# Global parameters for iNZight
# These can be adjusted here.

# Output graphics file format: "swf", "png" or "pdf"
Format <- "swf"

# Tables not produced if too many levels in any variable.
Table.threshold <- 10

# Minimum number of observations for which an Error bar will be shown
Errorbar.threshold <- 5

#Resolution <- 75
#Width.pixels <- 780

# General cex parameter.
par.cex <- 1


# Single categorical varible:  Barchart
Barchart1varCol <- hcl(120,35,64)  # Colour of bars.
BarchartBarCol <- 'black'          # Colour of error bars.


# Single continuous variable:  Boxplot and points
BoxColour <- 'black'  # Colour for lines of boxplot (not fill).
BoxBarCol <- 'red'    # Colour for Error Bars within Boxplots.
BoxPtCol <- "grey50"  # Colour for points above a boxplot  #hcl(240,35,52)


# Two continuous variables
Dots2varPtCol <- "black"  # Colour of points.

# New environment variable
e = new.env()

# Default values for plotting character size and color
e$basicCexScatter = par.cex
e$basicCexDot = par.cex
e$basicScatterColor = "black"  #Dots2varPtCol
e$basicDotColor = "grey50" #BoxPtCol

e$basicBackgroundDot = "white"
e$basicBackgroundScatter = "white"

e$scatterThickness1 = 1
e$scatterThickness2 = 2

e$basicPlottingCharScatter = 1 # pch=19: filled circle
e$basicPlottingCharDot = 1


# Max bubble size (in inches)
maxbubsize = 0.25 # default = maxbubsize = FALSE ie: inches = FALSE inside symbols()

# Number of bootstrap iterations
bootN = 1500

#small sample cutoff size for bootstrap
bootCutoff = 10


#Number of bootstrap trendlines in scatter plots
e$numBootLines = 30


# Control trendline/smoother color & level of transparency
e$alphaValue = 72   #82

e$smootherColor = "#8B0000" # darkred
e$linearColor =  "#0000FF"  # blue
e$quadColor = "#006400"     # darkgreen
e$cubicColor =  "#8B4500"   # darkorange4

# A list of boolean variables

  e$summaryButtonPressed = FALSE
  e$inferenceButtonPressed = FALSE

  e$removeAddIndices = NULL

  e$sliderCreated = FALSE
  e$sliderCreated2 = FALSE

  e$dndDisabled = FALSE

  e$inferenceMethod = "Normal"
  e$bootstrapInProgress = FALSE

  e$transformWinOpened = FALSE
  e$collapseWinOpened = FALSE
  e$combineWinOpened = FALSE
  e$convertWinOpened = FALSE
  e$trashWinOpened = FALSE
  e$addToPlotWin = FALSE
  e$reorderWinOpened = FALSE
  e$filterDataWinOpened = FALSE
  e$binNumericWinOpened = FALSE
  e$standardWinOpened = FALSE
  e$inferenceWinOpened = FALSE
  e$removeAddWinOpened = FALSE
  e$newVariableWinOpened = FALSE
  e$renameWinOpened = FALSE
  e$renameLWinOpened = FALSE
  e$renameVWinOpened = FALSE
  e$saveModelWinOpened = FALSE
  e$scatterPlotWinOpened = FALSE

  e$inDataView = FALSE

  e$dotChartView = FALSE
  e$scatterPlotView = FALSE



  e$drawBootLines = FALSE

  e$drawBoxPlots = TRUE
  e$drawBothInf = FALSE
  e$drawIntervals = FALSE
  e$useBootstrap = FALSE   # use bootstrap to draw the confidence/comparison intervals

  e$addSmoother = FALSE
  e$addYequalsX = FALSE
  e$addLinearTrend = FALSE
  e$addQuadTrend = FALSE
  e$addCubicTrend = FALSE

  e$fourthVariable = NULL  # This tells the graphs if there needs to be a different heading or not
  e$fourthVarName = ""

  e$fifthVariable = NULL
  e$fifthVarName= ""
  e$fifthVariableSubset = NULL
  e$fifthVariableNumeric = NULL

  e$sixthVariable = NULL
  e$sixthVariableSubset = NULL
  e$sixthVarName = ""

  e$segmentVariable = NULL
  e$segmentVarName= ""
  e$segmentVariableSubset = NULL
  e$segmentVariableNumeric = NULL

  e$addJitterX = FALSE
  e$addJitterY = FALSE
  e$addRugX = FALSE
  e$addRugY = FALSE
  e$addRugYhat = FALSE
  e$rugJitterButton = NULL


  e$presentRugOptions = FALSE
  e$presentJitterOptions = FALSE
  e$presentTrendOps = FALSE # relates to e$trendGp
  e$presentMoreVarOps = FALSE
  e$presentCustomOps = FALSE
  e$presentSmootherOps = FALSE

  e$smootherValue = 0.7

  e$joinByLines = FALSE



  options("guiToolkit"="RGtk2")

  OrigPath <<- getwd()

  #setwd("~")



# When bootstrap techniques would be put in make use of the enabled(e$win) = FALSE option this would freeze the entire window until all the iterations are done, and before the
# output/changes are carried out unfreeze it.

# --------------------------------------------------------------------------------
# Load the library that exports R objects to HTML files:
#library(R2HTML)


# Add a histogram to an existing plot.
# Arguments
#   x     : a vector of values
#   nints : number of intervals for histogram
#   base  : y-value for the base of the histogram
#   top   : y-value for the top of the highest histogram bar
#   histlwd : line width for histogram boxes
#   xlims : limits of x-axis
#   boxbordercol : colour of borders of histogram bars
#   shading : internal colour of bars
#   plot  : logical (not used?!)
#
addhist <- function(x,nints,base,top,histlwd=1,xlims,boxbordercol= "grey", shading="lightgrey", plot=TRUE) {
  if (missing(xlims)) {
    rngs <- range(x); rng <- rngs[2]-rngs[1]
    xlims <- rngs + c(-1,1)*0.5*rng/nints
  }
  breaks <- seq(xlims[1],xlims[2],length=nints+1)
  freqs <- table(cut(x,breaks))
  breaks <- breaks
  rect(breaks[-length(breaks)], base, breaks[-1], base+(top-base)*freqs/max(freqs),lwd=histlwd,border=boxbordercol, col="grey")
  invisible(list(breaks=breaks,freqs=freqs))
}


# Add an x-axis to an existing plot (within the plotting region).
# Arguments
#   xlims : limits of x-axis
#   ylev  : y-value of axis line (draws a horizontal line right across)
#   tickheight : size of ticks (on existing y-axis scale)
#   textdispl  : vertical displacement for text labels below axis line
#   nticks : number of ticks
#   axiscex : character expansion factor for axis
#   prettyx : not used?!
#
addaxis <- function(xlims, ylev, tickheight, textdispl, nticks=5, axiscex=1, prettyx) {
  abline(h=ylev)
  tts = pretty(xlims,n=nticks); tts = tts[tts>=xlims[1] & tts<=xlims[2]]
  for (i in 1:length(tts)) lines(tts[i]*c(1,1),ylev -c(0,tickheight))
  text(tts,(ylev-textdispl)*rep(1,length(tts)),as.character(tts),cex=axiscex)
}


# Generate a list of two vectors to use in plotting a univariate sample.
# Points are stacked in groups.
# Includes facility to have jagged (forward sloping) stacks of points.
# Arguments
#   x : vector of values
#   bins: vector of bin values (same length as x)
#
stacking <- function(x,bins) {
  oo <- order(x)
  x <- x[oo]; bins <- bins[oo]; bins <- factor(bins)
  xg <- split(x,bins)
  xo <- lapply(xg, seq_along)
  x <- unlist(xg, use.names = FALSE)
  du <- unlist(xo, use.names = FALSE)
  list(x=x,du=du)
}


# Create a density cloud for a univariate sample.  Returns the y-values.
# The y-values are derived from the density estimate so that the points
# form a random cloud within the density plot.
# Arguments
#    x   : a vector of values from a univariate sample
#    top : scale so the topmost point is this value
#
density.cloud <- function(x, top=NA) {
  dense <- density(x, na.rm=TRUE)
  h <- approx(dense$x, dense$y, x)$y * runif(length(x))
  if (!is.na(top))
    h <- top * h / max(h,na.rm=TRUE)
  h
}


# Add data points to an existing plot.  Points are stacked within bins.
# Arguments
#   x     : a vector of values
#   yval  : level of base line of points on the existing y-axis scale
#   vadd  : vertical distance to add below lowest line of points (and between stacked points)
#   vmax  : maximum vertical distance up from yval
#   xbin  : the bin identifiers for the x values (vector of same length as x)
#   ptcex : expansion factor for plotting points
#   ptcol : colour of points
#   ptlwd : line width of plotting symbols
#
addpoints <- function(x,yval,vadd,vmax,xbin,ptcex=e$basicCexDot, ptcol, ptlwd=2, ...) {
  if (!missing(xbin)) temp <- stacking(x,xbin) else temp <- list(x=x,du=rep(1,length(x)))
  vsp <- vmax/max(temp$du)  # Required spacing
  cramp <- vadd/vsp
#  if (cramp >= 2) { # too cramped!
#    y <- density.cloud(x,vmax) + yval
#    ptcex <- ptcex / sqrt(cramp)
#    ptlwd <- ptlwd / sqrt(cramp)
#  }
#  else
    y <- yval*rep(1,length(x))+vadd+min(vsp,vadd)*(temp$du-1)
  points(temp$x, y, col=ptcol,cex=ptcex,lwd=ptlwd, pch = e$basicPlottingCharDot)
}


# Add a (horizontal) boxplot box to an existing plot.
# Arguments
#   x5    : a vector of five values, as produced by fivenum() or boxplot.stats()
#   yval  : level on the y-axis scale for the centre of the box
#   hbxwdth : half box width, added either side of yval to create the box
#   medcol  : colour of the median line
#   boxcol  : colour of the box between lower and upper quartiles
#   whiskercol : colour of whiskers
#   boxfill    : colour to fill the box with (NA means don't fill it)
#   boxlwidth  : line width of the box
#   boxrelwidth: two values, relative width of median vs box and whiskers vs box
#
# Steve has a more general version taking a 5-column matrix and plotting many
# boxes, with all the medians remaining clearly visible.
#
addbox <- function(x5,yval,hbxwdth=0.3,medcol="black", boxcol="black",whiskercol="black",boxfill=NA, boxlwidth=1,boxrelwidth=c(2,0.7), ...) {

  if(e$sliderCreated && is.null(e$yVarData)){
    if(e$sliderData != 0 )
      hbxwdth = 0.09
  }


  rect( x5[2],yval-hbxwdth,x5[4],yval+hbxwdth,border=boxcol,lwd=boxlwidth,col=boxfill) # box
  lines(x5[3]*c(1,1),yval+hbxwdth*c(-1,1),col=medcol,lwd=boxrelwidth[1]*boxlwidth) # median
  lines(c(x5[1],x5[2]),yval*c(1,1),col=whiskercol,lwd=boxrelwidth[2]*boxlwidth) # whisker
  lines(c(x5[4],x5[5]),yval*c(1,1),col=whiskercol,lwd=boxrelwidth[2]*boxlwidth) # whisker
}

# Derive a vector of colours for plotting a categorical variable.
# Arguments:
#   x    : categorical vector
#   ...  : additional arguments (c, l, alpha) for hcl()
#
ptcolfn <- function(x, ...) {
  fcatvar <- as.factor(x)
  k <- length(levels(fcatvar))
  levels(fcatvar) <- hcl(h=seq(360/k,360,length=k),...)
  as.character(fcatvar)
}

# Derive a vector of plotting symbols for a categorical variable.
#
ptpchfn <- function(catvar) {
  as.integer(as.factor(catvar))
}

# Derive a sequence of n colours for barchart bars.
# Hue is evenly spaced, ending in red.
# Luminosity changes, to distinguish them when printed in black and white.
#
barcols <- function(n, chroma=50, lum1=60, lum2=30) {
  hcl(h=seq(360/n,360,length=n), c=chroma, l=seq(lum1,lum2,length=n))
}

# Create a plot for a sample from a continuous variable.
# Individual points are categorised and shown in jagged stacked groups.
# A boxplot summary and x-axis are also displayed.
#
# Arguments:
#   x      : vector of values
#   varname: label for x-axis
#   boxcol : colour of boxplot
#   ptcol  : colour of points
#   errorbarcol: colour for error bar within the box (NA means no bar)
#
boxpoints1 <- function(x, varname, boxcol='black', ptcol='grey50', errorbarcol = NA, noBox = FALSE) {
  x = x[!is.na(x)]
  xlims <- range(x) + 0.04*c(-1,1.5)*(max(x)-min(x)) ########################################### xlims     xlims <- range(x) + 0.04*c(-1,1)*(max(x)-min(x))

  if(!is.null(e$fifthVariable)) xlims[2] = xlims[2]+ 0.1*(xlims[2]-xlims[1])

  plot(xlims,c(-.02,1.02),type="n",xlab="",ylab="",axes=F)

  addaxis(xlims, ylev=0.2, tickheight=0.03, textdispl=0.07, nticks=5, axiscex=1)
  text(mean(xlims),0.02,varname,adj=0.5,cex=1)
  bxplt <- fivenum(x)   # boxplot.stats(x)$stat
  boxy = 0.32

  #boxfill=hcl(72,c=65,l=70)
  if(e$drawBoxPlots){
  addbox(x5=bxplt,yval=boxy,hbxwdth=0.08,
         boxcol=boxcol,medcol=boxcol,whiskercol=boxcol,boxfill=NA,
         boxlwidth=2)

    if (e$drawIntervals){   #(!is.na(errorbarcol))
      errorbarcol = BoxBarCol # remove this if the above is uncommented
      boxy = 0.32

      if(e$useBootstrap){ # should this condition go before or after the previous condition

            if((nobs <- length(x)) >= bootCutoff){
                  b = boot(x, getBoot1, R=bootN, estimate="median")

                  ci = boot.ci(b, type="perc")
                  ci.l = ci$percent[1,4]
                  ci.u = ci$percent[1,5]

                  #barsizeLower =
                  #barsizeUpper =
                  segments(ci.l, boxy, ci.u, boxy, col="darkgreen", lwd= 8, lend=1)

            }

      }else{
        if ((nobs <- length(x)) >= Errorbar.threshold) {
          if(e$drawBothInf){

  #            barsize <- 1.96 * sd(x) / sqrt(nobs-1)
  #            segments(bxplt[3] - barsize, boxy, bxplt[3] + barsize, boxy, col=errorbarcol,lwd=6,lend=1)

              barsizeSchool = 1.5 * (abs(bxplt[4]-bxplt[2])/sqrt(nobs))
              segments(bxplt[3] - barsizeSchool, boxy, bxplt[3] + barsizeSchool, boxy, col="blue", lwd= 8, lend=1)  ## Year 12 version ## make a decision on line width

          }else{

              barsizeSchool = 1.5 * (abs(bxplt[4]-bxplt[2])/sqrt(nobs))
              segments(bxplt[3] - barsizeSchool, boxy, bxplt[3] + barsizeSchool, boxy, col="blue", lwd= 8, lend=1)  ## Year 12 version
              #barsize <- 1.96 * sd(x) / sqrt(nobs-1)
  #            segments(bxplt[3] - barsize, boxy, bxplt[3] + barsize, boxy, col=errorbarcol, lwd=6, lend=1)
          }
        }
      }
    }
  }else{
    if (e$drawIntervals){
      errorbarcol = BoxBarCol # remove this if the above is uncommented

      if(e$useBootstrap){
            if((nobs <- length(x)) >= bootCutoff){
                  b = boot(x, getBoot1, R=bootN, estimate="mean")

                  ci = boot.ci(b, type="perc")
                  ci.l = ci$percent[1,4]
                  ci.u = ci$percent[1,5]

                  #barsizeLower =
                  #barsizeUpper =
                  segments(ci.l, boxy, ci.u, boxy, col="darkgreen", lwd= 8, lend=1)
                  lines(mean(x)*c(1,1),boxy+0.01*c(-1,1),col="white",lwd=1.5)


            }
      }else{
        if ((nobs <- length(x)) >= Errorbar.threshold) {
          if(e$drawBothInf){
            comparisonBar = (1/sqrt(2)) * (sd(x)/sqrt(nobs))
            segments(mean(x) - comparisonBar, boxy, mean(x) + comparisonBar, boxy, col=errorbarcol, lwd=8, lend=1)
            confidenceBar = qt(0.975, df = length(x)-1) * sd(x) / sqrt(nobs)
            segments(mean(x) - confidenceBar, boxy, mean(x) + confidenceBar, boxy, col=errorbarcol, lwd=3, lend=1) # make decision on line width
            lines(mean(x)*c(1,1),boxy+0.01*c(-1,1),col="black",lwd=1.5)
          }else{
            comparisonBar = (1/sqrt(2)) * (sd(x)/sqrt(nobs))
            segments(mean(x) - comparisonBar, boxy, mean(x) + comparisonBar, boxy, col=errorbarcol, lwd=3, lend=1)
            lines(mean(x)*c(1,1),boxy+0.01*c(-1,1),col="black",lwd=1.5)

          }
        }
      }
    }
  }
  prettyrange <- range(pretty(x))
  if(length(unique(x))==1)
    xbins = x
  else if (min(diff(sort(unique(x)))) >= diff(prettyrange)/75)
    xbins = x  # They are sufficiently well spaced to stack on each unique value
  else
    xbins = round(75 * (x-prettyrange[1])/diff(prettyrange))

  addpoints(x,yval=0.45,vmax=0.5,vadd=0.03,xbin=xbins,ptcex=e$basicCexDot, ptcol=ptcol,ptlwd=2)
}

# Create a plot from two variables, one continuous and one categorical.
# For each level of the categorical variable (grps) a stacked dot plot
# and a boxplot summary are created.
# A title, an x-axis and error bars are created by default but can be turned off.
#
boxpoints2 <- function(x,grps,varnames1,varnames2,
                       includeheader=TRUE, includeaxis=TRUE,
                       errorbarcol=NA, xlims, labeltext, prettyx,
                       boxfill=NA,ptcol='grey50')
{
  observed = (1:length(x))[!is.na(x) & !is.na(grps)]
  x = x[observed]
  grps = as.factor(grps[observed])
  ngrps = length(levels(grps))
  if (missing(xlims)) xlims <- range(x) + c(-0.2,0.1)*(max(x)-min(x))  ######################################################## changed Xlims  if (missing(xlims)) xlims <- range(x) + c(-0.2,0.04)*(max(x)-min(x))

  if(!is.null(e$fifthVariable)) xlims[2] = xlims[2]+ 0.1*(xlims[2]-xlims[1])


  top = 1.05; if (includeheader) top=top+0.05; if (!missing(labeltext)) top=top+0.05
  bottom = 0; if (includeaxis) bottom = -0.2
  plot(xlims,c(bottom,top),type="n",xlab="",ylab="",axes=F)
  yvals = ((1:ngrps)-0.7)/ngrps
  if (includeheader) {
    text(mean(xlims),top,paste(varnames1,"by",varnames2,sep=" "),cex=1,font=2)
  }
  text(xlims[1],top-0.05,varnames2,cex=1,adj=0)
  if (!missing(labeltext)) text(xlims[2],top-0.05,labeltext,cex=1,font=2,adj=1)
  if (includeaxis) {
    addaxis(xlims, ylev=0, tickheight=0.03, textdispl=0.07, nticks=5,axiscex=1)
    text(mean(xlims),-0.2,varnames1,adj=0.5,cex=1)
  }
  if (missing(prettyx)) prettyx = pretty(x)
  for (i in 1:ngrps) {
    xi = x[grps==levels(grps)[i]]
    if(length(ptcol) > 1){
      ptcol1 = ptcol[grps==levels(grps)[i]]
     # ptcol1 = rev(ptcol1)
    }else
      ptcol1 = ptcol

    #if(length(xi) != 0) #----------------------------------------------------------------- ADDED MAY 3rd
      text(xlims[1],yvals[i]+0.2/ngrps,substr(as.character(levels(grps)[i]),1,12),
      adj=0,cex=1)
    prettyrange <- range(pretty(xi))
    if (min(diff(sort(unique(xi)))) >= diff(prettyrange)/75)
      xbins = xi  # They are sufficiently well spaced.
    else {
      xbins = round(75 * (xi-prettyrange[1])/diff(prettyrange))
    }
    addpoints(xi,yval=yvals[i],vmax=0.62/ngrps,vadd=0.075/ngrps,
      xbin=xbins,ptcex=e$basicCexDot, ptcol=ptcol1,ptlwd=2)
    bxplt <- fivenum(xi)


#    if(length(xi) != 0) #----------------------------------------------------------------- ADDED MAY 3rd
#    addbox(x5=bxplt,yval=yvals[i],hbxwdth=0.2/ngrps,
#      boxcol="black",medcol="black",whiskercol="black",
#      boxlwidth=2,boxfill=boxfill) #hcl(72,c=65,l=70)

#    if(!is.na(errorbarcol) & length(xi)>10) {
#      barsize <- 1.96 * sd(xi) / sqrt(length(xi)-1)                                  ALL OF THIS COMMENTED OUT ON FRIDAY 13th AUGUST
#      segments(bxplt[3] - barsize, yvals[i], bxplt[3] + barsize, yvals[i],
#        col=errorbarcol,lwd=4,lend=1)
#    }

    if(e$drawBoxPlots){
      if(length(xi) != 0)
        addbox(x5=bxplt,yval=yvals[i],hbxwdth=0.2/ngrps,
               boxcol="black",medcol="black",whiskercol="black",boxfill=boxfill,
               boxlwidth=2)

        if (e$drawIntervals){   #(!is.na(errorbarcol))
          errorbarcol = BoxBarCol # remove this if the above is uncommented


          if(e$useBootstrap){
            if((nobs <- length(xi)) >= bootCutoff){
                  b = boot(xi, getBoot1, R=bootN, estimate="median")

                  ci = boot.ci(b, type="perc")
                  ci.l = ci$percent[1,4]
                  ci.u = ci$percent[1,5]

                  #barsizeLower =
                  #barsizeUpper =
                  segments(ci.l, yvals[i], ci.u, yvals[i], col="darkgreen", lwd= 8, lend=1)



            }
          }else{
            if ((nobs <- length(x)) >= Errorbar.threshold) {
              if(e$drawBothInf){

                  barsizeSchool = 1.5 * (abs(bxplt[4]-bxplt[2])/sqrt(nobs))
                  segments(bxplt[3] - barsizeSchool, yvals[i], bxplt[3] + barsizeSchool, yvals[i], col="blue", lwd= 8, lend=1)
      #            barsize <- 1.96 * sd(x) / sqrt(nobs-1)
      #            segments(bxplt[3] - barsize, boxy, bxplt[3] + barsize, boxy, col=errorbarcol,lwd=6,lend=1)
      #            barsizeSchool = 1.5 * (abs(bxplt[4]-bxplt[2])/sqrt(nobs))
      #            segments(bxplt[3] - barsizeSchool, boxy, bxplt[3] + barsizeSchool, boxy, col="green", lwd=0.7, lend=1)  # make a decision on line width
              }else{
                  barsizeSchool = 1.5 * (abs(bxplt[4]-bxplt[2])/sqrt(nobs))
                  segments(bxplt[3] - barsizeSchool, yvals[i], bxplt[3] + barsizeSchool, yvals[i], col="blue", lwd= 8, lend=1)

              }
            }
          }
        }
    }else{
      if (e$drawIntervals){
        errorbarcol = BoxBarCol # remove this if the above is uncommented
        yvals = ((1:ngrps)-0.9)/ngrps


        if(e$useBootstrap){
            if((nobs <- length(xi)) >= bootCutoff){
                  b = boot(xi, getBoot1, R=bootN, estimate="mean")

                  ci = boot.ci(b, type="perc")
                  ci.l = ci$percent[1,4]
                  ci.u = ci$percent[1,5]

                  #barsizeLower =
                  #barsizeUpper =
                  segments(ci.l, yvals[i], ci.u, yvals[i], col="darkgreen", lwd= 8, lend=1)
                  lines(mean(xi)*c(1,1),yvals[i]+0.01*c(-1,1),col="white",lwd=1.5)


            }
        }else{
          if ((nobs <- length(xi)) >= Errorbar.threshold) {
            if(e$drawBothInf){
              comparisonBar = (1/sqrt(2)) * (sd(xi)/sqrt(nobs))
              segments(mean(xi) - comparisonBar, yvals[i], mean(xi) + comparisonBar, yvals[i], col=errorbarcol, lwd=8, lend=1)
              confidenceBar = qt(0.975, df = length(xi)-1) * sd(xi) / sqrt(nobs)
              segments(mean(xi) - confidenceBar, yvals[i], mean(xi) + confidenceBar, yvals[i], col=errorbarcol, lwd=3, lend=1) # make decision on line width
              lines(mean(xi)*c(1,1),yvals[i]+0.01*c(-1,1),col="black",lwd=1.5)
            }else{
              comparisonBar = (1/sqrt(2)) * (sd(xi)/sqrt(nobs))
              segments(mean(xi) - comparisonBar, yvals[i], mean(xi) + comparisonBar, yvals[i], col=errorbarcol, lwd=8, lend=1)
              lines(mean(xi)*c(1,1),yvals[i]+0.01*c(-1,1),col="black",lwd=1.5)

            }
          }
        }
      }
    }
  }
}

# Create a plot, with histogram, boxplot summary and x-axis
# for a vector sample from a continuous variable.
#
boxhist1 <- function(x,varname) {
    x = x[!is.na(x)]
    xlims <- range(x)
    plot(xlims,c(0,1),type="n",xlab="",ylab="",axes=F)
    addaxis(xlims, ylev=0.2, tickheight=0.03, textdispl=0.1, nticks=5,axiscex=1)
    text(mean(xlims),0.02,varname,adj=0.5,cex=1)
    bxplt <- boxplot.stats(x)$stats
    addbox(x5=bxplt,yval=0.4,hbxwdth=0.08,boxcol="black",medcol="black",whiskercol="black",boxlwidth=3)
    addhist(x,nints=20,base=0.5,top=1.0,xlims=xlims,boxbordercol= "black", shading="lightgrey")
}




# --------------------------------------------------------------------------------
# Create a covariance matrix for a vector of estimated proportions from
# a categorical variable.
#
proportion.covs <- function(tbl, phat=tbl/sum(tbl), n=sum(tbl)) {
  covs = -outer(phat,phat) / n
  diag(covs) = phat * (1 - phat) / n
  covs
}


# --------------------------------------------------------------------------------
# Approximate standard error bar sizes, based on paired contrasts.
# Derived from the covariance matrix for a vector of estimates.
#
# Given a k*k covariance matrix, solve a linear model
# to estimate an error bar size for each of the k parameters.
#
errorbarsize = function(Covs) {
  stopifnot(is.matrix(Covs))
  stopifnot((k <- nrow(Covs)) == ncol(Covs))  # Must be square.
  Vars = diag(Covs)
  if (k < 3)
    return(sqrt(Vars))
  mat = matrix(0,nr=k,nc=k)
  keep = col(Covs) > row(Covs)  # Upper triangle, above diag.
  k2 = sum(keep)
  Xr = row(mat)[keep]
  Xc = col(mat)[keep]
  X = outer(1:k2, 1:k, function(x,y) {y==Xr[x] | y==Xc[x]})
  Y = sqrt(outer(Vars,Vars,"+") - 2*Covs)[keep]
  return(drop(solve(crossprod(X)) %*% t(X) %*% Y))
}


# --------------------------------------------------------------------------------
# Create a SWF file from a PDF file, turning pages into animated frames.
# This is achieved via a system command pdf2swf from SWFTOOLS.
#
# Arguments
#    pdf       : filename of PDF to convert
#    framerate : number of animation frames per second (or 0 for static pages)
#    rm.pdf    : delete the pdf file if the swf was created successfully?
#
# Value
#    filename of resulting SWF file, or NULL if not created
#
pdf2swf <- function(pdf, framerate=20, rm.pdf=FALSE) {
  cmd <- "/opt/swftools/bin/pdf2swf"   # option  -s transparent  doesn't work
  if(file.exists(cmd)) {
    swf <- paste(pdf,".swf",sep='')
    swf <- gsub("[.]pdf[.]swf$",".swf", swf, ignore.case=TRUE)
    if (framerate==0) framerate <- " --stop --viewer /opt/swftools/share/swftools/swfs/keyboard_viewer.swf  "
    else framerate <- paste(" -s framerate=", framerate, " ", sep='')
    cmd <- paste(cmd, framerate, pdf, " -o ", swf, " > /dev/null", sep='')
    res <- system(cmd)
    if (res==0) {
      if (rm.pdf & file.exists(swf)) file.remove(pdf)
      return(swf)
    }
  }
  NULL
}



verticalTable.1 = function(x, pc=TRUE, digits=2, ...){

  counts <- table(x)
  res <- data.frame(
    Count=format(c(counts, sum(counts)),sci=FALSE),
    Percent=paste(format(c(round(100 * counts / sum(counts), digits), 100)),"%",sep=""),
    stringsAsFactors=FALSE
  )

  rownames(res) <- c(names(counts),"Total")
  if(pc) as.matrix(res) else as.matrix(res[,1,drop=FALSE])

}

verticalTable.2 = function(x1,x2, pc=TRUE, digits=2, ...){

  tbl <- table(x1,x2)
  Rowsums <- rowSums(tbl)
  Colsums <- c(colSums(tbl), sum(colSums(tbl)))

  if (pc) {
    tbl[] <- 100 * sweep(tbl,1,Rowsums,"/")
    tbl <- cbind(tbl, Total=rowSums(tbl))
    tbl[] <- paste(format(round(tbl,digits=digits),trim=TRUE,nsmall=digits),"%",sep="")
    tbl <- cbind(tbl, "Row N" = Rowsums)

    tbl[tbl=="NaN%"] <- ""
  }else {
    tbl <- cbind(tbl, "Row Total"=Rowsums)
    tbl <- rbind(tbl, "Col Total"=Colsums)
  }
  tbl <- tbl[Rowsums>0,,drop=FALSE]
  as.matrix(tbl)
}





addSumm = function(datafile, varnames, vartypes, factorLevel){

  #dframe = apply(dframe, 2, function(x) replace(x, which((any(x %in% c("NULL","NA","N/A","N/A",""," ",NA,"<NA>"))) || (nchar(dframe[,i]) == 0)), NA))

  dframe = datafile

  for(i in 1:ncol(dframe)){
    dframe[,i] = replace(dframe[,i],which((any(dframe[,i] %in% c("NULL","NA","N/A","N/A",""," ",NA,"<NA>"))) || (nchar(dframe[,i]) == 0)), NA)
    #\if(is.factor(datafile[,i])) datafile[,i] = factor(datafile[,i], exclude = c(NA, "<NA>", "NA", ""))
  }


  #dframe = na.omit(dframe)      #-------------------#-------------------#--------------------#-------------------#

                                 #-------------------#-------------------#-------22 November 2010-------#-------------------#

                                 #-------------------#-------------------#--------------------#-------------------#
   fifthVarSubset = NULL
   fifthVarNumeric = NULL
   segmentVarSubset = NULL
   sixthVarSubset = NULL


  if(e$scatterPlotView || e$dotChartView){
    if(!is.null(e$fifthVariable)){
      dframe = cbind(dframe, fifthVarSubset = e$fifthVariableSubset)
      if(!is.null(e$fifthVariableNumeric))
        dframe = cbind(dframe, fifthVarNumeric = e$fifthVariableNumeric)
    }
  }
  if(e$scatterPlotView){
    if(!is.null(e$sixthVariable))
      dframe = cbind(dframe, sixthVarSubset = e$sixthVariableSubset)
  }

  if(!e$scatterPlotView && !e$dotChartView){
    if(!is.null(e$segmentVariable)){
      dframe = cbind(dframe, segmentVarSubset = e$segmentVariableSubset)
    }
  }


  dframe = na.omit(dframe)

  if(e$scatterPlotView || e$dotChartView){
    if(!is.null(e$fifthVariable)){
      fifthVarSubset = dframe[,"fifthVarSubset"]

      if(!is.null(e$fifthVariableNumeric))
        fifthVarNumeric = dframe[,"fifthVarNumeric"]

    }
  }
  if(e$scatterPlotView){
    if(!is.null(e$segmentVariable)){
      segmentVarSubset = dframe[,"segmentVarSubset"]

    }
  }
  if(!e$scatterPlotView && !e$dotChartView){
    if(!is.null(e$sixthVariable))
      sixthVarSubset = dframe[,"sixthVarSubset"]
  }


  dframe = data.frame(dframe[,1:ncol(datafile)])
  colnames(dframe) = varnames




  summWin = gwindow("Summaries Window", width = 530, container = TRUE, parent = e$win)
  summaryArea = gtext(expand = TRUE, wrap = FALSE)


  if(!is.null(e$fourthVariable))
    insert(summaryArea, paste("For the subset of data where", e$fourthVarName, "=", (levels(e$fourthVariable)[e$sliderData2])) , font.attr=c(style = "monospace", weights = "bold", color = "black", sizes="large"))


  if(length(vartypes)==1) {

    v1 = dframe[,1]

    if(vartypes[1] == "CONT"){
      sum.v1 = summary(v1)
      values = as.vector(sum.v1)

      summ.table = cbind(t(matrix(values)),round(sd(v1),3), length(v1), deparse.level = 0)
      colnames(summ.table) = c(names(sum.v1),"Std.dev", "Sample.Size")
      rownames(summ.table) = rep("",nrow(summ.table))
      insert(summaryArea, "\n")
      command = paste("Summary of",varnames)
      insert(summaryArea, command, font.attr=c(style = "monospace", color = "blue", sizes="large"))
      out = capture.output(eval(summ.table))
      insert(summaryArea, out, font.attr=c(style = "monospace", sizes="medium"))
    }else{

      nv1 = length(levels(v1))

    # table of counts
      if(nv1 > Table.threshold)  # Vert table for CAT with many levels
        summ.table = verticalTable.1(v1, pc=FALSE)
      else # Horizontal table for CAT with many levels
        summ.table = t(verticalTable.1(v1, pc=FALSE))

      out = capture.output(matprint(summ.table))
      insert(summaryArea, paste("Table of counts :", varnames), font.attr=c(style = "monospace", color = "blue", sizes="medium"))
      insert(summaryArea, out, font.attr=c(style = "monospace", color = "darkgreen", sizes="medium"))

    # frequency table
      if(nv1 > Table.threshold)  # Vert table for CAT with many levels
        summ.table = verticalTable.1(v1, pc=TRUE)
      else  # Horizontal table for CAT with many levels
        summ.table = t(verticalTable.1(v1, pc=TRUE))

      out = capture.output(matprint(summ.table))
      insert(summaryArea, paste("\n\nFrequency table :", varnames), font.attr=c(style = "monospace", color = "blue", sizes="medium"))
      insert(summaryArea, out, font.attr=c(style = "monospace", color = "darkgreen", sizes="medium"))
    }

  }else if(length(vartypes) == 2){

    if((vartypes[1] == "CONT" && vartypes[2] == "CAT") || (vartypes[1] == "CAT" && vartypes[2] == "CONT")){

      v1 = dframe[,1]
      f1 = factor(dframe[,1])
      if(vartypes[1] == "CONT")
        f1 = factor(dframe[,2])
      else
        v1 = dframe[,2]


      summ.table = t(sapply(split(v1,f1),summary))
      sd.col = sapply(split(v1,f1),sd)
      samp.size = sapply(split(v1,f1),length)
      summ.table = cbind(summ.table, Std.dev = round(sd.col,3), Sample.Size = samp.size)

      insert(summaryArea, "\n")
      command = paste("Summary of", varnames[vartypes == "CONT"],"by",varnames[vartypes == "CAT"])
      insert(summaryArea, command, font.attr=c(style = "monospace", color = "red", sizes="large"))
      out = capture.output(eval(summ.table))
      insert(summaryArea, out, font.attr=c(style = "monospace", sizes="medium"), do.newline = TRUE)

# If one variable is continuous and the other is categorical
# The 7 number summary is produced for each level of the factor

      fit = parse(text = paste("lm(", varnames[vartypes == "CONT"], " ~ ", varnames[vartypes == "CAT"], ", data = dframe)", collapse = ""))
      anovaSumm = capture.output(anova(eval(fit)))
#      insert(summaryArea, "\n\n", font.attr=c(style = "monospace", color = "black", sizes="large"))
#      insert(summaryArea, anovaSumm, font.attr=c(style = "monospace", color = "black", sizes="large"))

    }else if(vartypes[1] == "CONT" && vartypes[2] == "CONT"){

      v1 = dframe[,1]
      v2 = dframe[,2]

      if(e$addLinearTrend || e$addQuadTrend || e$addCubicTrend){
        if(e$addLinearTrend){

          insert(summaryArea, "Linear Trend\n", font.attr=c(style = "monospace", color = "red", sizes="large"))
          fit = eval(parse(text = paste("lm(", varnames[2], " ~ ", varnames[1], ", data = dframe)", collapse = "")))
          insert(summaryArea, paste(varnames[2], "=", round(coef(fit)[2],2), "*", varnames[1], "+", round(coef(fit)[1],2)), font.attr=c(style = "monospace", color = "black", sizes="large"))
          insert(summaryArea, paste("Correlation =", round(cor(v1,v2),2)), font.attr=c(style = "monospace", color = "black", sizes="large"))
          insert(summaryArea, "\n")

        }
        if(e$addQuadTrend){

          insert(summaryArea, "Quadratic Trend\n", font.attr=c(style = "monospace", color = "red", sizes="large"))
          fit <-  eval(parse(text = paste("lm(", varnames[2], " ~ ", varnames[1], "+","I(", varnames[1], "^2)", ", data = dframe)", collapse = "")))
          B <- coef(fit)
          insert(summaryArea, paste(varnames[2], "=", round(B[2],2), "*", varnames[1], "+", round(B[3],2), "*", paste(varnames[1], "^2", sep = ""), "+", round(B[1],2)), font.attr=c(style = "monospace", color = "black", sizes="large"))
          insert(summaryArea, "\n")

        }
        if(e$addCubicTrend){

          insert(summaryArea, "Cubic Trend\n", font.attr=c(style = "monospace", color = "red", sizes="large"))
          fit <-  eval(parse(text = paste("lm(", varnames[2], " ~ ", varnames[1], "+","I(", varnames[1], "^2)","+","I(", varnames[1], "^3)", ", data = dframe)", collapse = "")))
          B <- coef(fit)
          insert(summaryArea, paste(varnames[2], "=", round(B[2],2), "*", varnames[1], "+", round(B[3],2), "*", paste(varnames[1], "^2", sep = ""), "+", round(B[4],2), "*", paste(varnames[1], "^3", sep = ""), "+", round(B[1],2)), font.attr=c(style = "monospace", color = "black", sizes="large"))
          insert(summaryArea, "\n")

        }
      }else{

        insert(summaryArea, "\nAdd trend lines to the scatter plot in order to get a summary.\n", font.attr=c(style = "monospace", color = "blue", sizes="large"))
        insert(summaryArea, "(Use the Add To Plot feature at the bottom of the graphics window)", font.attr=c(style = "monospace", color = "blue", sizes="medium"))
      }


    }else{
      if(all(vartypes == 'CAT')){

      v1 = dframe[,1]
      v2 = dframe[,2]
      # table of counts
        if(length(levels(v1))<Table.threshold & length(levels(v2))<Table.threshold)
          summ.table = verticalTable.2(v2,v1, pc=FALSE)
        else # Horizontal table for CAT with many levels
          summ.table = t(verticalTable.2(v2,v1, pc=FALSE))

        out = capture.output(matprint(summ.table))
        insert(summaryArea, paste("Table of counts :", varnames[1], "by", varnames[2]), font.attr=c(style = "monospace", color = "blue", sizes="medium"))
        insert(summaryArea, out, font.attr=c(style = "monospace", color = "darkgreen", sizes="medium"))

      # frequency table
        if(length(levels(v1))<Table.threshold & length(levels(v2))<Table.threshold)
          summ.table = verticalTable.2(v2,v1, pc=TRUE)
        else  # Horizontal table for CAT with many levels
          summ.table = t(verticalTable.2(v2,v1, pc=TRUE))

        out = capture.output(matprint(summ.table))
        insert(summaryArea, paste("\n\nFrequency table :", varnames[1], "by", varnames[2]), font.attr=c(style = "monospace", color = "blue", sizes="medium"))
        insert(summaryArea, out, font.attr=c(style = "monospace", color = "darkgreen", sizes="medium"))


      }
    }

  }else if(length(vartypes) == 3){

    twoFactors = FALSE
    emptySecondVariable = FALSE
    c1 = 0
    f1 = 0
    f2 = 0

    if(all(vartypes == c('CONT','CAT','CAT'))){
      c1 = dframe[,1]; cont = varnames[1]
      f1 = factor(dframe[,2]); fact1 = varnames[2]
      f2 = factor(dframe[,3]); fact2 = varnames[3]
      twoFactors = TRUE

    }else if(all(vartypes == c('CAT','CONT','CAT'))){
      c1 = dframe[,2]; cont = varnames[2]
      f1 = factor(dframe[,1]); fact1 = varnames[1]
      f2 = factor(dframe[,3]); fact2 = varnames[3]
      twoFactors = TRUE
    }else if(all(vartypes == c('CONT','EMPTY','CAT'))){
      emptySecondVariable = TRUE
      c1 = dframe[,1]; cont = varnames[1]
      f2 = factor(dframe[,2]); fact2 = varnames[2]
    }

    if(e$scatterPlotView){

      f2 = factor(dframe[,3])
      fact2 = varnames[3]
      lvls = levels(f2)

      # Incorporating slider information (so that summary is only shown for the chosen level)
      if(factorLevel != 0)
         lvls = lvls[factorLevel]

      y = dframe[,varnames[2]]
      x = dframe[,varnames[1]]
      if(e$addLinearTrend || e$addQuadTrend || e$addCubicTrend){
        for(i in 1:length(lvls)){

          y.subset = y[(f2 == lvls[i])]
          x.subset = x[(f2 == lvls[i])]

          insert(summaryArea, paste("\nSummary for", varnames[3], "=", lvls[i],"\n") , font.attr=c(style = "monospace", weights = "bold", color = "black", sizes="large"))
            if(e$addLinearTrend){

              insert(summaryArea, "Linear Trend\n", font.attr=c(style = "monospace", color = "red", sizes="large"))
              fit = lm(y.subset ~ x.subset)
              insert(summaryArea, paste(varnames[2], "=", round(coef(fit)[2],2), "*", varnames[1], "+", round(coef(fit)[1],2)), font.attr=c(style = "monospace", color = "black", sizes="medium"))
              insert(summaryArea, paste("Correlation =", round(cor(y.subset,x.subset),2)), font.attr=c(style = "monospace", color = "black", sizes="medium"))
              insert(summaryArea, "\n")

            }

            if(e$addQuadTrend){

              insert(summaryArea, "Quadratic Trend\n", font.attr=c(style = "monospace", color = "red", sizes="large"))
              fit = lm(y.subset ~ x.subset + I(x.subset^2))
              B = coef(fit)
              insert(summaryArea, paste(varnames[2], "=", round(B[2],2), "*", varnames[1], "+", round(B[3],2), "*", paste(varnames[1], "^2", sep = ""), "+", round(B[1],2)), font.attr=c(style = "monospace", color = "black", sizes="medium"))
              insert(summaryArea, "\n")

            }

            if(e$addCubicTrend){

              insert(summaryArea, "Cubic Trend\n", font.attr=c(style = "monospace", color = "red", sizes="large"))
              fit <- lm(y.subset ~ x.subset + I(x.subset^2) + I(x.subset^3))
              B <- coef(fit)
              insert(summaryArea, paste(varnames[2], "=", round(B[2],2), "*", varnames[1], "+", round(B[3],2), "*", paste(varnames[1], "^2", sep = ""), "+", round(B[4],2), "*", paste(varnames[1], "^3", sep = ""), "+", round(B[1],2)), font.attr=c(style = "monospace", color = "black", sizes="medium"))
              insert(summaryArea, "\n")

            }


        }

      }else{
          insert(summaryArea, "\nAdd trend lines to the scatter plot in order to get a summary.\n", font.attr=c(style = "monospace", color = "blue", sizes="large"))
          insert(summaryArea, "(Use the Add To Plot feature at the bottom of the graphics window)", font.attr=c(style = "monospace", color = "blue", sizes="medium"))
      }

    }

    if(twoFactors){

      #lvls = unique(f2)
      lvls = levels(f2)

      # Incorporating slider information (so that summary is only shown for the chosen level)
      if(factorLevel != 0)
         lvls = lvls[factorLevel]


      for(i in 1:length(lvls)){
        c1.subset = c1[(f2 == lvls[i])]
        f1.subset = f1[(f2 == lvls[i])]

        division = split(c1.subset,f1.subset)

        summ.matrix = t(matrix(summary(as.numeric(division[[1]]))))


        sd.col = matrix(round(sd(as.numeric(division[[1]])),3))
        samp.size.col = matrix(length(as.numeric(division[[1]])))
        summ.matrix = cbind(summ.matrix, sd.col, samp.size.col)

        for(j in 2:length(unique(f1))){
          summ.table  = t(summary(as.numeric(division[[j]])))

          sd.col = matrix(round(sd(as.numeric(division[[j]])),3))
          samp.size.col = matrix(length(as.numeric(division[[j]])))
          summ.table = cbind(summ.table, sd.col, samp.size.col)

          summ.matrix = rbind(summ.matrix, summ.table)

        }

        rownames(summ.matrix) = levels(factor(f1))
        colnames(summ.matrix) = c(names(summary(as.numeric(division[[1]]))),"Std.dev", "Sample.Size")

        insert(summaryArea, "\n")
        command = paste("Summary of", cont, "by", fact1, "for", fact2, "=", lvls[i])
        insert(summaryArea, command, font.attr=c(style = "monospace", color = "magenta", sizes="medium"))
        out = capture.output(eval(summ.matrix))
        insert(summaryArea, out, font.attr=c(style = "monospace", sizes="medium"))


      }

    }
    else if(emptySecondVariable){
      lvls = levels(f2)

      if(factorLevel != 0)
         lvls = lvls[factorLevel]


      for(i in 1:length(lvls)){
        c1.subset = c1[(f2 == lvls[i])]
        summ.matrix = t(matrix(summary(as.numeric(c1.subset))))
        sd.col = matrix(round(sd(as.numeric(c1.subset)),3))
        samp.size = matrix(length(as.numeric(c1.subset)))
        summ.matrix = cbind(summ.matrix, sd.col, samp.size)

        rownames(summ.matrix) = cont   #lvls[i]
        colnames(summ.matrix) = c(names(summary(as.numeric(c1.subset))),"Std.dev", "Sample.Size")

        insert(summaryArea, "\n")
        command = paste("Summary of", cont, "for", fact2, "=", lvls[i])
        insert(summaryArea, command, font.attr=c(style = "monospace", color = "darkblue", sizes="medium"))
        out = capture.output(eval(summ.matrix))
        insert(summaryArea, out, font.attr=c(style = "monospace", sizes="medium"))


      }


    }else{


     if(all(vartypes == c('CAT','CAT','CAT'))){
        v1 = dframe[,1]
        v2 = dframe[,2]
        f3 = factor(dframe[,3]) ###------------------------------ should there be a factor() here to get rid of the unnecessary levels? 29th September 2010

        lvls = levels(f3)

        # Incorporating slider information (so that summary is only shown for the chosen level)
        if(factorLevel != 0)
           lvls = lvls[factorLevel]


        for(i in 1:length(lvls)){
          v1.subset = v1[(f3 == lvls[i])]  # should there be factor() here to get rid of unnecessary levels?
          v2.subset = v2[(f3 == lvls[i])]  # should there be factor() here to get rid of unnecessary levels?

          # table of counts
          if(length(levels(v1.subset))<Table.threshold & length(levels(v2.subset))<Table.threshold)
            summ.table = verticalTable.2(v2.subset,v1.subset, pc=FALSE)
          else # Horizontal table for CAT with many levels
            summ.table = t(verticalTable.2(v2.subset,v1.subset, pc=FALSE))

            out = capture.output(matprint(summ.table))
            insert(summaryArea, paste("\nTable of counts :", varnames[1], "by", varnames[2], "for", varnames[3], "=", lvls[i]), font.attr=c(style = "monospace", color = "blue", sizes="medium"))
            insert(summaryArea, out, font.attr=c(style = "monospace", color = "darkgreen", sizes="medium"))

          # frequency table
          if(length(levels(v1.subset))<Table.threshold & length(levels(v2.subset))<Table.threshold)
            summ.table = verticalTable.2(v2.subset,v1.subset, pc=TRUE)
          else  # Horizontal table for CAT with many levels
            summ.table = t(verticalTable.2(v2.subset,v1.subset, pc=TRUE))

          out = capture.output(matprint(summ.table))
          insert(summaryArea, paste("\n\nFrequency table :", varnames[1], "by", varnames[2], "for", varnames[3], "=", lvls[i]), font.attr=c(style = "monospace", color = "blue", sizes="medium"))
          insert(summaryArea, out, font.attr=c(style = "monospace", color = "darkgreen", sizes="medium"))

          if(length(lvls) != 1 || i != length(lvls)) insert(summaryArea, "-----------------------------------------------------------------------", font.attr = c(style = "monospace"))

        }


      }else if(all(vartypes == c('CAT','EMPTY','CAT'))){


        v1 = dframe[,1]
        f3 = factor(dframe[,2])

        lvls = levels(f3)

        # Incorporating slider information (so that summary is only shown for the chosen level)
        if(factorLevel != 0)
           lvls = lvls[factorLevel]


        for(i in 1:length(lvls)){

          v1.subset = v1[(f3 == lvls[i])]  # should there be factor() here to get rid of unnecessary levels? No because the graphs already show them
          nv1 = length(levels(v1.subset))

        # table of counts
          if(nv1 > Table.threshold)  # Vert table for CAT with many levels
            summ.table = verticalTable.1(v1.subset, pc=FALSE)
          else # Horizontal table for CAT with many levels
            summ.table = t(verticalTable.1(v1.subset, pc=FALSE))

          out = capture.output(matprint(summ.table))
          insert(summaryArea, paste("\nTable of counts :", varnames[1], "for", varnames[2], "=", lvls[i]), font.attr=c(style = "monospace", color = "blue", sizes="medium"))
          insert(summaryArea, out, font.attr=c(style = "monospace", color = "darkgreen", sizes="medium"))

        # frequency table
          if(nv1 > Table.threshold)  # Vert table for CAT with many levels
            summ.table = verticalTable.1(v1.subset, pc=TRUE)
          else  # Horizontal table for CAT with many levels
            summ.table = t(verticalTable.1(v1.subset, pc=TRUE))

          out = capture.output(matprint(summ.table))
          insert(summaryArea, paste("\n\nFrequency table :", varnames[1], "for", varnames[2], "=", lvls[i]), font.attr=c(style = "monospace", color = "blue", sizes="medium"))
          insert(summaryArea, out, font.attr=c(style = "monospace", color = "darkgreen", sizes="medium"))

          if(length(lvls) != 1 || i != length(lvls)) insert(summaryArea, "-----------------------------------------------------------------------", font.attr = c(style = "monospace"))
        }

      }
    }
  }

  insert(summaryArea, "_______________________________________________________________________", font.attr = c(style = "monospace"))
  add(summWin, summaryArea, expand = TRUE)

}

bootstrapData = function(samp, statsType = "basic", iterations = bootN){

  for(i in 1:iterations){


  }
}
triangularMatrix = function(factorLvls, output, statType){

  statsMatrix = as.matrix(output)
  colNames = colnames(statsMatrix)

  condition = FALSE
  if(!is.null(colNames)){ if(colnames(statsMatrix) == c("Estimate", "Tukey.L", "Tukey.U", "Tukey.p")) condition = TRUE else condition = FALSE
  }else{condition = FALSE}

  if(statType == "estimates"){
    if(condition)
      values = statsMatrix[,1]
    else
      values = statsMatrix[1,]

  }else if (statType == "p-values"){
    if(condition)
      values = statsMatrix[,4]
    else
      values = statsMatrix[4,]

  }else if(statType == "ci"){
    count = 1; i = count
    if(condition){

      values = numeric(nrow(statsMatrix)*2)
      while(count < nrow(statsMatrix)+1){

        values[c(i,i+1)] = c(statsMatrix[count,2], statsMatrix[count,3])
        count = count + 1
        i = i+2
      }
    }else{
      values = numeric(ncol(statsMatrix)*2)
      while(count < ncol(statsMatrix)+1){

        values[c(i,i+1)] = c(statsMatrix[2,count], statsMatrix[3,count])
        count = count + 1
        i = i+2
      }
    }
  }


  num = length(factorLvls)
  newMatrix = matrix(NA, ncol = num, nrow = num)

  if(statType %in% c("estimates", "p-values")){
    stopAt = 0
    for(i in 1:num){
      if(i == 1) startAt = 1
      stopAt = (stopAt-i)+num

      if(i == num) extra = numeric(0)
      else extra = values[startAt:stopAt]

      newMatrix[,i] =  format(c(rep("",num+i-num), round(extra,4)), width = 5, justify = "r")
     #\c(rep("",num+i-num), round(extra,4))
      startAt = stopAt + 1
    }
    rownames(newMatrix) = factorLvls
    colnames(newMatrix) = factorLvls
    x = ncol(newMatrix)
    newMatrix = as.matrix(newMatrix[-1, -x])

    if(x == 2) newMatrix = t(newMatrix)
    rownames(newMatrix) = factorLvls[2:length(factorLvls)]
    colnames(newMatrix) = factorLvls[1:(length(factorLvls) -1)]


  }else if (statType == "ci"){

    stopAt = 0
    doubleNum = num*2
    newMatrix = matrix(NA, ncol = num, nrow = doubleNum)

    for(i in 1:num){
      if(i == 1) startAt = 1
      stopAt = (stopAt-i*2) + doubleNum

      if(i == num) extra = numeric(0)
      else extra = values[startAt:stopAt]

      newMatrix[,i] =  format(c(rep("",(doubleNum+i-doubleNum)*2), round(extra,4)), width = 5, justify = "r")
      startAt = stopAt + 1
    }
    rowNames = rep("",doubleNum)
    temp = 1:doubleNum
    rowNames[(temp%%2 != 0)] = factorLvls

    #rownames(newMatrix) = rowNames
    #colnames(newMatrix) = factorLvls

    x = ncol(newMatrix)
    newMatrix = as.matrix(newMatrix[-(1:2), -x])   #unwanted rows and columns are removed because they give no information
    #if(x == 2) newMatrix = t(newMatrix)

    rownames(newMatrix) = rowNames[-c(1,2)]
    colnames(newMatrix) = factorLvls[-x]


  }

  newMatrix

}

################################################################################
################################################################################
################################################################################
################################################################################
################################################################################


showInf = function(datafile, varnames, vartypes, factorLevel){

  # enabled(e$win) = FALSE until the bootstrapping is done. Should this happen separately in each section or a blanket effect?
  # September 1st - implement try error blocks just in case an error disrupts everything 90% DONE any other errors can only be detected through testing



  #dframe = na.omit(dframe)  #----------------------#------------------------#--------------------#
                             #----------------------#---------22 November 2010-----#--------------------#
                             #----------------------#------------------------#--------------------#

  fifthVarSubset = NULL
  fifthVarNumeric = NULL
  segmentVarSubset = NULL
  sixthVarSubset = NULL

  dframe = datafile

  if(e$scatterPlotView || e$dotChartView){
    if(!is.null(e$fifthVariable)){
      dframe = cbind(dframe, fifthVarSubset = e$fifthVariableSubset)
      if(!is.null(e$fifthVariableNumeric))
        dframe = cbind(dframe, fifthVarNumeric = e$fifthVariableNumeric)
    }
  }
  if(e$scatterPlotView){
    if(!is.null(e$sixthVariable))
      dframe = cbind(dframe, sixthVarSubset = e$sixthVariableSubset)
  }

  if(!e$scatterPlotView && !e$dotChartView){
    if(!is.null(e$segmentVariable)){
      dframe = cbind(dframe, segmentVarSubset = e$segmentVariableSubset)
    }
  }


  dframe = na.omit(dframe)

  if(e$scatterPlotView || e$dotChartView){
    if(!is.null(e$fifthVariable)){
      fifthVarSubset = dframe[,"fifthVarSubset"]

      if(!is.null(e$fifthVariableNumeric))
        fifthVarNumeric = dframe[,"fifthVarNumeric"]

    }
  }
  if(e$scatterPlotView){
    if(!is.null(e$segmentVariable)){
      segmentVarSubset = dframe[,"segmentVarSubset"]

    }
  }
  if(!e$scatterPlotView && !e$dotChartView){
    if(!is.null(e$sixthVariable))
      sixthVarSubset = dframe[,"sixthVarSubset"]
  }


  dframe = data.frame(dframe[,1:ncol(datafile)])
  colnames(dframe) = varnames




  infWin = gwindow("Inference Information", width = 530, container = TRUE, parent = e$win)    # width = 530, height = 150
  infArea = gtext(expand = TRUE, wrap = FALSE)

  addHandlerUnrealize(infWin, handler = function(h,...){
                              if(e$bootstrapInProgress){
                                #e$bootstrapInProgress = TRUE its status needs to be changed
                                val <- gconfirm("Bootstrap simulations in progress!\nAre you sure you want to close the window? ", parent=h$obj)
                                if(as.logical(val))
                                  return(FALSE)		# destroy  # enable all components that were disabled  and stop the bootstrapping
                                else
                                  return(TRUE)		# don't destroy
                              }
                            })

  insert(infArea, "\n")
  insert(infArea, paste("Method used to generate inference:", ifelse(e$inferenceMethod == "Normal", "Normal theory", "Bootstrap theory"), "\n") , font.attr=c(style = "monospace", color = "navy", weights = "bold", sizes="large"))


  if(!is.null(e$fourthVariable))
    insert(infArea, paste("\nFor the subset of data where", e$fourthVarName, "=", (levels(e$fourthVariable)[e$sliderData2])) , font.attr=c(style = "monospace", weights = "bold", color = "black", sizes="large"))

  twoFactors = FALSE
  emptySecondVariable = FALSE

  if(length(vartypes)==1) {

    if(vartypes[1] == "CONT"){

      v1 = dframe[,1]
      n = length(v1)
      mu = round(mean(v1),2)
      med = round(median(v1),2)
      iqr = round(summary(v1)[5]/summary(v1)[2],2)

      if(e$inferenceMethod == "Normal"){
          if(n > 1){
            insert(infArea, paste("\n",varnames, sep = ""), font.attr=c(style = "monospace", color = "navy", weights = "bold", size = "medium"))
            insert(infArea, "\nGroup Means with 95% Confidence Intervals", font.attr=c(style = "monospace", color = "blue", size = "medium"))
            error = round(qt(0.975, df = n-1) * (sd(v1)/sqrt(n)),2)
            infMatrix = capture.output(matprint(as.matrix(data.frame(ci.lower = mu - error, estimate = mu, ci.upper = mu + error))))
            insert(infArea, eval(infMatrix), font.attr = c(style = "monospace", color = "darkgreen", size = "medium"))
          }else insert(infArea, "No Inference Output (Not Enough Observations)", font.attr=c(style = "monospace", color = "black", size = "medium"))

      }else{

          if(n > bootCutoff){
            enabled(e$inferenceButton) = FALSE
            insert(infArea, paste("\n",varnames, sep = ""), font.attr=c(style = "monospace", color = "navy", weights = "bold", size = "medium"))


            b = boot(v1, getBoot1, R=bootN, estimate="all")
            ci.mean = boot.ci(b, type="perc", index=1)
            ci.med = boot.ci(b, type="perc", index=2)
            ci.iqr = boot.ci(b, type="perc", index=3)

            ci.l.mean = round(ci.mean$percent[1,4],2)
            ci.u.mean = round(ci.mean$percent[1,5],2)
            ci.l.med = round(ci.med$percent[1,4],2)
            ci.u.med = round(ci.med$percent[1,5],2)
            ci.l.iqr = round(ci.iqr$percent[1,4],2)
            ci.u.iqr = round(ci.iqr$percent[1,5],2)

            #data.frame(mean = mu, ci.lower = ci.l.mean, ci.upper = ci.u.mean, median = med, ci.lower = ci.l.med, ci.upper = ci.u.med, inter.quartile.range = iqr, ci.lower = ci.l.iqr, ci.upper = ci.u.iqr)
            insert(infArea, "\nGroup Means with Percentile Bootstrap Confidence Intervals", font.attr=c(style = "monospace", color = "blue", size = "medium"))
            infMatrix = capture.output(matprint(as.matrix(data.frame(ci.lower = ci.l.mean, estimate = mu,  ci.upper = ci.u.mean, row.names = varnames))))
            insert(infArea, eval(infMatrix), font.attr = c(style = "monospace", color = "darkgreen", size = "medium"))

            insert(infArea, "\nGroup Medians with Percentile Bootstrap Confidence Intervals", font.attr=c(style = "monospace", color = "blue", size = "medium"))
            infMatrix = capture.output(matprint(as.matrix(data.frame(ci.lower = ci.l.med, estimate = med, ci.upper = ci.u.med, row.names = varnames))))
            insert(infArea, eval(infMatrix), font.attr = c(style = "monospace", color = "darkgreen", size = "medium"))


            insert(infArea, "\nGroup Inter-Quartile-Ranges with Percentile Bootstrap Confidence Intervals", font.attr=c(style = "monospace", color = "blue", size = "medium"))
            infMatrix = capture.output(matprint(as.matrix(data.frame(ci.lower = ci.l.iqr, estimate = iqr, ci.upper = ci.u.iqr, row.names = varnames))))
            insert(infArea, eval(infMatrix), font.attr = c(style = "monospace", color = "darkgreen", size = "medium"))

            enabled(e$inferenceButton) = TRUE

          }else insert(infArea, "No Inference Output (Number of observations less than the bootstrap cutoff)", font.attr=c(style = "monospace", color = "black", size = "medium"))





       # Before starting the bootstrap disable anything that might be used to interrupt the process
       # If using enabled(e$win) = FALSE  then make sure that it is enabled before printing out the output!

       #enabled(e$win) = FALSE

      }

    }else{
      v1f = dframe[,1]
      n = length(v1f)

      if(e$inferenceMethod == "Normal"){
       #Just a table with ci.lower, proportion, ci.upper for each level of the factor
        if(n > 1){

          tbl = table(v1f)
          phat = tbl / n
          se <- sqrt(phat * (1 - phat)/n)
          qval = 1.96
          infMatrix = capture.output(matprint(matrix(c(round(phat - qval * se, 2), round(phat, 2), round(phat + qval * se, 2)), nc = 3, dimnames = list(levels(v1f), c("ci.lower", "estimate", "ci.upper")))))
          insert(infArea, paste("\n",varnames, sep = ""), font.attr=c(style = "monospace", color = "navy", weights = "bold", size = "medium"))
          insert(infArea, "\nProportions with 95% Confidence Intervals", font.attr=c(style = "monospace", color = "blue", size = "medium"))
          insert(infArea, eval(infMatrix), font.attr = c(style = "monospace", color = "darkgreen", size = "medium"))


          if(length(levels(v1f))>1){
            insert(infArea, "\n\nDifferences Between Proportions (col - row)", font.attr=c(style = "monospace", color = "blue", sizes = "medium"), do.newline = TRUE)
            insert(infArea, "\nEstimates", font.attr=c(style = "monospace", color = "black"), do.newline = TRUE)
            insert(infArea, eval(capture.output(matprint(freq1way.edited(tbl, "estimates")))), font.attr = c(style = "monospace", color = "darkgreen", size = "medium"))
            insert(infArea, "\n")
            insert(infArea, "95% Confidence Intervals", font.attr=c(style = "monospace", color = "black"))
            insert(infArea, eval(capture.output(matprint(freq1way.edited(tbl, "ci")))), font.attr = c(style = "monospace", color = "darkgreen", size = "medium"))

            #testForUniformity = try(capture.output(chisq.test(tbl)))
            testForUniformity = try(capture.output(chiSquareTest(tbl)))
            if(!inherits(testForUniformity,"try-error")){
              insert(infArea, "\n")
              #insert(infArea, eval(testForUniformity), font.attr = c(style = "monospace", color = "black", size = "medium"))
              insert(infArea, "Chi-square test for equal probabilities\n", font.attr=c(style = "monospace", color = "black"))
              insert(infArea, eval(testForUniformity), font.attr = c(style = "monospace", color = "darkgreen", size = "medium"))
              insert(infArea, "\n")
            }

          }


        }else{
          out = "No Inference included"
          insert(infArea, out, font.attr=c(style = "monospace", color = "black", sizes="large"))
        }
       } # else do bootstrap
    }

  }else if(length(vartypes) == 2){

    if(e$dotChartView){
    #if((vartypes[1] == "CONT" && vartypes[2] == "CAT") || (vartypes[1] == "CAT" && vartypes[2] == "CONT")){

      v1 = dframe[,1]
      f1 = factor(dframe[,1])
      if(vartypes[1] == "CONT")
        f1 = factor(dframe[,2])
      else
        v1 = dframe[,2]

        if(!is.null(e$fourthVariable) && e$fourthVarName == varnames[vartypes == "CAT"]){

          n = length(v1)
          mu = round(mean(v1),2)
          med = round(median(v1),2)
          iqr = round(summary(v1)[5]/summary(v1)[2],2)


          if(e$inferenceMethod == "Normal"){
            if(n > 1){
              insert(infArea, paste("\n", varnames[vartypes == "CONT"], sep = ""), font.attr=c(style = "monospace", color = "navy", weights = "bold", size = "medium"))
              insert(infArea, "\nGroup Means with 95% Confidence Intervals", font.attr=c(style = "monospace", color = "blue", size = "medium"))
              error = round(qt(0.975, df = n-1) * (sd(v1)/sqrt(n)),2)
              infMatrix = capture.output(matprint(as.matrix(data.frame(ci.lower = mu - error, estimate = mu, ci.upper = mu + error))))  #, row.names = ""
              insert(infArea, eval(infMatrix), font.attr = c(style = "monospace", color = "darkgreen", size = "medium"))
            }else insert(infArea, "\n\nNo Inference Output (Not Enough Observations)", font.attr=c(style = "monospace", color = "black", size = "medium"))
          }else{

             if(n > bootCutoff){
                  enabled(e$inferenceButton) = FALSE
                  insert(infArea, paste("\n", varnames[vartypes == "CONT"], sep = ""), font.attr=c(style = "monospace", color = "navy", weights = "bold", size = "medium"))

                  b = boot(v1, getBoot1, R=bootN, estimate="all")
                  ci.mean = boot.ci(b, type="perc", index=1)
                  ci.med = boot.ci(b, type="perc", index=2)
                  ci.iqr = boot.ci(b, type="perc", index=3)

                  ci.l.mean = round(ci.mean$percent[1,4],2)
                  ci.u.mean = round(ci.mean$percent[1,5],2)
                  ci.l.med = round(ci.med$percent[1,4],2)
                  ci.u.med = round(ci.med$percent[1,5],2)
                  ci.l.iqr = round(ci.iqr$percent[1,4],2)
                  ci.u.iqr = round(ci.iqr$percent[1,5],2)

                  #data.frame(mean = mu, ci.lower = ci.l.mean, ci.upper = ci.u.mean, median = med, ci.lower = ci.l.med, ci.upper = ci.u.med, inter.quartile.range = iqr, ci.lower = ci.l.iqr, ci.upper = ci.u.iqr)
                  insert(infArea, "\nGroup Means with Percentile Bootstrap Confidence Intervals", font.attr=c(style = "monospace", color = "blue", size = "medium"))
                  infMatrix = capture.output(matprint(t(as.matrix(data.frame(ci.lower = ci.l.mean, estimate = mu,  ci.upper = ci.u.mean, row.names = levels(f1)[e$sliderData])))))
                  insert(infArea, eval(infMatrix), font.attr = c(style = "monospace", color = "darkgreen", size = "medium"))

                  insert(infArea, "\nGroup Medians with Percentile Bootstrap Confidence Intervals", font.attr=c(style = "monospace", color = "blue", size = "medium"))
                  infMatrix = capture.output(matprint(t(as.matrix(data.frame(ci.lower = ci.l.med, estimate = med, ci.upper = ci.u.med, row.names = levels(f1)[e$sliderData])))))
                  insert(infArea, eval(infMatrix), font.attr = c(style = "monospace", color = "darkgreen", size = "medium"))


                  insert(infArea, "\nGroup Inter-Quartile-Ranges with Percentile Bootstrap Confidence Intervals", font.attr=c(style = "monospace", color = "blue", size = "medium"))
                  infMatrix = capture.output(matprint(t(as.matrix(data.frame(ci.lower = ci.l.iqr, estimate = iqr, ci.upper = ci.u.iqr, row.names = levels(f1)[e$sliderData])))))
                  insert(infArea, eval(infMatrix), font.attr = c(style = "monospace", color = "darkgreen", size = "medium"))

                  enabled(e$inferenceButton) = TRUE

                }else insert(infArea, "No Inference Output (Number of observations less than the bootstrap cutoff)", font.attr=c(style = "monospace", color = "black", size = "medium"))

          }
        #}
        }else{
         # Do t-test if factor has only two levels if not do a repetition for above for all levels (WHAT ABOUT ANOVA?)


         if(e$inferenceMethod == "Normal"){
           fit = try(eval(parse(text = paste("lm(", varnames[vartypes == "CONT"], "~", varnames[vartypes == "CAT"], ", data = dframe)", collapse = ""))))

           if(inherits(fit,"try-error")){ insert(infArea, "Need more than 1 group OR not enough observations", font.attr=c(style = "monospace", color = "black", sizes="medium"), do.newline = TRUE)

           }else{
            levelNames = levels(f1)
            if(length(levelNames) == 2){ #Welsh test

#              insert(infArea, "\n")
#              inf.table = try(capture.output(eval(parse(text = paste("t.test(", varnames[vartypes == "CONT"], " ~ ",  varnames[vartypes == "CAT"], ", data = dframe, var.equal = FALSE)")))))
#              if(inherits(inf.table,"try-error")) insert(infArea, "Not enough observations in the group(s) for a t-test", font.attr=c(style = "monospace", color = "black", sizes="medium"), do.newline = TRUE)
#              else insert(infArea, inf.table, font.attr=c(style = "monospace", color = "darkgreen", sizes="medium"), do.newline = TRUE)

            }

              inf.table = matrix(".", nrow = length(levelNames), ncol = 3, dimnames = list(levelNames, c("ci.lower", "estimate", "ci.upper")))

              for(i in 1:length(levelNames)){
                v1.subset = v1[f1 == levelNames[i]]
                n = length(v1.subset)
                if(n > 1){
                  mu = round(mean(v1.subset),2)
                  error = round(qt(0.975, df = n-1) * (sd(v1.subset)/sqrt(n)),2)
                  inf.table[i,] = c(mu - error, mu, mu + error)
                }else{
                  mu = round(mean(v1.subset),2)
                  inf.table[i,] = c("-", ifelse(is.nan(mu), "-", mu), "-")
                }
              }

            out = capture.output(matprint(inf.table))
            insert(infArea, "\n\n")
            command = paste(varnames[vartypes == "CONT"],"by",varnames[vartypes == "CAT"], "\n")
            insert(infArea, command, font.attr=c(style = "monospace", color = "navy", weights = "bold", sizes="medium"))
            insert(infArea, "\nGroup Means with 95% Confidence Intervals", font.attr=c(style = "monospace", color = "blue", size = "medium"))

            insert(infArea, eval(out), font.attr=c(style = "monospace", color = "darkgreen", sizes="medium"), do.newline = TRUE)
            #insert(infArea, "_______________________________________________________________________\n", font.attr=c(style = "monospace", sizes="medium", color = "blue"), do.newline = TRUE)


            multiple.table = try(multipleComp(fit))
            if(!inherits(multiple.table,"try-error")){

              if(nrow(as.matrix(multiple.table)) == 1){
                out = capture.output(eval(multiple.table))
                insert(infArea, out, font.attr=c(style = "monospace"), do.newline = TRUE)
              }else{
                if(length(levels(f1)) > 1){

                  insert(infArea, "\nDifferences Between Group Means (col - row)", font.attr=c(style = "monospace", color = "blue", sizes = "medium"), do.newline = TRUE)

                  insert(infArea, "\nEstimates", font.attr=c(style = "monospace", color = "black"), do.newline = TRUE)
                  out = capture.output(matprint(triangularMatrix(levels(f1),  multiple.table, "estimates")))
                  insert(infArea, out, font.attr=c(style = "monospace", color = "darkgreen"), do.newline = TRUE)

                  insert(infArea, "\n\n95% Confidence Intervals", font.attr=c(style = "monospace", color = "black"), do.newline = TRUE)
                  insert(infArea, "(Adjusted for multiple comparison)\n", font.attr=c(style = "monospace", color = "black"), do.newline = TRUE)
                  out = capture.output(matprint(triangularMatrix(levels(f1), multiple.table, "ci")))
                  insert(infArea, out, font.attr=c(style = "monospace", color = "darkgreen"), do.newline = TRUE)


                  insert(infArea, "\n\np-values", font.attr=c(style = "monospace", color = "black"), do.newline = TRUE)
                  out = capture.output(matprint(triangularMatrix(levels(f1), multiple.table, "p-values")))
                  insert(infArea, out, font.attr=c(style = "monospace", color = "darkgreen"), do.newline = TRUE)



              }
             }
            }
           }
        }else{
            insert(infArea, "\n")
            command = paste(varnames[vartypes == "CONT"],"by",varnames[vartypes == "CAT"], "\n")
            insert(infArea, command, font.attr=c(style = "monospace", color = "navy", weights = "bold", sizes="medium"))

            levelNames = levels(f1)
            inf.table1 = matrix(".", nrow = length(levelNames), ncol = 3, dimnames = list(levelNames, c("ci.lower", "estimate", "ci.upper")))
            inf.table2 = matrix(".", nrow = length(levelNames), ncol = 3, dimnames = list(levelNames, c("ci.lower", "estimate", "ci.upper")))
            inf.table3 = matrix(".", nrow = length(levelNames), ncol = 3, dimnames = list(levelNames, c("ci.lower", "estimate", "ci.upper")))


            for(i in 1:length(levelNames)){


              v1.subset = v1[f1 == levelNames[i]]
              n = length(v1.subset)
              mu = round(mean(v1.subset),2)
              med = round(median(v1.subset),2)
              iqr = round(summary(v1.subset)[5]/summary(v1.subset)[2],2)


              if(n > bootCutoff){

                enabled(e$inferenceButton) = FALSE
                b = boot(v1.subset, getBoot1, R=bootN, estimate="all")
                ci.mean = boot.ci(b, type="perc", index=1)
                ci.med = boot.ci(b, type="perc", index=2)
                ci.iqr = boot.ci(b, type="perc", index=3)

                ci.l.mean = round(ci.mean$percent[1,4],2)
                ci.u.mean = round(ci.mean$percent[1,5],2)
                ci.l.med = round(ci.med$percent[1,4],2)
                ci.u.med = round(ci.med$percent[1,5],2)
                ci.l.iqr = round(ci.iqr$percent[1,4],2)
                ci.u.iqr = round(ci.iqr$percent[1,5],2)


                inf.table1[i,] = c(ci.l.mean, mu, ci.u.mean)
                inf.table2[i,] = c(ci.l.med, mu, ci.u.med)
                inf.table3[i,] = c(ci.l.iqr, iqr, ci.u.iqr)



              }else{

                inf.table1[i,] = c("-", ifelse(is.nan(mu), "-", mu), "-")
                inf.table2[i,] = c("-", ifelse(is.nan(med), "-", med), "-")
                inf.table3[i,] = c("-", ifelse(is.nan(iqr), "-", iqr), "-")

              }
            }

            #insert(infArea, "\n")
            #data.frame(mean = mu, ci.lower = ci.l.mean, ci.upper = ci.u.mean, median = med, ci.lower = ci.l.med, ci.upper = ci.u.med, inter.quartile.range = iqr, ci.lower = ci.l.iqr, ci.upper = ci.u.iqr)
            insert(infArea, "\nGroup Means with Percentile Bootstrap Confidence Intervals", font.attr=c(style = "monospace", color = "blue", size = "medium"))
            infMatrix = capture.output(matprint(inf.table1))
            insert(infArea, eval(infMatrix), font.attr = c(style = "monospace", color = "darkgreen", size = "medium"))

            insert(infArea, "\nGroup Medians with Percentile Bootstrap Confidence Intervals", font.attr=c(style = "monospace", color = "blue", size = "medium"))
            infMatrix = capture.output(matprint(inf.table2))
            insert(infArea, eval(infMatrix), font.attr = c(style = "monospace", color = "darkgreen", size = "medium"))


            insert(infArea, "\nGroup Inter-Quartile-Ranges with Percentile Bootstrap Confidence Intervals", font.attr=c(style = "monospace", color = "blue", size = "medium"))
            infMatrix = capture.output(matprint(inf.table3))
            insert(infArea, eval(infMatrix), font.attr = c(style = "monospace", color = "darkgreen", size = "medium"))
            enabled(e$inferenceButton) = TRUE


        }
       }

    }else if(vartypes[1] == "CONT" && vartypes[2] == "CONT"){

        if(e$scatterPlotView){
          if(e$inferenceMethod == "Normal"){
            if(e$addLinearTrend || e$addQuadTrend || e$addCubicTrend){
                if(e$addLinearTrend){
                  insert(infArea, "Linear Trend\n", font.attr=c(style = "monospace", color = "blue", sizes="medium"))
                  fit = eval(parse(text = paste("lm(", varnames[2], " ~ ", varnames[1], ", data = dframe)", collapse = "")))
                  insert(infArea, paste("Slope",  "=", round(coef(fit)[2],2), "   p-value =", signif(coef(summary(fit))[8],5) ), font.attr=c(style = "monospace", color = "darkgreen", sizes="medium"))
                  insert(infArea, paste("Intercept =", round(coef(fit)[1],2)), font.attr=c(style = "monospace", color = "darkgreen", sizes="medium"))
                  insert(infArea, "\n")
                  insert(infArea, "Confidence Intervals =", font.attr=c(style = "monospace", color = "black", sizes="medium"))
                  insert(infArea, capture.output(ciReg(fit)), font.attr=c(style = "monospace", color = "darkgreen", sizes="medium"))
                  insert(infArea, "\n")

              }
              if(e$addQuadTrend){
                insert(infArea, "Quadratic Trend\n", font.attr=c(style = "monospace", color = "blue", sizes="medium"))
                out = "No Inference included\n"
                insert(infArea, out, font.attr=c(style = "monospace", color = "darkgreen", sizes="medium"))
              }
              if(e$addCubicTrend){
                insert(infArea, "Cubic Trend\n", font.attr=c(style = "monospace", color = "blue", sizes="medium"))
                out = "No Inference included"
                insert(infArea, out, font.attr=c(style = "monospace", color = "darkgreen", sizes="medium"))
              }
            }else{
              insert(infArea, "\nAdd trend lines to the scatter plot in order to get an inference.\n", font.attr=c(style = "monospace", color = "blue", sizes="large"))
              insert(infArea, "(Use the Add To Plot feature at the bottom of the graphics window)", font.attr=c(style = "monospace", color = "blue", sizes="medium"))

            }
          }else{
             if(e$addLinearTrend || e$addQuadTrend || e$addCubicTrend){
                if(e$addLinearTrend){
                  insert(infArea, "Linear Trend\n", font.attr=c(style = "monospace", color = "blue", sizes="medium"))
                  fit = eval(parse(text = paste("lm(", varnames[2], " ~ ", varnames[1], ", data = dframe)", collapse = "")))

                  b = boot(dframe, getBoot2, R=bootN, yname = varnames[2], xname = varnames[1])
                  ci.slope = boot.ci(b, type="perc", index=1)
                  ci.intercept = boot.ci(b, type="perc", index=2)
                  ci.corr = boot.ci(b, type="perc", index=3)

                  ci.l.slope = round(ci.slope$percent[1,4],2)
                  ci.u.slope = round(ci.slope$percent[1,5],2)
                  ci.l.intercept = round(ci.intercept$percent[1,4],2)
                  ci.u.intercept = round(ci.intercept$percent[1,5],2)
                  ci.l.corr = round(ci.corr$percent[1,4],2)
                  ci.u.corr = round(ci.corr$percent[1,5],2)


                  #inf.table1 = c(ci.l.slope, round(coef(fit)[2],2), ci.u.slope)
                  insert(infArea, "\nSlope with Percentile Bootstrap Confidence Intervals", font.attr=c(style = "monospace", color = "black", size = "medium"))
                  infMatrix = capture.output(matprint(as.matrix(data.frame(ci.lower = ci.l.slope, estimate = round(coef(fit)[2],2), ci.upper = ci.u.slope, row.names = "slope"))))
                  insert(infArea, eval(infMatrix), font.attr = c(style = "monospace", color = "darkgreen", size = "medium"))

                  #inf.table2 = c(ci.l.intercept, round(coef(fit)[1],2), ci.u.intercept)
                  insert(infArea, "\nIntercept with Percentile Bootstrap Confidence Intervals", font.attr=c(style = "monospace", color = "black", size = "medium"))
                  infMatrix = capture.output(matprint(as.matrix(data.frame(ci.lower = ci.l.intercept, estimate = round(coef(fit)[1],2), ci.upper = ci.u.intercept, row.names = "intercept"))))
                  insert(infArea, eval(infMatrix), font.attr = c(style = "monospace", color = "darkgreen", size = "medium"))

                  #inf.table3 = c(ci.l.corr, round(cor(dframe[,varnames[2]], dframe[,varnames[1]]),2) , ci.u.corr)
                  insert(infArea, "\nCorrelation with Percentile Bootstrap Confidence Intervals", font.attr=c(style = "monospace", color = "black", size = "medium"))
                  infMatrix = capture.output(matprint(as.matrix(data.frame(ci.lower = ci.l.corr, estimate = round(cor(dframe[,varnames[2]], dframe[,varnames[1]]),2), ci.upper = ci.u.corr, row.names = "correlation"))))
                  insert(infArea, eval(infMatrix), font.attr = c(style = "monospace", color = "darkgreen", size = "medium"))

              }
              if(e$addQuadTrend){
                insert(infArea, "Quadratic Trend\n", font.attr=c(style = "monospace", color = "blue", sizes="medium"))
                out = "No Inference included\n"
                insert(infArea, out, font.attr=c(style = "monospace", color = "darkgreen", sizes="medium"))
              }
              if(e$addCubicTrend){
                insert(infArea, "Cubic Trend\n", font.attr=c(style = "monospace", color = "blue", sizes="medium"))
                out = "No Inference included"
                insert(infArea, out, font.attr=c(style = "monospace", color = "darkgreen", sizes="medium"))
              }
            }else{
              insert(infArea, "\nAdd trend lines to the scatter plot in order to get an inference.\n", font.attr=c(style = "monospace", color = "blue", sizes="large"))
              insert(infArea, "(Use the Add To Plot feature at the bottom of the graphics window)", font.attr=c(style = "monospace", color = "blue", sizes="medium"))

            }

          }
        }



    }else{
    # This situation would always be a barchart but it's better to check
    # The first and second variables must be flipped to match the analysis step
      if(all(vartypes == c('CAT','CAT'))){

        v1 = factor(dframe[,2])
        v2 = factor(dframe[,1])

        nv1 = length(levels(v2))
        tbl = table(v2,v1)
        Rowsums = rowSums(tbl)
        phat = sweep(tbl, 1, Rowsums, "/")
        nrt = nrow(tbl)

        if(e$inferenceMethod == "Normal"){


          for(r in 1:nrt){
            insert(infArea, "\n")
            insert(infArea, paste(varnames[2], "by", varnames[1], "=",  levels(v2)[r], "\n"), font.attr=c(style = "monospace", color = "navy", weights = "bold", sizes="medium"), do.newline = TRUE)
            insert(infArea, "\nProportions with 95% Confidence Intervals", font.attr=c(style = "monospace", color = "blue", size = "medium"))
            phat.sub = phat[r,]
            tbl.sub = tbl[r,]
            if(Rowsums[r] > 1){

              se <- sqrt(phat.sub * (1 - phat.sub)/Rowsums[r])
              qval = 1.96
              infMatrix = capture.output(matprint(matrix(c(round(phat.sub - qval * se, 2), round(phat.sub, 2), round(phat.sub + qval * se, 2)), nc = 3, dimnames = list(levels(v1), c("ci.lower", "estimate", "ci.upper")))))
              insert(infArea, eval(infMatrix), font.attr = c(style = "monospace", color = "darkgreen", size = "medium"))

              if(length(levels(v1))>1){
                insert(infArea, paste("\n\nDifferences Between Proportions For", varnames[2], "=", levels(v2)[r], "(col - row)"), font.attr=c(style = "monospace", color = "blue", sizes = "medium"), do.newline = TRUE)

                insert(infArea, "\nEstimates", font.attr=c(style = "monospace", color = "black"), do.newline = TRUE)
                insert(infArea, eval(capture.output(matprint(freq1way.edited(tbl.sub, "estimates")))), font.attr = c(style = "monospace", color = "darkgreen", size = "medium"))
                insert(infArea, "\n")
                insert(infArea, "95% Confidence Intervals", font.attr=c(style = "monospace", color = "black"))
                insert(infArea, eval(capture.output(matprint(freq1way.edited(tbl.sub, "ci")))), font.attr = c(style = "monospace", color = "darkgreen", size = "medium"))

                #testForUniformity = try(capture.output(chisq.test(tbl.sub)))
                testForUniformity = try(capture.output(chiSquareTest(tbl.sub)))
                if(!inherits(testForUniformity,"try-error")){
                    insert(infArea, "\n")
                    #insert(infArea, eval(testForUniformity), font.attr = c(style = "monospace", color = "black", size = "medium"))
                    insert(infArea, "Chi-square test for equal probabilities\n", font.attr=c(style = "monospace", color = "black"))
                    insert(infArea, eval(testForUniformity), font.attr = c(style = "monospace", color = "darkgreen", size = "medium"))
                    insert(infArea, "\n")

                }

              }


            }else{
              out = "No Inference included"
              insert(infArea, out, font.attr=c(style = "monospace", color = "black", sizes="medium"))
            }
          }

        }
      }
    }

  }else if(length(vartypes) == 3){

    c1 = 0
    f1 = 0
    f2 = 0
    twoFactors = FALSE
    emptySecondVariable = FALSE

    if(all(vartypes == c('CONT','CAT','CAT'))){
      c1 = dframe[,1]; cont = varnames[1]
      f1 = dframe[,2]; fact1 = varnames[2]
      f2 = factor(dframe[,3]); fact2 = varnames[3]
      twoFactors = TRUE

    }else if(all(vartypes == c('CAT','CONT','CAT'))){
      c1 = dframe[,2]; cont = varnames[2]
      f1 = dframe[,1]; fact1 = varnames[1]
      f2 = factor(dframe[,3]); fact2 = varnames[3]
      twoFactors = TRUE
    }else if(all(vartypes == c('CONT','EMPTY','CAT'))){
      emptySecondVariable = TRUE
      c1 = dframe[,1]; cont = varnames[1]
      f2 = factor(dframe[,2]); fact2 = varnames[2]

    }

    if(e$scatterPlotView){


      f2 = factor(dframe[,3])
      fact2 = varnames[3]
      lvls = levels(f2)


      if(factorLevel != 0)
         lvls = lvls[factorLevel]

      y = dframe[,varnames[2]]
      x = dframe[,varnames[1]]

      if(e$inferenceMethod == "Normal"){
        if(e$addLinearTrend || e$addQuadTrend || e$addCubicTrend){
          for(i in 1:length(lvls)){

            y.subset = y[(f2 == lvls[i])]
            x.subset = x[(f2 == lvls[i])]

            insert(infArea, paste("\nInference for", varnames[3], "=", lvls[i],"\n") , font.attr=c(style = "monospace", weights = "bold", color = "black", sizes="large"))

              if(e$addLinearTrend){

                insert(infArea, "Linear Trend\n", font.attr=c(style = "monospace", color = "blue", sizes="medium"))
                fit = lm(y.subset ~ x.subset)
                insert(infArea, paste("Slope",  "=", round(coef(fit)[2],2), "   p-value =", signif(coef(summary(fit))[8],5) ), font.attr=c(style = "monospace", color = "darkgreen", sizes="medium"))
                insert(infArea, paste("Intercept =", round(coef(fit)[1],2)), font.attr=c(style = "monospace", color = "darkgreen", sizes="medium"))
                insert(infArea, "\n")
                insert(infArea, "Confidence Intervals =", font.attr=c(style = "monospace", color = "black", sizes="medium"))
                insert(infArea, capture.output(ciReg(fit)), font.attr=c(style = "monospace", color = "darkgreen", sizes="medium"))
                insert(infArea, "\n")

              }

              if(e$addQuadTrend){

                insert(infArea, "Quadratic Trend\n", font.attr=c(style = "monospace", color = "blue", sizes="medium"))
                out = "No Inference included\n"
                insert(infArea, out, font.attr=c(style = "monospace", color = "darkgreen", sizes="medium"))

              }

              if(e$addCubicTrend){

                insert(infArea, "Cubic Trend\n", font.attr=c(style = "monospace", color = "blue", sizes="medium"))
                out = "No Inference included"
                insert(infArea, out, font.attr=c(style = "monospace", color = "darkgreen", sizes="medium"))

              }

            }

          }else{

            insert(infArea, "\nAdd trend lines to the scatter plot in order to get an inference.\n", font.attr=c(style = "monospace", color = "blue", sizes="large"))
            insert(infArea, "(Use the Add To Plot feature at the bottom of the graphics window)", font.attr=c(style = "monospace", color = "blue", sizes="medium"))
          }
      }else{

        #bootstrap
      }

    }



    if(twoFactors){

      lvls = levels(factor(f2))  ## --------lvls = levels(f2)--------------------- Changed 23rd of September

      if(factorLevel != 0)
         lvls = lvls[factorLevel]

      levelNames = levels(f1)

      #if(is.null(e$fourthVariable)){   ## ----------------------------- Changed 23rd of September

           if(e$inferenceMethod == "Normal"){
              for(i in 1:length(lvls)){
                c1.subset = c1[f2 == lvls[i]]
                f1.subset = f1[(f2 == lvls[i])]
                inf.table = matrix(".", nrow = length(levelNames), ncol = 3, dimnames = list(levelNames, c("ci.lower", "estimate", "ci.upper")))
                insert(infArea, "\n")
                insert(infArea, paste(cont, "by", fact1, "for", fact2, "=", lvls[i]), font.attr=c(style = "monospace", color = "navy", weights = "bold", sizes="medium"), do.newline = TRUE)
                insert(infArea, "\nGroup Means with 95% Confidence Intervals", font.attr=c(style = "monospace", color = "blue", size = "medium"))

                for(j in 1:length(levelNames)){          #levels(factor(f1.subset)))
                    c1.sub.subset = c1.subset[f1.subset == levelNames[j]]
                    n = length(c1.sub.subset)

                    if(n > 1){
                      mu = round(mean(c1.sub.subset),2)
                      error = round(qt(0.975, df = n-1) * (sd(c1.sub.subset)/sqrt(n)),2)
                      inf.table[j,] = c(mu - error, mu, mu + error)
                    }else{
                      mu = round(mean(c1.sub.subset),2)
                      inf.table[j,] = c("-", ifelse(is.nan(mu), "-", mu), "-") #c(NA, mu, NA)
                    }

                }
                out = capture.output(matprint(inf.table))
                insert(infArea, eval(out), font.attr=c(style = "monospace", color = "darkgreen", sizes="medium"), do.newline = TRUE)

                if(fact1 != fact2){ # Then do multiple comparison as well


                    dframe.subset = dframe[f2 == lvls[i],]
                    f1.sub = factor(dframe.subset[, fact1])
                    #dframe.subset[, fact1] = f1 #factor(dframe.subset[,fact1])


                    fit = try(eval(parse(text = paste("lm(", cont, "~", fact1, ", data = dframe.subset)", collapse = ""))))
                    if(inherits(fit,"try-error")){
                        ## insert(infArea, paste("\n", "Needs more than 1 group for multiple comparisons", sep = ""), font.attr=c(style = "monospace", color = "black", sizes="medium"), do.newline = TRUE)
                    }else{

                      multiple.table = try(multipleComp(fit))
                      if(!inherits(fit,"try-error")){
                        if(nrow(as.matrix(multiple.table)) == 1){
                          out = capture.output(eval(multiple.table))
                          insert(infArea, out, font.attr=c(style = "monospace"), do.newline = TRUE)
                        }else{
                          if(length(levels(f1)) > 1){
                            insert(infArea, paste("\nDifferences Between Group Means For", fact2, "=", lvls[i], "(col - row)"), font.attr=c(style = "monospace", color = "blue", sizes = "medium"), do.newline = TRUE)

                            insert(infArea, "\nEstimates", font.attr=c(style = "monospace", color = "black"), do.newline = TRUE)
                            out = capture.output(matprint(triangularMatrix(levels(f1.sub), multiple.table, "estimates")))
                            insert(infArea, out, font.attr=c(style = "monospace", color = "darkgreen"), do.newline = TRUE)

                            insert(infArea, "\n\n95% Confidence Intervals", font.attr=c(style = "monospace", color = "black"), do.newline = TRUE)
                            insert(infArea, "(Adjusted for multiple comparison)\n", font.attr=c(style = "monospace", color = "black"), do.newline = TRUE)
                            out = capture.output(matprint(triangularMatrix(levels(f1.sub), multiple.table, "ci")))
                            insert(infArea, out, font.attr=c(style = "monospace", color = "darkgreen"), do.newline = TRUE)

                            insert(infArea, "\n\np-values", font.attr=c(style = "monospace", color = "black"), do.newline = TRUE)
                            out = capture.output(matprint(triangularMatrix(levels(f1.sub), multiple.table, "p-values")))
                            insert(infArea, out, font.attr=c(style = "monospace", color = "darkgreen"), do.newline = TRUE)


                          }
                        }
                      }
                   }
                   insert(infArea, "_______________________________________________________________________\n", font.attr=c(style = "monospace", sizes="medium", color = "blue"), do.newline = TRUE)
                }
              }

          }else{print("BOOTSTRAP")}

      #}else{

      #}
    }else if(emptySecondVariable){

      if(e$inferenceMethod == "Normal"){
        lvls = levels(factor(f2)) ##--------------------------- put in factor() to remove empty levels

        if(factorLevel != 0)
         lvls = lvls[factorLevel]


        levelNames = lvls



      for(i in 1:length(levelNames)){
          inf.table = matrix(".", nrow = 1, ncol = 3, dimnames = list(levels(factor(f2))[i], c("ci.lower", "estimate", "ci.upper")))
          c1.subset = c1[f2 == levelNames[i]]
          n = length(c1.subset)
          if(n > 1){
            mu = round(mean(c1.subset),2)
            error = round(qt(0.975, df = n-1) * (sd(c1.subset)/sqrt(n)),2)
            inf.table[1,] = c(mu - error, mu, mu + error)
          }else{
            mu = round(mean(c1.subset),2)
            inf.table[1,] = c("-", ifelse(is.nan(mu), "-", mu), "-")
          }
          insert(infArea, "\n")
          command = paste(cont, "for", fact2, "=", lvls[i])
          insert(infArea, command, font.attr=c(style = "monospace", color = "navy", weights = "bold", sizes="medium"), do.newline = TRUE)
          insert(infArea, "\nGroup Means with 95% Confidence Intervals", font.attr=c(style = "monospace", color = "blue", size = "medium"))
          out = capture.output(matprint(inf.table))
          insert(infArea, eval(out), font.attr=c(style = "monospace", color = "darkgreen", sizes="medium"), do.newline = TRUE)
        }

        if(factorLevel == 0){
          # do multiple graphs but if the factorLevel == 0 plot is changed to multiple plots (panels) and not everything together
          # then don't bother with this section
        }

      }else{ print("BOOTSTRAP")}

    }else{

      if(all(vartypes == c('CAT','CAT','CAT'))){

        v1 = factor(dframe[,2])
        v2 = factor(dframe[,1])
        f3 = factor(dframe[,3])
        lvls = levels(f3)

        # Incorporating slider information (so that summary is only shown for the chosen level)
        if(factorLevel != 0)
           lvls = lvls[factorLevel]

        if(e$inferenceMethod == "Normal"){



        for(i in 1:length(lvls)){

            v1.subset = v1[(f3 == lvls[i])]
            v2.subset = v2[(f3 == lvls[i])]
            n = length(v2.subset)

            nv1 = length(levels(v2))
            tbl = table(v2.subset,v1.subset)
            Rowsums = rowSums(tbl)
            phat = sweep(tbl, 1, Rowsums, "/")
            nrt = nrow(tbl)


            for(r in 1:nrt){
              insert(infArea, "\n")
              insert(infArea, paste(varnames[2], "by", varnames[1], "=",  levels(v2)[r], "for", varnames[3], "=", lvls[i], "\n"), font.attr=c(style = "monospace", color = "navy", weights = "bold", sizes="medium"), do.newline = TRUE)
              insert(infArea, "\nProportions with 95% Confidence Intervals", font.attr=c(style = "monospace", color = "blue", size = "medium"))
              phat.sub = phat[r,]
              tbl.sub = tbl[r,]
              if(Rowsums[r] > 1){

                se <- sqrt(phat.sub * (1 - phat.sub)/Rowsums[r])
                qval = 1.96
                infMatrix = capture.output(matprint(matrix(c(round(phat.sub - qval * se, 2), round(phat.sub, 2), round(phat.sub + qval * se, 2)), nc = 3, dimnames = list(levels(v1), c("ci.lower", "estimate", "ci.upper")))))
                insert(infArea, eval(infMatrix), font.attr = c(style = "monospace", color = "darkgreen", size = "medium"))

                if(length(levels(v1))>1){
                  insert(infArea, paste("\n\nDifferences Between Proportions For", varnames[1], "=", levels(v2)[r], "(col - row)"), font.attr=c(style = "monospace", color = "blue", sizes = "medium"), do.newline = TRUE)
                  insert(infArea, "\nEstimates", font.attr=c(style = "monospace", color = "black"), do.newline = TRUE)
                  insert(infArea, eval(capture.output(matprint(freq1way.edited(tbl.sub, "estimates")))), font.attr = c(style = "monospace", color = "darkgreen", size = "medium"))
                  insert(infArea, "\n")
                  insert(infArea, "95% Confidence Intervals", font.attr=c(style = "monospace", color = "black"))
                  insert(infArea, eval(capture.output(matprint(freq1way.edited(tbl.sub, "ci")))), font.attr = c(style = "monospace", color = "darkgreen", size = "medium"))

                  #testForUniformity = try(capture.output(chisq.test(tbl.sub)))
                  testForUniformity = try(capture.output(chiSquareTest(tbl.sub)))
                  if(!inherits(testForUniformity,"try-error")){
                      insert(infArea, "\n")
                      #insert(infArea, eval(testForUniformity), font.attr = c(style = "monospace", color = "black", size = "medium"))
                      insert(infArea, "Chi-square test for equal probabilities\n", font.attr=c(style = "monospace", color = "black"))
                      insert(infArea, eval(testForUniformity), font.attr = c(style = "monospace", color = "darkgreen", size = "medium"))
                      insert(infArea, "\n")
                  }


                }



              }else{
                out = "No Inference included"
                insert(infArea, out, font.attr=c(style = "monospace", color = "black", sizes="medium"))
              }


            }
            if(length(lvls) != 1 || i != length(lvls)) insert(infArea, "-----------------------------------------------------------------------", font.attr = c(style = "monospace"))

          }

        }


      }else if(all(vartypes == c('CAT','EMPTY','CAT'))){

        v1f = dframe[,1]
        f3 = factor(dframe[,2])
        lvls = levels(f3)

        # Incorporating slider information (so that summary is only shown for the chosen level)
        if(factorLevel != 0)
           lvls = lvls[factorLevel]

        if(e$inferenceMethod == "Normal"){

         #Just a table with ci.lower, proportion, ci.upper for each level of the factor

          for(i in 1:length(lvls)){

            v1.subset = v1f[(f3 == lvls[i])]
            n = length(v1.subset)

            if(n > 1){

              tbl = table(v1.subset)
              phat = tbl / n
              se <- sqrt(phat * (1 - phat)/n)
              qval = 1.96
              infMatrix = capture.output(matprint(matrix(c(round(phat - qval * se, 2), round(phat, 2), round(phat + qval * se, 2)), nc = 3, dimnames = list(levels(v1.subset), c("ci.lower", "estimate", "ci.upper")))))
              insert(infArea, "\n")
              insert(infArea, paste(varnames[1], "for", varnames[2], "=", lvls[i]), font.attr=c(style = "monospace", color = "navy", weights = "bold", size = "medium"))
              insert(infArea, "\nProportions with 95% Confidence Intervals", font.attr=c(style = "monospace", color = "blue", size = "medium"))
              insert(infArea, eval(infMatrix), font.attr = c(style = "monospace", color = "darkgreen", size = "medium"))


              if(length(levels(v1.subset)>1)){
                insert(infArea, "\n\nDifferences Between Proportions (col - row)", font.attr=c(style = "monospace", color = "blue", sizes = "medium"), do.newline = TRUE)
                insert(infArea, "\nEstimates", font.attr=c(style = "monospace", color = "black"), do.newline = TRUE)
                insert(infArea, eval(capture.output(matprint(freq1way.edited(tbl, "estimates")))), font.attr = c(style = "monospace", color = "darkgreen", size = "medium"))
                insert(infArea, "\n")
                insert(infArea, "95% Confidence Intervals", font.attr=c(style = "monospace", color = "black"))
                insert(infArea, eval(capture.output(matprint(freq1way.edited(tbl, "ci")))), font.attr = c(style = "monospace", color = "darkgreen", size = "medium"))

                testForUniformity = try(capture.output(chiSquareTest(tbl)))
                if(!inherits(testForUniformity,"try-error")){
                    insert(infArea, "\n")
                    #insert(infArea, eval(testForUniformity), font.attr = c(style = "monospace", color = "black", size = "medium"))
                    insert(infArea, "Chi-square test for equal probabilities\n", font.attr=c(style = "monospace", color = "black"))
                    insert(infArea, eval(testForUniformity), font.attr = c(style = "monospace", color = "darkgreen", size = "medium"))
                    insert(infArea, "\n")
                }

              }

            }else{
              out = "No Inference included"
              insert(infArea, out, font.attr=c(style = "monospace", color = "black", sizes="large"))
            }

            if(length(lvls) != 1 || i != length(lvls)) insert(infArea, "-----------------------------------------------------------------------", font.attr = c(style = "monospace"))
          }
         } # else do bootstrap
      }
    }


  }

  insert(infArea, "_______________________________________________________________________", font.attr = c(style = "monospace", sizes="medium", color = "blue"))
  add(infWin, infArea, expand = TRUE)

}

################################################################################
################################################################################
################################################################################
################################################################################

chiSquareTest = function(tbl){

  chitest = chisq.test(tbl)

  estimated = 0
  digits = 2
  ncats = length(tbl)
  dfs <- ncats - 1
  expectedCounts = chitest$exp

#  if(any(chitest$exp < 2) || (sum(expectedCounts>5)/length(expectedCounts)) < 0.8)
#    fisher.test(tbl)
#  else{

    chitest$p.value = 1 - pchisq(chitest$statistic, dfs - estimated)
    #cat("\n\n")
    #cat("Chi-square test for equal probabilities", "\n    ")
    cat(names(chitest$statistic), " = ", format(round(chitest$statistic, 4)), ", ", sep = "")
    cat(paste(names(chitest$parameter), " = ", format(round(chitest$parameter -  estimated, 3)), ",", sep = ""), "")
    cat("p-value =", format.pval(chitest$p.value, digits = digits))
# }

}

freq1way.edited = function(tbl, inf.type = "estimates", conf.level = 0.95){

  # Before freq1way is called should output the variable name in the table
  level.names =  names(tbl)
  n = sum(tbl)
  ncats = length(tbl)
  ncatsC2 = choose(ncats, 2)

  if(is.null(level.names)) level.names = 1:ncats

  conf.pc = conf.level * 100
  phat = tbl/sum(tbl)

  qval = abs(qnorm((1-conf.level)/(2*ncats)))

  matw = matrix(NA, ncats -1, ncats - 1)

  dimnames(matw) = list(level.names[-length(level.names)], level.names[-1])

  qval.adjusted = abs(qnorm((1 - conf.level)/(2 * ncatsC2)))

  tempw = ""

  if(inf.type == "estimates"){

    for(i1 in 1:(ncats - 1)){
      for(i2 in 2:ncats){
        tempw = phat[i1] - phat[i2]
        tempw = round(tempw, 3)
        matw[i1, i2 - 1] = ifelse((i1 < i2), tempw , " ")


      }
    }
    t(matw)
  }else{

    testMatrix =  matrix(" ", ncats - 1, 2*ncats - 2)
    count = 1
    count.2 = 0
    for(i1 in 1:(ncats - 1)){
      count = 0
      for(i2 in 2:ncats){
        tempw = phat[i1] - phat[i2] +
                abs(qnorm((1-conf.level)/(2 * ncatsC2))) * c(-1, 1) *
                sqrt(((phat[i1] + phat[i2]) - ((phat[i1] - phat[i2])^2))/n)
        tempw = round(tempw, 3)
        matw[i1, i2 - 1] = ifelse((i1 < i2), paste("(",
                tempw[1], ",", tempw[2], ")", sep = ""), " ")


        if(i2 == 2)
          count = i2 - 2

        if(i1 < i2){
          testMatrix[i1, count + 1 + count.2] = tempw[1]
          testMatrix[i1, (count = count + 2) + count.2] = tempw[2]
        }

      }
      count.2 = count.2 + 2
    }

    rowNames = rep("", ncats * 2)
    temp = 1:(ncats * 2)
    rowNames[(temp%%2 != 0)] = level.names

    testMatrix = t(testMatrix)
    rownames(testMatrix) = rowNames[-c(1,2)]
    colnames(testMatrix) = level.names[-ncats]

    testMatrix
  }

}



convert.to.factor = function(var3){


      if(length(unique(var3)) < 5)
        var3.fact = factor(var3)
      else{

          var3.quantiles = round((quantile(var3, na.rm = TRUE)),0)  #------------- May 13th used to round to 2 digits


          var3.fact = try(cut(var3, c(-Inf, ifelse(unique(var3.quantiles[2:4])==3, var3.quantiles[2:4],unique(var3.quantiles[2:4])), Inf)))


    #          # Creating 4 equal groups
    #    quantile(dm$HealthExpPC, c(0,25,50,75,100)/100, na.rm=T)
    #
    #    dm$HE = cut( dm$HealthExpPC,
    #        quantile(dm$HealthExpPC, c(0,25,50,75,100)/100, na.rm=T),
    #        include.lowest = TRUE)





          if(inherits(var3.fact,"try-error")){
            eps <- .Machine$double.eps
            #or use something like 1e-10
            #brks <- quantile(vec, (0:10)/10) + eps*(0:10)
            #cut(vec, brks, include.lowest=TRUE, labels=FALSE)


            var3.quantiles = round((quantile(var3, na.rm = TRUE)),2) + eps*(0:10)
            var3.fact = cut(var3, c(-Inf, ifelse(unique(var3.quantiles[2:4])==3, var3.quantiles[2:4],unique(var3.quantiles[2:4])), Inf))



          }

          if((var3.quantiles[2] == var3.quantiles[3]) && (var3.quantiles[3] == var3.quantiles[4]))
              levels(var3.fact) = c(paste(c("[", var3.quantiles[1], " - ", var3.quantiles[2], "]"), collapse = ""),
                                                                         paste(c("(", var3.quantiles[2], " - ", var3.quantiles[5], "]"), collapse = ""))
          else if(var3.quantiles[2] == var3.quantiles[3])
              levels(var3.fact) = c(paste(c("[", var3.quantiles[1], " - ", var3.quantiles[2], "]"), collapse = ""),
                                                                         paste(c("(", var3.quantiles[2], " - ", var3.quantiles[4], "]"), collapse = ""),
                                                                         paste(c("(", var3.quantiles[4], " - ", var3.quantiles[5], "]"), collapse = ""))
          else if(var3.quantiles[3] == var3.quantiles[4])
              levels(var3.fact) = c(paste(c("[", var3.quantiles[1], " - ", var3.quantiles[2], "]"), collapse = ""),
                                                                         paste(c("(", var3.quantiles[2], " - ", var3.quantiles[3], "]"), collapse = ""),
                                                                         paste(c("(", var3.quantiles[3], " - ", var3.quantiles[5], "]"), collapse = ""))
          else
              levels(var3.fact) = c(paste(c("[", var3.quantiles[1], " - ", var3.quantiles[2], "]"), collapse = ""),
                                                                         paste(c("(", var3.quantiles[2], " - ", var3.quantiles[3], "]"), collapse = ""),
                                                                         paste(c("(", var3.quantiles[3], " - ", var3.quantiles[4], "]"), collapse = ""),
                                                                       paste(c("(", var3.quantiles[4], " - ", var3.quantiles[5], "]"), collapse = ""))

        }
        var3.fact

}




lattice.boxplots = function(dframe, varnames, vartypes){

  v1 = dframe[,1]
  if(length(varnames)==1)
    print(bwplot(v1, xlab = varnames[1] , pch="|", par.settings=list(box.rectangle=list(col="black"), box.umbrella=list(lty=1, col="black"), plot.symbol=list(col = "blue"))))
}




lattice.histograms = function(dframe, varnames, vartypes){

  v1 = dframe[,1]
  if(length(varnames)==1)
    print(histogram(v1, xlab = varnames[1], ylab = "Percentage", col = "lightblue"))

}

#match can be used to replace which() because it is much more efficient

# The following function prints nicely formatted matrices

matprint = function(x, sep = "   "){
  rlabs = !is.null(rownames(x))
  clabs = !is.null(colnames(x))
  #print(nrow(x))
  l = matrix("", nrow(x) + clabs, ncol(x) + rlabs)
  if(rlabs)
    l[,1] = format(c(if(clabs) "" else character(), rownames(x)), justify = "l")

  for(i in 1:ncol(x)){
    l[,i+rlabs] = format(c(if(clabs) colnames(x)[i] else character(),
                  format(x[,i], justify = "r")), justify = "r")
  }

  for(i in 1:nrow(l)) cat(l[i,], sep = sep, "\n")

}

################################################################################
################################################################################
################################################################################

#Means, Medians, IQRs
getBoot1 = function(x, d, estimate = "mean"){

  if(estimate == "mean")
    return(mean(x[d]))
  else if(estimate == "median")
    return(median(x[d]))
  else if(estimate == "all")
    return(c(means = mean(x[d]), medians = median(x[d]), iqrs = summary(x[d])[5] - summary(x[d])[2]))

}

# Regression coefficients, correlations etc.
getBoot2 = function(data, indices, yname, xname){

  d = data[indices,]
  fit = lm(eval(parse(text=paste(yname,"~", xname))), data = d)

  return(c(slope = coef(fit)[2] , intercept = coef(fit)[1], correlation = cor(d[,yname],d[,xname])))


}

#bs <- function(formula, data, indices) {
#  d <- data[indices,] # allows boot to select sample
#  fit <- lm(formula, data=d)
#  return(coef(fit))
#}
## bootstrapping with 1000 replications
#results <- boot(data=mtcars, statistic=bs,
#   R=1000, formula=mpg~wt+disp)

#
#
#  usual bootstrap of the ratio of means using the city data
#ratio <- function(d, w)
#     sum(d$x * w)/sum(d$u * w)
#boot(city, ratio, R=999)
#
#trimmedmean <- function(x, d, trim=0) {
#  return(mean(x[d], trim/length(x)))
#}
#
#Here, I'm defaulting trim to 0. And, I'll allowing the caller to talk in the units of observations, not fractions of the data. So the user would say "5" to trim off the most extreme 5 observations at the top and the bottom. I convert that into fractions before feeding this to mean().
#
#Here's how you would call boot() using this:
#
#    b = boot(x, trimmedmean, R=1000, trim=5)
#
#


# Define the analysisStep function.
#
# Generates HTML table files and graphics files for one, two
# or three variables found in a specified CSV data file.
#
# Prints out the full filenames to the screen as the files are created.
#
# Arguments
#   datafile : csv filename to open and read into a data.frame
#   varnames : character vector of variable names (at most 3)
#   vartypes : types of those variables, each either "CONT" or "CAT"
#   output_file : path and stub filename for output file(s)
#   year12   : TRUE or FALSE - add Year 12 components? e.g. error bars


analysisStep <- function(datafile,varnames,vartypes,plotType,year12=FALSE) {

  #local variables used need to be reinitialized
   fifthVarSubset = NULL
   fifthVarNumeric = NULL
   segmentVarSubset = NULL
   sixthVarSubset = NULL

  dframe = datafile

  if(e$scatterPlotView || e$dotChartView){
    if(!is.null(e$fifthVariable)){
      dframe = cbind(dframe, fifthVarSubset = e$fifthVariableSubset)
      if(!is.null(e$fifthVariableNumeric))
        dframe = cbind(dframe, fifthVarNumeric = e$fifthVariableNumeric)
    }
  }
  if(e$scatterPlotView){
    if(!is.null(e$sixthVariable))
      dframe = cbind(dframe, sixthVarSubset = e$sixthVariableSubset)#
  }

  if(!e$scatterPlotView && !e$dotChartView){
    if(!is.null(e$segmentVariable)){
      dframe = cbind(dframe, segmentVarSubset = e$segmentVariableSubset)
    }
  }


  dframe = na.omit(dframe)

  if(e$scatterPlotView || e$dotChartView){
    if(!is.null(e$fifthVariable)){
      fifthVarSubset = dframe[,"fifthVarSubset"]

      if(!is.null(e$fifthVariableNumeric))
        fifthVarNumeric = dframe[,"fifthVarNumeric"]

    }
  }
  if(e$scatterPlotView){

    if(!is.null(e$sixthVariable)) {
      sixthVarSubset = dframe[,"sixthVarSubset"]
    }
  }
  if(!e$scatterPlotView && !e$dotChartView){

    if(!is.null(e$segmentVariable)){
      segmentVarSubset = dframe[,"segmentVarSubset"]

    }
  }


  dframe = data.frame(dframe[,1:ncol(datafile)])
  colnames(dframe) = varnames


  #dframe = na.omit(datafile) # Because datafile is already a data frame
  #dframe = na.omit(data.frame(datafile))

  if(e$sliderCreated){
    if(is.factor(svalue(tag(e$obj,"groupingVarData")))){
      #if(is.null(e$fourthVariable))
        e$gpVarLbls = levels(factor(dframe[,3]))
#      else
#        e$gpVarLbls = levels(factor(dframe[,3][e$fourthVariable == (levels(e$fourthVariable)[e$sliderData2])]))

    }else{
      #if(is.null(e$fourthVariable))
        e$gpVarLbls = levels(convert.to.factor(dframe[,3]))
#      else
#        e$gpVarLbls = levels(convert.to.factor((dframe[,3])[e$fourthVariable == (levels(e$fourthVariable)[e$sliderData2])]))
    }

    svalue(e$lbl) = paste(c("*",e$gpVarLbls), collapse = "   ")

  }



	samp.size <- nrow(dframe)

  for (i in 1:length(varnames)) {
    if (vartypes[i] == "CONT" & is.factor(dframe[,varnames[i]]))
      vartypes[i] <- "CAT"
  }


# Tweaks to 2007 Data

	if (any(varnames=='timetravel'))
    dframe$timetravel <- relevel(dframe$timetravel, 'less10')
	if (any(varnames=='futurejob'))
    dframe$futurejob <- relevel(dframe$futurejob, 'no')
  if (any(varnames=='bedtime')) {
    bedtimes <- levels(dframe$bedtime)
    if (length(bedtimes) == length(grep("^[0-9]*:[0-9][0-9]:00$",bedtimes))) {
      bedtimes <- levels(dframe$bedtime) <- gsub(":00$","",levels(dframe$bedtime))
      x = as.numeric(gsub(":",".",bedtimes))
      x = ifelse(x<12,x+24,x)
      newbedtimes = bedtimes[order(x)]
      dframe$bedtime <- factor(newbedtimes[rank(x)[as.integer(dframe$bedtime)]], levels=newbedtimes)
    }
  }
  if (any(varnames=="techmp") & !any(colnames(dframe)=="techmp"))
    varnames[varnames=="techmp"] <- "techmp3"


  if (length(varnames) == 3){
    if(vartypes[3] == "CONT")
      dframe[,3] = convert.to.factor(dframe[,3])
    else
      dframe[,3] = factor(dframe[,3])  ##---------------------------------------- Added this on Monday 13th September
  }


  if (length(varnames)==1) {

    v1 = dframe[,which(names(dframe) == varnames[1])]
    v1f <- as.factor(v1)
    nv1 = length(levels(v1f))
    par(mfrow = c(1,1))

    if (vartypes[1] == "CONT") {

        e$dotChartView = TRUE
        e$scatterPlotView = FALSE

        par(mar=rep(0.1,4), cex=1,  bg = e$basicBackgroundDot)

        if(!is.null(e$fifthVariable))
          par(mar=rep(0.1,4), cex=1, oma = c(rep(0.1,3),2),  bg = e$basicBackgroundDot)


        if(!is.null(e$fifthVariable)){

          nv5 = length(levels(e$fifthVariableSubset))
          cols = barcols(nv5,c=65,lum1=60,lum2=30)
          pcols = cols[as.numeric(as.factor(fifthVarSubset))]
          if(!is.null(e$fifthVariableNumeric)){
            #cols = rev(heat.colors(length(levels(factor(e$fifthVariableNumeric))), alpha = 1)) ##--------------------------------------------------------  CHANGED 10th August
            #cols = rev(terrain.colors(length(levels(factor(fifthVarNumeric)))))
            #cols = rainbow(length(levels(factor(fifthVarNumeric))), start = 0, end = 4/6)
            #dineika.palette <- colorRampPalette(c("red", "orchid4", "blue"), space = "rgb")
            #cols = rev(dineika.palette(length(levels(factor(fifthVarNumeric)))))


            cols = rev(rainbow(length(levels(factor(fifthVarNumeric))), start = .7, end = .1))

            pcols = cols[as.numeric(as.factor(fifthVarNumeric))]
          }
          ii = order(v1,pcols) #ordering the colors so that there is no mishmash :)
          pcols = pcols[ii]
          v1 = v1[ii]


        }else
          pcols = e$basicDotColor

        boxpoints1(x=v1,varname=varnames[1], boxcol=BoxColour,ptcol=pcols, errorbarcol=ifelse(year12,BoxBarCol,NA),noBox = FALSE)
        if(!is.null(e$fifthVariable)){
          if(is.null(e$fifthVariableNumeric))
              legend("right",substr(levels(e$fifthVariableSubset),1,15),bg = "transparent",pch=1,col=cols,title=e$fifthVarName,pt.cex=1,cex=1,pt.lwd=2)
          else{
              pseudoLevels = levels(factor(fifthVarNumeric))
              lvlsLength = length(pseudoLevels)
              #if(max(diff(sort(as.numeric(pseudoLevels)))) >20 && length)

              #########brks = c(as.numeric(pseudoLevels),as.numeric(pseudoLevels[lvlsLength])+0.5)


              #brks = c(as.numeric(pseudoLevels[1])-0.5, as.numeric(pseudoLevels))
              #brk.labs = rep("",length(brks))

              #brk.quantiles = round(quantile(1:lvlsLength))
              #brk.labs[brk.quantiles] = pseudoLevels[brk.quantiles]

              #image.plot(legend.only=TRUE, legend.shrink = 0.5, legend.width = 1.2, legend.mar = 2.3, zlim = c(min(fifthVarNumeric)-0.5,max(fifthVarNumeric)), breaks = brks, lab.breaks = brk.labs, nlevels = length(levels(factor(fifthVarNumeric))), col=cols, main=e$fifthVarName, legend.args=list(text = e$fifthVarName, cex = 1, line = 1), add = TRUE, horizontal = FALSE) # legend.lab = e$fifthVarName

                                                                                                                                                                         # c(levels(factor(fifthVarNumeric)),"")

             image.plot(legend.only=TRUE, legend.shrink = 0.5, legend.width = 1.2, legend.mar = 2.3, zlim = c(min(fifthVarNumeric),max(fifthVarNumeric)), breaks = c(levels(factor(fifthVarNumeric)),max(fifthVarNumeric)+10), lab.breaks = levels(factor(fifthVarNumeric)) ,nlevels = length(levels(factor(fifthVarNumeric))), col=cols, main=e$fifthVarName, legend.args=list(text = e$fifthVarName, cex = 1, line = 1), add = TRUE, horizontal = FALSE) # legend.lab = e$fifthVarName

              #colorlegend(posx=c(0.92,0.95),posy =c(0.5,0.9),zlim=c(min(v1),max(v1)),zlevels = NULL,zval =c(min(v1),max(v1)),col=cols,main=e$fifthVarName, main.cex = 0.9)

              #reset.graphics=TRUE
          }

        }
        #svalue(e$choosePlot, index = TRUE) = 1 <- need to keep it at default otherwise it is the default plot but the plot type is wrong

    }
    else {

      e$dotChartView = FALSE
      e$scatterPlotView = FALSE
      las = 0
      cex.names = 1
      if (nv1>5) {cex.names=0.8; levels(v1f)=substr(levels(v1f),1,8)}
      if (nv1>8) {
        levels(v1f)=substr(levels(v1f),1,6)
        if (max(nchar(levels(v1f))) > 2) las=2  # Vertical labels
        cex.names = 0.8 * (30 / max(30, nv1))
      }
      tbl = table(v1f)
      phat = tbl / sum(tbl)

      if(e$drawIntervals){  # Must take into consideration if e$useBootstrap is on

        qval <- 1.96 #abs(qnorm(1 - 0.975))
        n <- sum(as.vector(tbl))
        se <- sqrt(phat * (1 - phat)/n)

        xmid = 1.2 * (1:nv1) - 0.5
        barlwd = min(10, max(1, 100/nv1))
        bars = qval * errorbarsize(proportion.covs(tbl))
        bars[tbl < Errorbar.threshold] <- NA
        barsize.conf = qval * se
        barsize.conf[tbl < Errorbar.threshold] <- NA

        if(e$drawBothInf)
          ylim = c(0, ifelse(is.infinite(max(phat + barsize.conf, na.rm = TRUE)), max(phat), max(phat + barsize.conf, na.rm = TRUE)))
        else{
          if (any(!is.na(bars))) ylim = c(0, ifelse(is.infinite(max(phat+bars,na.rm=TRUE)),max(phat),max(phat+bars,na.rm=TRUE)))
        }

      }else{ if (nv1==2) ylim=c(0,1) else ylim=c(0,max(phat))}

      if (nv1<4) xlim=c(-1,1.2*(nv1+1)) else xlim=c(0,1.2*nv1)



      #if (year12) {
      #}


      par(mar=c(4.2,4.6,0.5,0.1),cex=1, bg = "white")


      if(!is.null(e$segmentVariable)){
          colSegments = barcols(length(levels(e$segmentVariableSubset)),c=65,lum1=70,lum2=40)
          counts <- table(segmentVarSubset,v1f)

          phat = (table(v1f)) / sum(table(v1f))

          Colsums = colSums(counts)
          props = sweep(counts, 2, Colsums, "/")


          for(i in 1:length(phat))
            props[,i] =  props[,i]* phat[i]


          barplot(props, col = colSegments, legend.text = rownames(props), args.legend = list(title = e$segmentVarName, xjust = 1, cex = 0.9),xlim=xlim,ylim=ylim,ylab="",xlab=varnames[1],las=las, cex.names=cex.names,cex.lab=1.2,axes=FALSE)



      }else
          barplot(phat,xlab=varnames[1],xlim=xlim,ylim=ylim,ylab="",col=Barchart1varCol, las=las, cex.names=cex.names,cex.lab=1.2,axes=FALSE)  #cex.axis=1.6,




      ylabs=pretty(ylim)
      axis(2,at=ylabs,lab=paste(100*ylabs,"%",sep=''),las=1)  #,cex.lab=1.6,cex.axis=1.6


#      if (year12) {
#        xmid = 1.2 * (1:nv1) - 0.5
#        barlwd = min(10, max(1, 100/nv1))
#        segments(xmid, phat - bars, xmid, phat + bars, col=BarchartBarCol, lwd=barlwd, lend=1)
#      }

      if (e$drawIntervals){

        if(e$useBootstrap){

          #if( > bootCuttoff)


        }else{

          if(e$drawBothInf)
          #Confidence Intervals
          segments(xmid, phat - barsize.conf, xmid, phat + barsize.conf, col="red", lwd=1, lend=1)

          #Comparison Intervals
          segments(xmid, phat - bars, xmid, phat + bars, col=BarchartBarCol, lwd=barlwd, lend=1)

          ###if(e$drawBothInf) print( 100 * ((2* bars) / (2*qval*se))) Just to test if the comparison bar is roughly 70% of the confidence bar

        }
      }
    }
  }


  if (length(varnames)>1) {
    par(mfrow = c(1,1))    #************************************************************* added 23rd
    varnames = c(varnames[2],varnames[1],varnames[c(-2,-1)])   #Changed this
    vartypes = c(vartypes[2],vartypes[1],vartypes[c(-2,-1)])   #Changed this
    v1 = dframe[,varnames[1]]
    v2 = dframe[,varnames[2]]

    if (vartypes[1]=="CONT" & vartypes[2]=="CONT") {
      ylims=range(v1,na.rm=T);

      xlims=range(v2,na.rm=T)
      if(!is.null(e$fifthVariable)) xlims[2] = xlims[2]+ 0.1*(xlims[2]-xlims[1])

      pchs=1; pcols=e$basicScatterColor
      e$dotChartView = FALSE
      e$scatterPlotView = TRUE

      if (length(varnames)>2) {

        if(!is.null(e$fifthVariable))
          xlims[2] = xlims[2]+0.2*(xlims[2]-xlims[1])
        else
          xlims[2] = xlims[2]+0.1*(xlims[2]-xlims[1])

        levs = levels(as.factor(dframe[,3]))

        nv3 = length(levs)
        #pchs = as.numeric(as.factor(dframe[,3]))

        pchs = rep(1,length(dframe[,3]))

        #cols = barcols(nv3,c=65,lum1=60,lum2=30) #------------------------------------- changed 4th May
        #cols =  heat.colors(nv3, alpha = 1)   # The color should be black

        if(!is.null(e$fifthVariable)){
          nv5 = length(levels(e$fifthVariableSubset))
          cols = barcols(nv5,c=65,lum1=60,lum2=30)
          pcols = cols[as.numeric(as.factor(fifthVarSubset))]

          if(!is.null(e$fifthVariableNumeric)){
            #cols = rev(heat.colors(length(levels(factor(e$fifthVariableNumeric))), alpha = 1))
            #cols = rev(terrain.colors(length(levels(factor(fifthVarNumeric))), alpha = 1))
            #cols = rainbow(length(levels(factor(fifthVarNumeric))), start = 0, end = 4/6)

            #dineika.palette <- colorRampPalette(c("red", "orchid4", "blue"), space = "rgb")
            #cols = rev(dineika.palette(length(levels(factor(fifthVarNumeric)))))
            cols = rev(rainbow(length(levels(factor(fifthVarNumeric))), start = .7, end = .1))
            pcols = cols[as.numeric(as.factor(fifthVarNumeric))]
          }

        }else{
          cols = rep(e$basicScatterColor, nv3)
          pcols = cols[as.numeric(as.factor(dframe[,3]))]
        }

        if(nv3 == 1)
          par(mfrow =c(1,1), bg = e$basicBackgroundScatter)
        else if(nv3%%2 == 0)
          par(mfrow = c(nv3/2, 2), bg = e$basicBackgroundScatter)
        else if(nv3%%2 != 0)
          par(mfrow = c((nv3/2)+ 0.5, 2), bg = e$basicBackgroundScatter)



        if(!is.null(e$fifthVariableNumeric)) par(oma = c(rep(0.1,3),2))

        for(i in 1:nv3){
          par(mar=c(4.5,5.1,4.1,0.5))

          x = v2[dframe[,3]==levs[i]]
          y = v1[dframe[,3]==levs[i]]

          if(e$addJitterX)  x = jitter(x)
          if(e$addJitterY)  y = jitter(y)

          plot(xlims,ylims,type="n",xlab=varnames[2],ylab=varnames[1],cex.axis=1,cex.lab=1)

          if(e$addRugX) rug(x, side = 1)
          if(e$addRugY) rug(y, side = 2)


          title(main=list(paste(varnames[1],"by",varnames[2], ifelse(is.null(e$fourthVariable), paste("for", varnames[3], "=", levs[i]), paste("for", varnames[3], "=", levs[i], " & ", e$fourthVarName, "=", (levels(e$fourthVariable)[e$sliderData2])))),cex=0.9))
          #title(main=list(paste(varnames[1],"by",varnames[2]),cex=1))   #********************** Changed on 25th March




      # JOIN BY LINES ##############################################################
            if(e$joinByLines){

              if(!is.null(e$fifthVariable)){

                if(is.null(e$fifthVariableNumeric)){

                  for(colIndex in 1:nv5){

                    pcolsTemp = pcols[fifthVarSubset == levels(fifthVarSubset)[colIndex]]#(pcols[dframe[,3]==levs[i]])[fifthVarSubset == levels(fifthVarSubset)[colIndex]]

                    points(x[fifthVarSubset == levels(fifthVarSubset)[colIndex]],y[fifthVarSubset == levels(fifthVarSubset)[colIndex]],col= pcolsTemp , lwd=e$scatterThickness1/4, type = "l")
                  }



                }else
                  points(x,y,col= "black", lwd=e$scatterThickness1/4 , type = "l")

              }else
                points(x,y,col= "black", lwd=e$scatterThickness1/4, type = "l")

            }

      #############################################################################





          #pch=pchs[dframe[,3]==levs[i]],
          if(is.null(e$sixthVariable))
              points(x,y,cex=e$basicCexScatter,col=pcols[dframe[,3]==levs[i]],lwd=e$scatterThickness1,pch = e$basicPlottingCharScatter)
          else{
              if(max(sixthVarSubset) < 15) constant = 0.2
              else if(max(sixthVarSubset) < 50) constant = 0.1
              else constant = 0.1

              scaledVar = as.vector((sixthVarSubset-min(sixthVarSubset))/diff(range(sixthVarSubset)) + constant) #* e$basicCexScatter
              backgroundColor =  NA
              if(e$basicPlottingCharScatter == 1) backgroundColor = NA else backgroundColor = pcols[dframe[,3]==levs[i]]
              if(length(v2[dframe[,3]==levs[i]]) != 0)
                symbols(x, y, circles = scaledVar[dframe[,3]==levs[i]], inches=maxbubsize * e$basicCexScatter, fg = pcols[dframe[,3]==levs[i]], bg = backgroundColor ,  add = TRUE, lwd = e$scatterThickness1 )



          }
              #symbols(v2[dframe[,3]==levs[i]],v1[dframe[,3]==levs[i]], circles=abs(e$sixthVariableSubset[dframe[,3]==levs[i]])/10, inches=FALSE, fg = pcols[dframe[,3]==levs[i]], add = TRUE)



          if(e$addSmoother == TRUE){
              v2.sub = v2[dframe[,3]==levs[i]]
              v1.sub = v1[dframe[,3]==levs[i]]
              if(e$drawBootLines){
                  obs.ids = 1:length(v1.sub)
                  for(j in 1:e$numBootLines){
                    boot.ids = sample(obs.ids,replace=T)
                    lines(lowess(v2.sub[boot.ids], v1.sub[boot.ids], f = e$smootherValue), col = paste(e$smootherColor, e$alphaValue, sep = ""), lwd = 1, lty = 2)
                  }
              }

              lines(lowess(v2.sub, v1.sub, f = e$smootherValue), col = e$smootherColor, lwd = 1)
          }

          if(e$addLinearTrend){
            v1.sub = v1[dframe[,3]==levs[i]]
            v2.sub = v2[dframe[,3]==levs[i]]
            if(e$drawBootLines){
                obs.ids = 1:length(v1.sub)
                for(j in 1:e$numBootLines){
                  boot.ids = sample(obs.ids,replace=T)
                  abline(reg = lm(v1.sub[boot.ids] ~ v2.sub[boot.ids]), col = paste(e$linearColor, e$alphaValue, sep = ""),lty = 2, lwd = 1)
                }
            }

              abline(reg = lm(v1.sub ~ v2.sub), col = e$linearColor, lty = 1, lwd = 1)
          }


          if(e$addQuadTrend){

            y = v1[dframe[,3]==levs[i]]
            x = v2[dframe[,3]==levs[i]]

            if(e$drawBootLines){
                obs.ids = 1:length(x)
                for(j in 1:e$numBootLines){


                  y = v1[dframe[,3]==levs[i]]
                  x = v2[dframe[,3]==levs[i]]
                  boot.ids = sample(obs.ids,replace=T)
                  x = x[boot.ids]
                  y = y[boot.ids]
                  #x = x.boot
                  fit <- lm(y ~ x  + I(x^2))
                  B <- coef(fit)
                  curve(B[1] + B[2]*x + B[3]*x^2,col = paste(e$quadColor, e$alphaValue, sep = ""), lty = 2, lwd = 1, add = TRUE)
                }
            }

            y = v1[dframe[,3]==levs[i]]
            x = v2[dframe[,3]==levs[i]]
            fit <- lm(y ~ x + I(x^2))
            B <- coef(fit)
            curve(B[1] + B[2]*x + B[3]*x^2,col = e$quadColor,, lty = 1, lwd = 1, add = TRUE)

          }
          if(e$addCubicTrend){

            y = v1[dframe[,3]==levs[i]]
            x = v2[dframe[,3]==levs[i]]

            if(e$drawBootLines){
                obs.ids = 1:length(x)

                for(j in 1:e$numBootLines){
                  y = v1[dframe[,3]==levs[i]]
                  x = v2[dframe[,3]==levs[i]]
                  boot.ids = sample(obs.ids,replace=T)
                  x = x[boot.ids]
                  y = y[boot.ids]

                  fit <- lm(y ~ x + I(x^2) + I(x^3))
                  B <- coef(fit)

                  curve(B[1] + B[2]*x + B[3]*x^2 + B[4]*x^3, col = paste(e$cubicColor, e$alphaValue, sep = ""), lty = 2, lwd = 1, add = TRUE)
                }
            }
            y = v1[dframe[,3]==levs[i]]
            x = v2[dframe[,3]==levs[i]]
            fit <- lm(y ~ x + I(x^2) + I(x^3))
            B <- coef(fit)
            curve(B[1] + B[2]*x + B[3]*x^2 + B[4]*x^3, col = e$cubicColor, lty = 1, lwd = 1, add = TRUE)
          }
         if(e$addYequalsX){

          abline(0,1,lty=3,lwd=1)

         }

         if(!is.null(e$fifthVariable)){
            if(!is.null(e$fifthVariableNumeric) && i == nv3){
                image.plot(legend.only=TRUE, legend.shrink = 0.5, legend.width = 1.2, legend.mar = 2.3, zlim = c(min(fifthVarNumeric),max(fifthVarNumeric)), nlevels = length(levels(factor(fifthVarNumeric))), col=cols, main=e$fifthVarName, legend.args=list(text = e$fifthVarName, cex = 1, line = 1), add = TRUE, horizontal = FALSE)
            }else if(is.null(e$fifthVariableNumeric))
                legend("topright",substr((levels(e$fifthVariableSubset)),1,15),bg = "transparent",pch = 1, col=cols,title=e$fifthVarName,pt.cex=1,cex=1,pt.lwd=2)

          }
        }

      }else{
        par(mar=c(4.5,5.1,4.1,0.5), bg = e$basicBackgroundScatter)


        if(!is.null(e$fifthVariable)){
          nv5 = length(levels(fifthVarSubset))
          cols = barcols(nv5,c=65,lum1=60,lum2=30)
          pcols = cols[as.numeric(as.factor(fifthVarSubset))]

          if(!is.null(e$fifthVariableNumeric)){
             par(oma = c(rep(0.1,3),2))
             #cols = rev(terrain.colors(length(levels(factor(fifthVarNumeric))), alpha = 1))
             #cols = rainbow(length(levels(factor(fifthVarNumeric))), start = 0, end = 4/6)


             dineika.palette <- colorRampPalette(c("red", "orchid4", "blue"), space = "rgb")



#             YlOrBr <- c("#FFFFD4", "#FED98E", "#FE9929", "#D95F0E", "#993404")
#             dineika.palette <- colorRampPalette(YlOrBr, space = "Lab")

             #cols = rev(dineika.palette(length(levels(factor(fifthVarNumeric)))))

             cols = rev(rainbow(length(levels(factor(fifthVarNumeric))), start = .7, end = .1))
             pcols = cols[as.numeric(as.factor(fifthVarNumeric))]
          }

        }

        x = v2
        y = v1

        if(e$addJitterX)  v2 = jitter(v2)
        if(e$addJitterY)  v1 = jitter(v1)

        plot(xlims,ylims,type="n",xlab=varnames[2],ylab=varnames[1],cex.axis=1,cex.lab=1)


        if(e$addRugX) rug(v2, side = 1)

        if(e$addRugY) rug(v1, side = 2)


        title(main=list(paste(varnames[1],"by",varnames[2], ifelse(is.null(e$fourthVariable), "", paste("for", e$fourthVarName, "=", (levels(e$fourthVariable)[e$sliderData2])))),cex=0.8))   #********************** Changed on 25th March


      # JOIN BY LINES ##############################################################
            if(e$joinByLines){

              if(!is.null(e$fifthVariable)){

                if(is.null(e$fifthVariableNumeric)){

                  for(colIndex in 1:nv5){
                    points(v2[fifthVarSubset == levels(fifthVarSubset)[colIndex]],v1[fifthVarSubset == levels(fifthVarSubset)[colIndex]],col=pcols[fifthVarSubset == levels(fifthVarSubset)[colIndex]] , lwd=e$scatterThickness2/2, type = "l")
                  }

                }else
                  points(v2,v1,col= "black", lwd=e$scatterThickness2/2 , type = "l")

              }else
                points(v2,v1,col= "black", lwd=e$scatterThickness2/2, type = "l")

            }

      #############################################################################



        if(is.null(e$sixthVariable)){
            points(v2,v1,cex=e$basicCexScatter,pch=e$basicPlottingCharScatter,col=pcols,lwd=e$scatterThickness2)


        }else{
          if(max(sixthVarSubset) < 15) constant = 0.2
          else if(max(sixthVarSubset) < 50) constant = 0.1
          else constant = 0.1

          scaledVar = as.vector((sixthVarSubset-min(sixthVarSubset))/diff(range(sixthVarSubset)) + constant) #* e$basicCexScatter
          backgroundColor =  NA
          if(e$basicPlottingCharScatter == 1) backgroundColor = NA else backgroundColor = pcols

          if(length(v2 != 0))
            symbols(v2,v1, circles=scaledVar, inches = maxbubsize * e$basicCexScatter, fg = pcols, bg = backgroundColor, add = TRUE, cex = e$basicCexScatter, lwd = e$scatterThickness2)



        }






        #}#elsejust draw lines and remove type from above

        if(e$addSmoother){

            if(e$drawBootLines){
                obs.ids = 1:length(x)
                for(i in 1:e$numBootLines){
                  boot.ids = sample(obs.ids,replace=T)
                  lines(lowess(x[boot.ids],y[boot.ids], f = e$smootherValue), col = paste(e$smootherColor, e$alphaValue, sep = ""), lwd = 1, lty = 2)
                }
            }

            lines(lowess(x,y, f = e$smootherValue), col = e$smootherColor, lwd = 2, lty = 1)

        }

        if(e$addLinearTrend){

            if(e$drawBootLines){
                obs.ids = 1:length(x)
                for(i in 1:e$numBootLines){
                  boot.ids = sample(obs.ids,replace=T)
                  abline(reg = lm(y[boot.ids] ~ x[boot.ids]), col = paste(e$linearColor, e$alphaValue, sep = ""), lty = 2, lwd = 1)
                }
            }
            abline(reg = lm(y ~ x), col = e$linearColor,lty = 1, lwd = 2)
        }

        if(e$addQuadTrend){

            if(e$drawBootLines){
                obs.ids = 1:length(x)
                for(i in 1:e$numBootLines){
                  x = v2
                  y = v1

                  boot.ids = sample(obs.ids,replace=T)
                  x.boot = x[boot.ids]
                  y.boot = y[boot.ids]
                  fit <- lm(y.boot ~ x.boot  + I((x.boot)^2))
                  B <- coef(fit)
                  x = x.boot
                  curve(B[1] + B[2]*x + B[3]*x^2,col = paste(e$quadColor, e$alphaValue, sep = "") , lty = 2, lwd = 1, add = TRUE)
                }
            }
            x = v2
            y = v1
            fit <- lm(y ~ x + I(x^2))
            B <- coef(fit)
            curve(B[1] + B[2]*x + B[3]*x^2,col = e$quadColor, lty = 1, lwd = 2, add = TRUE)



        }
        if(e$addCubicTrend){

            if(e$drawBootLines){
                obs.ids = 1:length(x)
                for(i in 1:e$numBootLines){
                  x = v2
                  y = v1
                  boot.ids = sample(obs.ids,replace=T)
                  x.boot = x[boot.ids]
                  y.boot = y[boot.ids]
                  fit <- lm(y.boot ~ x.boot + I(x.boot^2) + I(x.boot^3))
                  B <- coef(fit)
                  x = x.boot
                  curve(B[1] + B[2]*x + B[3]*x^2 + B[4]*x^3, col = paste(e$cubicColor, e$alphaValue, sep = ""), lty = 2, lwd = 1, add = TRUE)
                }
            }
            x = v2
            y = v1
            fit <- lm(y ~ x + I(x^2) + I(x^3))
            B <- coef(fit)
            curve(B[1] + B[2]*x + B[3]*x^2 + B[4]*x^3, col = e$cubicColor, lty = 1, lwd = 2, add = TRUE)
        }

        if(e$addYequalsX){

          abline(0,1,lty=3,lwd=2)

        }
        #if (length(varnames)>2){
        if(!is.null(e$fifthVariable)){
            if(!is.null(e$fifthVariableNumeric))
                image.plot(legend.only=TRUE, legend.shrink = 0.5, legend.width = 1.2, legend.mar = 2.3, zlim = c(min(fifthVarNumeric),max(fifthVarNumeric)), nlevels = length(levels(factor(fifthVarNumeric))), col=cols, main=e$fifthVarName, legend.args=list(text = e$fifthVarName, cex = 1, line = 1), add = TRUE, horizontal = FALSE)
            else
                legend("topright",substr(levels(e$fifthVariableSubset),1,15),bg = "transparent", pch=1,col=cols,title=e$fifthVarName,pt.cex=1,cex=1,pt.lwd=2)
        }
#          if(all(substr(levs,nchar(levs),nchar(levs)) == "]")){
#              legend("bottomright",substr(levs,1,max(nchar(levs))),pch=1:length(levs),
#              col=cols,title=varnames[3],pt.cex=1,cex=1,pt.lwd=2)
#          }else{
#            if(length(levs) > 13)
#              legend("bottomright",substr(levs,1,7),pch=1:length(levs),
#              col=cols,title=varnames[3],pt.cex=0.5,cex=0.5,pt.lwd=2)       ###################### ADDED THIS & changed substr
#            else
#              legend("bottomright",substr(levs,1,7),pch=1:length(levs),
#              col=cols,title=varnames[3],pt.cex=1,cex=1,pt.lwd=2)
#          }
#

      }



    }else if (vartypes[1]=="CAT" & vartypes[2]=="CAT") {
      e$dotChartView = FALSE
      e$scatterPlotView = FALSE


      v1 = as.factor(v1)
      v2 = as.factor(v2)
      nv1 = length(levels(v1))

      tbl = table(v1,v2)
      Rowsums = rowSums(tbl)
      Colsums.1 = colSums(tbl)
      pcent = 100 * sweep(tbl, 1, Rowsums, "/")   # as Percentages
      pcent.1 = 100 * sweep(tbl, 2, Colsums.1, "/")
      nrt = nrow(tbl)
      nct= ncol(tbl)
      n3 = 1
      if (length(varnames)>2) {
        v3 = as.factor(dframe[,varnames[3]])

        vn3 = varnames[3]
        levs3 = levels(v3)
        n3 = length(levs3)
        tbl = table(v2,v1,v3)
        pcent = 100 * sweep(tbl, c(2,3), apply(tbl, c(2,3), sum), '/')  #CHECK

         if(n3 == 1)
            par(mfrow =c(1,1), bg = "white")
         else if(n3%%2 == 0)
            par(mfrow = c(n3/2, 2), bg = "white")
         else if(n3%%2 != 0)
            par(mfrow = c((n3/2)+ 0.5, 2), bg = "white")


      }
      xtop = (1+nrt)*nct*1.2
      #ytop = min(100, max(pcent,na.rm=TRUE)*ifelse(e$drawIntervals, 1.2, 1.05))  # Need to get the max limit
      ytop = min(100, max(pcent,na.rm=TRUE)*ifelse(e$drawIntervals, 1.2, 1.05))
      ylabs = pretty(c(0,ytop),8)
      if (n3>1) plotheight=3 else plotheight=4
      cols = barcols(nv1,c=35,lum1=70,lum2=40)
      barlwd <- max(0.8, min(5, 60 / (nrt * nct)))

      qval <- 1.96  # abs(qnorm(1 - 0.95))

      for (j in 1:n3) {

        #par(mar=c(4.8,4.1,1.2,0.1)) # , cex=1  bottom left top right
        par(mar=c(4.8,4.1,1.2,0.1)) ####################################################################################### Thursday 18th March Changed

        if (n3==1) {

# Calculate the upper & lower limits of the graphs
            if (e$drawIntervals){

              if(e$useBootstrap){

                # one interval or both?

              }else{
                barsize = pcent
                props = pcent
                barsize.conf.L <- pcent
                barsize.conf.U <- pcent

                for (r in 1:nrt)
                  barsize[r,] <- 100 * qval * errorbarsize(proportion.covs(tbl[r,]))

                barsize[tbl < Errorbar.threshold] <- NA
                xvals <- 0.5+as.vector(outer(1:nrt,0:(nct-1),function(u,v) (nrt+1)*v+u))

                if(e$drawBothInf){
                  #Confidence Intervals

                  for(r in 1:nrt){

                    n.sub = sum(tbl[r,])
                    props[r,] =  pcent[r,]/100
                    se = sqrt(props[r,] * (1-props[r,])/n.sub)

                    barsize.conf.L[r,] = (props[r,] - qval * se) * 100
                    barsize.conf.L[tbl < Errorbar.threshold] <- NA
                    barsize.conf.U[r,] = (props[r,] + qval * se) * 100
                    barsize.conf.U[tbl < Errorbar.threshold] <- NA
                  }
                  x.temp = max(as.vector(barsize.conf.U), na.rm = TRUE)
                  if(!is.infinite(x.temp))
                    ytop = x.temp
                  ylabs = pretty(c(0,ytop),8)
                }
              }
            }

# Draw the plots
          barplot(pcent,xlim=c(0,xtop + 5),ylim=c(0,ytop),axes=FALSE,
            xlab=varnames[2],ylab="",beside=TRUE,
            legend.text=substr(levels(v1),1,7),
            cex.lab=1,cex.axis=1,cex.names=1,col=cols, args.legend = list(title = varnames[1], xjust = 1, cex = 0.8)) ######### changed
          axis(2,at=ylabs,lab=paste(ylabs,'%',sep=''),las=1)
          title(paste(varnames[2],"by",varnames[1], ifelse(is.null(e$fourthVariable), "", paste("for", e$fourthVarName, "=", (levels(e$fourthVariable)[e$sliderData2]))),sep=" "))
#          if (year12) {
#            barsize <- pcent
#            for (r in 1:nrt)
#              barsize[r,] <- 100 * errorbarsize(proportion.covs(tbl[r,]))
#
#            barsize[tbl < Errorbar.threshold] <- NA
#            xvals <- 0.5+as.vector(outer(1:nrt,0:(nct-1),function(u,v) (nrt+1)*v+u))
#            segments(xvals, pcent - barsize, xvals, pcent + barsize,
#              col=BarchartBarCol, lwd=barlwd, lend=1)
#          }

            if (e$drawIntervals){

              if(e$useBootstrap){

                # one interval or both?

              }else{

                if(e$drawBothInf){
                  #Confidence Intervals
                  segments(xvals, barsize.conf.L, xvals, barsize.conf.U, col="red", lwd=1, lend=1)
                }
                #Comparison Intervals
                segments(xvals, pcent - barsize, xvals, pcent + barsize, col=BarchartBarCol, lwd=barlwd, lend=1)
              }
            }
        }
        else {
          tbl = table(v1[v3==levs3[j]],v2[v3==levs3[j]])
          Rowsums = rowSums(tbl)
          pcent = 100 * sweep(tbl, 1, Rowsums, "/")

# Calculate the upper & lower limits of the graphs
          if (e$drawIntervals){

            if(e$useBootstrap){

                # one interval or both?

            }else{
              barsize = pcent
              props = pcent
              barsize.conf.L <- pcent
              barsize.conf.U <- pcent

              for (r in 1:nrt)
                barsize[r,] <- 100 * qval * errorbarsize(proportion.covs(tbl[r,]))

              barsize[tbl < Errorbar.threshold] <- NA
              xvals <- 0.5+as.vector(outer(1:nrt,0:(nct-1),function(u,v) (nrt+1)*v+u))

              if(e$drawBothInf){
                  #Confidence Intervals

                for(r in 1:nrt){

                  n.sub = sum(tbl[r,])
                  props[r,] =  pcent[r,]/100
                  se = sqrt(props[r,] * (1-props[r,])/n.sub)

                  barsize.conf.L[r,] = (props[r,] - qval * se) * 100
                  barsize.conf.L[tbl < Errorbar.threshold] <- NA
                  barsize.conf.U[r,] = (props[r,] + qval * se) * 100
                  barsize.conf.U[tbl < Errorbar.threshold] <- NA
                }
                #ytop = max(as.vector(barsize.conf.U), na.rm = TRUE)
                #ylabs = pretty(c(0,ytop),8)
              }
            }
          }

          barplot(pcent,xlim=c(0,xtop + 5),ylim=c(0,ytop),axes=FALSE,
            xlab=varnames[2],ylab="",beside=TRUE,
            legend.text=substr(levels(v1),1,7),
            cex.lab=1,cex.axis=1,cex.names=1,col=cols, args.legend = list(title = varnames[1], xjust = 1, cex = 0.8))  ########## changed
          axis(2,at=ylabs,lab=paste(ylabs,'%',sep=''),las=1)
          title(paste(varnames[2]," by ",varnames[1],ifelse(is.null(e$fourthVariable), paste("for", varnames[3], "=", levs3[j]), paste("for", varnames[3], "=", levs3[j], " & ", e$fourthVarName, "=", (levels(e$fourthVariable)[e$sliderData2]))),sep=""))

          if (e$drawIntervals){

            if(e$useBootstrap){

              # one interval or both?

            }else{

              if(e$drawBothInf){
              #Confidence Intervals
                segments(xvals, barsize.conf.L, xvals, barsize.conf.U, col="red", lwd=1, lend=1)
              }
              #Comparison Intervals
              segments(xvals, pcent - barsize, xvals, pcent + barsize, col=BarchartBarCol, lwd=barlwd, lend=1)
            }
          }

#          if (year12) {
#            barsize <- pcent
#            for (r in 1:nrt)
#              barsize[r,] <- 100 * errorbarsize(proportion.covs(tbl[r,]))
#
#            barsize[tbl < Errorbar.threshold] <- NA
#            xvals <- 0.5+as.vector(outer(1:nrt,0:(nct-1),function(u,v) (nrt+1)*v+u))
#            segments(xvals, pcent - barsize, xvals, pcent + barsize,
#              col=BarchartBarCol, lwd=barlwd, lend=1)
#          }

        }
      }
    }
    else {
      e$dotChartView = TRUE
      e$scatterPlotView = FALSE
      i1=2; i2=1
      if (vartypes[1]=="CAT" & vartypes[2]=="CONT") {i1=1; i2=2}

      vn1 = varnames[i2]
      vn2 = varnames[i1]
      v1 = dframe[,i1]
      v2 = dframe[,i2]
      levelNames = levels(as.factor(v2))

      ngrps = length(levels(as.factor(v2)))
      plotheight=2.5
      if (ngrps> 2) plotheight=3
      if (ngrps> 3) plotheight=4
      if (ngrps> 5) plotheight=5.2

      n3 = 1

      if (length(varnames)>2) {
        v3 = as.factor(dframe[,3]); vn3 = varnames[3]
        levs3 = levels(v3)
        n3 = length(levs3)
        xlims=range(v1,na.rm=T)
        xlims=xlims + c(-0.2,0.04)*(xlims[2]-xlims[1])
        v3.ordered = numeric(0)

      if(n3 == 1)
        par(mfrow =c(1,1), bg = e$basicBackgroundDot)
      else if(n3%%2 == 0)
        par(mfrow = c(n3/2, 2), bg = e$basicBackgroundDot)
      else if(n3%%2 != 0)
        par(mfrow = c((n3/2)+ 0.5, 2), bg = e$basicBackgroundDot)


     }
     if(!is.null(e$fifthVariableNumeric)) par(oma = c(rep(0.1,3),2))

      if(!is.null(e$fifthVariable)){
          nv5 = length(levels(e$fifthVariableSubset))

          cols = barcols(nv5,c=65,lum1=60,lum2=30)
          pcols = cols[as.numeric(as.factor(fifthVarSubset))]

          if(!is.null(e$fifthVariableNumeric)){
            #cols = rev(terrain.colors(length(levels(factor(fifthVarNumeric))), alpha = 1))
            #cols = rainbow(length(levels(factor(fifthVarNumeric))), start = 0, end = 4/6)

#            dineika.palette <- colorRampPalette(c("red", "orchid4", "blue"), space = "rgb")
#            cols = rev(dineika.palette(length(levels(factor(fifthVarNumeric)))))
            cols = rev(rainbow(length(levels(factor(fifthVarNumeric))), start = .7, end = .1))
            pcols = cols[as.numeric(as.factor(fifthVarNumeric))]

          }
          v1.ordered = numeric(0)
          v2.ordered = numeric(0)
          pcols.ordered = numeric(0)


          for(i in 1:ngrps){
            temp.v1 = v1[v2 == levels(v2)[i]]
            temp.v2 = v2[v2 == levels(v2)[i]]

            temp.pcols = pcols[v2 == levels(v2)[i]]
            ii  = order(temp.v1,temp.pcols)
            v1.ordered = c(v1.ordered,temp.v1[ii])
            v2.ordered = c(v2.ordered,temp.v2[ii])
            pcols.ordered = c(pcols.ordered,temp.pcols[ii])

            if (length(varnames)>2) {
              temp.v3 = v3[v2 == levels(v2)[i]]
              v3.ordered = c(v3.ordered,temp.v3[ii])
            }
          }

          v1 = v1.ordered

          v2.try = try(factor(v2.ordered, labels = levelNames))     #------------------ added Oct 13th
          if(!inherits(v2.try,"try-error")) v2 = v2.try
          else v2 = factor(v2.ordered, labels = levels(factor(v2)))

          #v2 = factor(v2.ordered, labels = levelNames)

          pcols = pcols.ordered
          if (length(varnames)>2)  v3 = factor(v3.ordered, labels = levs3)


      }else
          pcols = e$basicDotColor

     pcols1 = pcols

      for (j in 1:n3) {


        par(mar=c(0.1,0.1,1,0.1),  bg = e$basicBackgroundDot) # ,cex=1
        if (n3==1){
          boxpoints2(v1,v2,vn1,vn2,
            labeltext = ifelse(is.null(e$fourthVariable), "", paste("for", e$fourthVarName, "=", (levels(e$fourthVariable)[e$sliderData2]))),
            boxfill=NA,ptcol=pcols,
            errorbarcol=ifelse(year12,BoxBarCol,NA))

        }else{

          if(!is.null(e$fifthVariable))
            pcols1 = pcols[v3==levs3[j]]

          boxpoints2(v1[v3==levs3[j]],v2[v3==levs3[j]],vn1,vn2,
            labeltext=ifelse(is.null(e$fourthVariable), paste("for", varnames[3], "=", levs3[j]), paste("for", varnames[3], "=", levs3[j], " & ", e$fourthVarName, "=", (levels(e$fourthVariable)[e$sliderData2]))),
            xlims=xlims,prettyx=pretty(v1),
            boxfill=NA,ptcol=pcols1,
            errorbarcol=ifelse(year12,BoxBarCol,NA))



        }

      }

      if(!is.null(e$fifthVariable)){
        if(!is.null(e$fifthVariableNumeric)){
            if(min(fifthVarNumeric) != max(fifthVarNumeric))
              image.plot(legend.only=TRUE, legend.shrink = 0.5, legend.width = 1.2, legend.mar = 2.3, zlim = c(min(fifthVarNumeric),max(fifthVarNumeric)), nlevels = length(levels(factor(fifthVarNumeric))), col=cols, main=e$fifthVarName, legend.args=list(text = e$fifthVarName, cex = 1, line = 1), add = TRUE, horizontal = FALSE) # legend.lab = e$fifthVarName
            else
              legend("right",as.character(min(fifthVarNumeric)),bg = "transparent",pch=19,col=cols,title=e$fifthVarName,pt.cex=1,cex=1,pt.lwd=2)
        }else
            legend("right",substr(levels(e$fifthVariableSubset),1,15),bg = "transparent",pch=1,col=cols,title=e$fifthVarName,pt.cex=1,cex=1,pt.lwd=2)
      }

    }


  }

}

#
analysisStep2 <- function(datafile,varnames,vartypes, plotType, sliderValue, year12=FALSE) {

  for(i in 1:ncol(datafile))
    datafile[,i] = replace(datafile[,i],which(any(datafile[,i] %in% c("NULL","NA","N/A","#N/A",""))), NA)

  #new local variables
  fifthVarSubset = NULL
  fifthVarNumeric = NULL
  segmentVarSubset = NULL
  #segmentVarNumeric = NULL
  sixthVarSubset = NULL

  dframe = datafile

  if(e$scatterPlotView || e$dotChartView){
    if(!is.null(e$fifthVariable)){
      dframe = cbind(dframe, fifthVarSubset = e$fifthVariableSubset)
      if(!is.null(e$fifthVariableNumeric))
        dframe = cbind(dframe, fifthVarNumeric = e$fifthVariableNumeric)
    }
  }
  if(e$scatterPlotView){
    if(!is.null(e$sixthVariable))
      dframe = cbind(dframe, sixthVarSubset = e$sixthVariableSubset)
  }

  if(!e$scatterPlotView && !e$dotChartView){
    if(!is.null(e$segmentVariable)){
      dframe = cbind(dframe, segmentVarSubset = e$segmentVariableSubset)
    }
  }


  dframe = na.omit(dframe)

  if(e$scatterPlotView || e$dotChartView){
    if(!is.null(e$fifthVariable)){
      fifthVarSubset = dframe[,"fifthVarSubset"]

      if(!is.null(e$fifthVariableNumeric))
        fifthVarNumeric = dframe[,"fifthVarNumeric"]

    }
  }
  if(e$scatterPlotView){
    if(!is.null(e$sixthVariable))
      sixthVarSubset = dframe[,"sixthVarSubset"]
  }
  if(!e$scatterPlotView && !e$dotChartView){

    if(!is.null(e$segmentVariable)){
      segmentVarSubset = dframe[,"segmentVarSubset"]

    }
  }

  dframe = data.frame(dframe[,1:ncol(datafile)])
  colnames(dframe) = varnames

  if(e$sliderCreated){
    if(is.factor(svalue(tag(e$obj,"groupingVarData")))){
      #if(is.null(e$fourthVariable))
        e$gpVarLbls = levels(factor(dframe[,3]))
#      else
#        e$gpVarLbls = levels(factor(dframe[,3][e$fourthVariable == (levels(e$fourthVariable)[e$sliderData2])]))

    }else{
      #if(is.null(e$fourthVariable))
        e$gpVarLbls = levels(convert.to.factor(dframe[,3]))
#      else
#        e$gpVarLbls = levels(convert.to.factor((dframe[,3])[e$fourthVariable == (levels(e$fourthVariable)[e$sliderData2])]))
    }

    svalue(e$lbl) = paste(c("*",e$gpVarLbls), collapse = "   ")

  }


	samp.size <- nrow(dframe)
  for (i in 1:length(varnames)) {
    if (vartypes[i] == "CONT" & is.factor(dframe[,i]))
      vartypes[i] <- "CAT"
  }
# Tweaks to 2007 Data

	if (any(varnames=='timetravel'))
    dframe$timetravel <- relevel(dframe$timetravel, 'less10')
	if (any(varnames=='futurejob'))
    dframe$futurejob <- relevel(dframe$futurejob, 'no')
  if (any(varnames=='bedtime')) {
    bedtimes <- levels(dframe$bedtime)
    if (length(bedtimes) == length(grep("^[0-9]*:[0-9][0-9]:00$",bedtimes))) {
      bedtimes <- levels(dframe$bedtime) <- gsub(":00$","",levels(dframe$bedtime))
      x = as.numeric(gsub(":",".",bedtimes))
      x = ifelse(x<12,x+24,x)
      newbedtimes = bedtimes[order(x)]
      dframe$bedtime <- factor(newbedtimes[rank(x)[as.integer(dframe$bedtime)]], levels=newbedtimes)
    }
  }
  if (any(varnames=="techmp") & !any(colnames(dframe)=="techmp"))
    varnames[varnames=="techmp"] <- "techmp3"


  if (length(varnames) == 3){
    if(vartypes[3] == "CONT")
      dframe[,3] = convert.to.factor(dframe[,3])
    else
      dframe[,3] = factor(dframe[,3])
  }


  if (length(varnames)>1) {

    varnames = c(varnames[2],varnames[1],varnames[c(-2,-1)])   #Changed this
    vartypes = c(vartypes[2],vartypes[1],vartypes[c(-2,-1)])   #Changed this
    v1 = dframe[,varnames[1]]
    v2 = dframe[,varnames[2]]


    if(vartypes[1]=="CONT" & vartypes[2]=="CONT") {
      ylims=range(v1,na.rm=T);

      xlims=range(v2,na.rm=T)
      if(!is.null(e$fifthVariable)) xlims[2] = xlims[2]+ 0.1*(xlims[2]-xlims[1])

      pchs=1; pcols=e$basicScatterColor
      e$dotChartView = FALSE
      e$scatterPlotView = TRUE

      if (length(varnames)>2) {      #***************************** 1st CHANGE
        par(mfrow = c(1,1),  bg = e$basicBackgroundScatter)
        grp = dframe[,3]
        gpVarLbls = levels(grp)

        factorLevel = gpVarLbls[sliderValue]
        v1 = dframe[grp == factorLevel, varnames[1]]
        v2 = dframe[grp == factorLevel, varnames[2]]

        x = v2
        y = v1

        if(e$addJitterX)  v2 = jitter(v2)
        if(e$addJitterY)  v1 = jitter(v1)

        xlims[2] = xlims[2]+0.2*(xlims[2]-xlims[1])
        levs = factorLevel
        nv3 = length(levs)
        pchs = as.numeric(grp)

        #cols = barcols(length(gpVarLbls),c=65,lum1=60,lum2=30)  #****************** changed cols
        #cols =  heat.colors(length(gpVarLbls), alpha = 1)


        if(!is.null(e$fifthVariable)){
          nv5 = length(levels(e$fifthVariableSubset))
          cols = barcols(nv5,c=65,lum1=60,lum2=30)
          pcols = cols[as.numeric(as.factor(fifthVarSubset))]
          pchs = rep(1,length(dframe[,3]))
          if(!is.null(e$fifthVariableNumeric)){
             par(oma = c(rep(0.1,3),2), bg = e$basicBackgroundScatter)
             #cols = rev(terrain.colors(length(levels(factor(fifthVarNumeric))), alpha = 1))
             #cols = rainbow(length(levels(factor(fifthVarNumeric))), start = 0, end = 4/6)

#             dineika.palette <- colorRampPalette(c("red", "orchid4", "blue"), space = "rgb")
#             cols = rev(dineika.palette(length(levels(factor(fifthVarNumeric)))))
              cols = rainbow(length(levels(factor(fifthVarNumeric))), start = .7, end = .1)

             pcols = cols[as.numeric(as.factor(fifthVarNumeric))]
          }
        }else{
          pchs = rep(1,length(dframe[,3]))
          cols = rep(e$basicScatterColor, length(gpVarLbls))
          pcols = cols[as.numeric(as.factor(dframe[,3]))]
        }

        par(mar=c(4.5,5.1,4.1,0.5), bg = e$basicBackgroundScatter)

        plot(xlims,ylims,type="n",xlab=varnames[2],ylab=varnames[1],cex.axis=1,cex.lab=1)

        if(e$addRugX) rug(v2, side = 1)
        if(e$addRugY) rug(v1, side = 2)


        title(main=list(paste(varnames[1],"by",varnames[2], ifelse(is.null(e$fourthVariable), paste("for", varnames[3], "=", levs), paste("for", varnames[3], "=", levs, " & ", e$fourthVarName, "=", (levels(e$fourthVariable)[e$sliderData2])))),cex=1))

      # JOIN BY LINES ##############################################################
            if(e$joinByLines){

              if(!is.null(e$fifthVariable)){

                if(is.null(e$fifthVariableNumeric)){


                  for(colIndex in 1:nv5){

                    pcolsTemp = pcols[fifthVarSubset == levels(fifthVarSubset)[colIndex]]#(pcols[dframe[,3]==factorLevel])[fifthVarSubset == levels(fifthVarSubset)[colIndex]]

                    points(v2[fifthVarSubset == levels(fifthVarSubset)[colIndex]],v1[fifthVarSubset == levels(fifthVarSubset)[colIndex]],col= pcolsTemp, lwd=e$scatterThickness2/2, type = "l")
                  }

                }else
                  points(v2,v1,col= "black", lwd=e$scatterThickness2/2 , type = "l")

              }else
                points(v2,v1,col= "black", lwd=e$scatterThickness2/2, type = "l")

            }

      #############################################################################


        #points(v2,v1,cex=1,pch=sliderValue,col=cols[sliderValue],lwd=2)               #****************** changed pcols
        #pchs[dframe[,3]==factorLevel]
        if(is.null(e$sixthVariable))
            points(v2,v1,cex=e$basicCexScatter,pch=e$basicPlottingCharScatter,col=pcols[dframe[,3]==factorLevel],lwd=e$scatterThickness2)
        else{
            if(max(sixthVarSubset) < 15) constant = 0.2
            else if(max(sixthVarSubset) < 50) constant = 0.1
            else constant = 0.1

            scaledVar = as.vector((sixthVarSubset-min(sixthVarSubset))/diff(range(sixthVarSubset)) + constant) # * e$basicCexScatter
            backgroundColor =  NA
            if(e$basicPlottingCharScatter == 1) backgroundColor = NA else backgroundColor = pcols[dframe[,3]==factorLevel]

            if(length(v2) != 0)
              symbols(v2,v1, circles=scaledVar[dframe[,3]==factorLevel], inches = maxbubsize * e$basicCexScatter, fg = pcols[dframe[,3]==factorLevel], bg = backgroundColor, add = TRUE, lwd = e$scatterThickness2)
        }




          if(e$addSmoother == TRUE){
              v1.sub = dframe[grp == factorLevel, varnames[1]]
              v2.sub = dframe[grp == factorLevel, varnames[2]]
              if(e$drawBootLines){
                  obs.ids = 1:length(v1.sub)
                  for(j in 1:e$numBootLines){
                    boot.ids = sample(obs.ids,replace=T)
                    lines(lowess(v2.sub[boot.ids], v1.sub[boot.ids], f = e$smootherValue), col = paste(e$smootherColor, e$alphaValue, sep = ""), lwd = 1, lty = 2)
                  }
              }

              lines(lowess(v2.sub, v1.sub, f = e$smootherValue), col = e$smootherColor, lwd = 1)
          }

          if(e$addLinearTrend){
            v1.sub = dframe[grp == factorLevel, varnames[1]]
            v2.sub = dframe[grp == factorLevel, varnames[2]]
            if(e$drawBootLines){
                obs.ids = 1:length(v1.sub)
                for(j in 1:e$numBootLines){
                  boot.ids = sample(obs.ids,replace=T)
                  abline(reg = lm(v1.sub[boot.ids] ~ v2.sub[boot.ids]), col = paste(e$linearColor, e$alphaValue, sep = ""),lty = 2, lwd = 1)
                }
            }

              abline(reg = lm(v1.sub ~ v2.sub), col = e$linearColor, lty = 1, lwd = 1)
          }


          if(e$addQuadTrend){

            y = dframe[grp == factorLevel, varnames[1]]
            x = dframe[grp == factorLevel, varnames[2]]

            if(e$drawBootLines){
                obs.ids = 1:length(x)
                for(j in 1:e$numBootLines){


                  y = dframe[grp == factorLevel, varnames[1]]
                  x = dframe[grp == factorLevel, varnames[2]]
                  boot.ids = sample(obs.ids,replace=T)
                  x = x[boot.ids]
                  y = y[boot.ids]
                  #x = x.boot
                  fit <- lm(y ~ x  + I(x^2))
                  B <- coef(fit)
                  curve(B[1] + B[2]*x + B[3]*x^2,col = paste(e$quadColor, e$alphaValue, sep = ""), lty = 2, lwd = 1, add = TRUE)
                }
            }

            y = dframe[grp == factorLevel, varnames[1]]
            x = dframe[grp == factorLevel, varnames[2]]
            fit <- lm(y ~ x + I(x^2))
            B <- coef(fit)
            curve(B[1] + B[2]*x + B[3]*x^2,col = e$quadColor,, lty = 1, lwd = 1, add = TRUE)

          }
          if(e$addCubicTrend){

            y = dframe[grp == factorLevel, varnames[1]]
            x = dframe[grp == factorLevel, varnames[2]]

            if(e$drawBootLines){
                obs.ids = 1:length(x)

                for(j in 1:e$numBootLines){
                  y = dframe[grp == factorLevel, varnames[1]]
                  x = dframe[grp == factorLevel, varnames[2]]
                  boot.ids = sample(obs.ids,replace=T)
                  x = x[boot.ids]
                  y = y[boot.ids]

                  fit <- lm(y ~ x + I(x^2) + I(x^3))
                  B <- coef(fit)

                  curve(B[1] + B[2]*x + B[3]*x^2 + B[4]*x^3, col = paste(e$cubicColor, e$alphaValue, sep = ""), lty = 2, lwd = 1, add = TRUE)
                }
            }
            y = dframe[grp == factorLevel, varnames[1]]
            x = dframe[grp == factorLevel, varnames[2]]
            fit <- lm(y ~ x + I(x^2) + I(x^3))
            B <- coef(fit)
            curve(B[1] + B[2]*x + B[3]*x^2 + B[4]*x^3, col = e$cubicColor, lty = 1, lwd = 1, add = TRUE)
          }

        if(e$addYequalsX){

          abline(0,1,lty=3,lwd=1)

        }

        if(!is.null(e$fifthVariable)){

          if(!is.null(e$fifthVariableNumeric))
              image.plot(legend.only=TRUE, legend.shrink = 0.5, legend.width = 1.2, legend.mar = 2.3, zlim = c(min(fifthVarNumeric),max(fifthVarNumeric)), nlevels = length(levels(factor(fifthVarNumeric))), col=cols, main=e$fifthVarName, legend.args=list(text = e$fifthVarName, cex = 1, line = 1), add = TRUE, horizontal = FALSE)
          else
              legend("topright",substr((levels(e$fifthVariableSubset)),1,15),bg = "transparent",pch = 1, col=cols,title=e$fifthVarName, pt.cex=1,cex=1,pt.lwd=2)
        }
      }

    }
    else if (vartypes[1]=="CAT" & vartypes[2]=="CAT") {
      v1 = as.factor(v1)
      v2 = as.factor(v2)
      nv1 = length(levels(v1))

      e$dotChartView = FALSE
      e$scatterPlotView = FALSE

      tbl = table(v1,v2)
      Rowsums = rowSums(tbl)
      pcent = 100 * sweep(tbl, 1, Rowsums, "/")   # as Percentages
      nrt = nrow(tbl)
      nct= ncol(tbl)
      n3 = 1
      if (length(varnames)>2) {
        par(mfrow = c(1,1), bg = "white")
        grp = dframe[,varnames[3]]
        gpVarLbls = levels(factor(grp))
        factorLevel = gpVarLbls[sliderValue]
        v3 = dframe[,varnames[3]]    #***************************** 5th CHANGE (removed the as.factor since the third variable is always a factor
        vn3 = varnames[3]
        levs3 = factorLevel
        n3 = length(levs3)
        tbl = table(v2,v1,v3)
        pcent = 100 * sweep(tbl, c(2,3), apply(tbl, c(2,3), sum), '/')

      }
      xtop = (1+nrt)*nct*1.2
      ytop = min(100, max(pcent,na.rm=TRUE)*ifelse(e$drawIntervals, 1.2, 1.05))
      ylabs = pretty(c(0,ytop),8)
      if (n3>1) plotheight=3 else plotheight=4
      cols = barcols(nv1,c=35,lum1=70,lum2=40)
      barlwd <- max(0.8, min(5, 60 / (nrt * nct)))

      for (j in 1:n3) {

        par(mar=c(4.8,4.1,1.2,0.1), bg = "white")

        if(!length(varnames) == 3){#(n3==1) {  #****************************************************change this condition
          barplot(pcent,xlim=c(0,xtop + 5),ylim=c(0,ytop),axes=FALSE,
            xlab=varnames[2],ylab="",beside=TRUE,
            legend.text=substr(levels(v1),1,7),
            cex.lab=1,cex.axis=1,cex.names=1,col=cols, args.legend = list(title = varnames[1], xjust = 1, cex = 0.8))
          axis(2,at=ylabs,lab=paste(ylabs,'%',sep=''),las=1)
          #title(paste(varnames[2], "by", varnames[1], "  (for ", vn3," = ", factorLevel ,")",sep=" "))
          title(paste(varnames[2]," by ",varnames[1],ifelse(is.null(e$fourthVariable), paste(" for", vn3, "=", factorLevel), paste(" for", vn3, "=", factorLevel, " & ", e$fourthVarName, "=", (levels(e$fourthVariable)[e$sliderData2]))),sep=""))

          if (year12) {
            barsize <- pcent
            for (r in 1:nrt)
              barsize[r,] <- 100 * errorbarsize(proportion.covs(tbl[r,]))

            barsize[tbl < Errorbar.threshold] <- NA
            xvals <- 0.5+as.vector(outer(1:nrt,0:(nct-1),function(u,v) (nrt+1)*v+u))
            segments(xvals, pcent - barsize, xvals, pcent + barsize,
              col=BarchartBarCol, lwd=barlwd, lend=1)
          }



        }
        else {

          tbl = table(v1[v3==levs3[j]],v2[v3==levs3[j]])
          Rowsums = rowSums(tbl)
          pcent = 100 * sweep(tbl, 1, Rowsums, "/")  #*************Change the xtop addition + 0

          if (e$drawIntervals){

            if(e$useBootstrap){

                            # one interval or both?

            }else{
              barsize = pcent
              props = pcent
              barsize.conf.L <- pcent
              barsize.conf.U <- pcent
              qval <- 1.96
              for (r in 1:nrt)
                barsize[r,] <- 100 * qval * errorbarsize(proportion.covs(tbl[r,]))

              barsize[tbl < Errorbar.threshold] <- NA
              xvals <- 0.5+as.vector(outer(1:nrt,0:(nct-1),function(u,v) (nrt+1)*v+u))

              if(e$drawBothInf){
              #Confidence Intervals

                for(r in 1:nrt){

                  n.sub = sum(tbl[r,])
                  props[r,] =  pcent[r,]/100
                  se = sqrt(props[r,] * (1-props[r,])/n.sub)

                  barsize.conf.L[r,] = (props[r,] - qval * se) * 100
                  barsize.conf.L[tbl < Errorbar.threshold] <- NA
                  barsize.conf.U[r,] = (props[r,] + qval * se) * 100
                  barsize.conf.U[tbl < Errorbar.threshold] <- NA
                }
                x.temp = max(as.vector(barsize.conf.U), na.rm = TRUE) # sometimes all barsize are NA so max(vector(0)) returns -Inf
                if(!is.infinite(x.temp))
                  ytop = x.temp
                ylabs = pretty(c(0,ytop),8)
              }
            }
          }

          barplot(pcent,xlim=c(0,xtop),ylim=c(0,ytop),axes=FALSE,
            xlab=varnames[2],ylab="",beside=TRUE,
            legend.text=substr(levels(v1),1,7),
            cex.lab=1,cex.axis=1,cex.names=1,col=cols, args.legend = list(title = varnames[1], xjust = 1, cex = 1))#*************Change the cex
          axis(2,at=ylabs,lab=paste(ylabs,'%',sep=''),las=1)
          #title(paste(varnames[2]," by ",varnames[1],"  (for ",vn3," = ",levs3[j],")",sep="")) # **************************** Changed
          title(paste(varnames[2]," by ",varnames[1],ifelse(is.null(e$fourthVariable), paste(" for", vn3, "=", levs3[j]), paste(" for", vn3, "=", levs3[j], " & ", e$fourthVarName, "=", (levels(e$fourthVariable)[e$sliderData2]))),sep=""))


          if (e$drawIntervals){

            if(e$useBootstrap){

            # one interval or both?

            }else{

              if(e$drawBothInf){
              #Confidence Intervals
                segments(xvals, barsize.conf.L, xvals, barsize.conf.U, col="red", lwd=1, lend=1)
              }
              #Comparison Intervals
              segments(xvals, pcent - barsize, xvals, pcent + barsize, col=BarchartBarCol, lwd=barlwd, lend=1)
            }
          }

#          if (year12) {
#            barsize <- pcent
#            for (r in 1:nrt)
#              barsize[r,] <- 100 * errorbarsize(proportion.covs(tbl[r,]))
#            barsize[tbl < Errorbar.threshold] <- NA
#            xvals <- 0.5+as.vector(outer(1:nrt,0:(nct-1),function(u,v) (nrt+1)*v+u))
#            segments(xvals, pcent - barsize, xvals, pcent + barsize,
#              col=BarchartBarCol, lwd=barlwd, lend=1)
#          }


        }
      }
    }
    else {


      e$dotChartView = TRUE
      e$scatterPlotView = FALSE
      i1=2; i2=1
      if (vartypes[1]=="CAT" & vartypes[2]=="CONT") {i1=1; i2=2}

      vn1 = varnames[i2]
      vn2 = varnames[i1]
      v1 = dframe[,i1]
      v2 = dframe[,i2]
      levelNames = levels(as.factor(v2))
      ngrps = length(levels(as.factor(v2)))
      plotheight=2.5
      if (ngrps> 2) plotheight=3
      if (ngrps> 3) plotheight=4
      if (ngrps> 5) plotheight=5.2

      n3 = 1


      if (length(varnames)>2) {
        par(mfrow  = c(1,1), bg = e$basicBackgroundDot)       #***************************** Change

        grp = dframe[,3]
        #print(head(grp))
        gpVarLbls = levels(factor(grp))
        factorLevel = gpVarLbls[sliderValue]
        v3 = as.factor(dframe[,3])
        vn3 = varnames[3]
        levs3 = factorLevel
        n3 = length(levs3)
        v3.ordered = numeric(0)
        xlims=range(v1,na.rm=T)
        xlims=xlims + c(-0.2,0.04)*(xlims[2]-xlims[1])



     }


      if(!is.null(e$fifthVariable)){

          nv5 = length(levels(e$fifthVariableSubset))
          cols = barcols(nv5,c=65,lum1=60,lum2=30)
          pcols = cols[as.numeric(as.factor(fifthVarSubset))]
          if(!is.null(e$fifthVariableNumeric)){
            par(oma =c(0.1,0.1,0.1,2), bg = e$basicBackgroundDot)
            #cols = rev(terrain.colors(length(levels(factor(fifthVarNumeric))), alpha = 1))
            #cols = rainbow(length(levels(factor(fifthVarNumeric))), start = 0, end = 4/6)

#            dineika.palette <- colorRampPalette(c("red", "orchid4", "blue"), space = "rgb")
#            cols = rev(dineika.palette(length(levels(factor(fifthVarNumeric)))))
            cols = rainbow(length(levels(factor(fifthVarNumeric))), start = .7, end = .1)
            pcols = cols[as.numeric(as.factor(fifthVarNumeric))]
          }
          v1.ordered = numeric(0)
          v2.ordered = numeric(0)
          pcols.ordered = numeric(0)


          for(i in 1:ngrps){
            temp.v1 = v1[v2 == levels(v2)[i]]
            temp.v2 = v2[v2 == levels(v2)[i]]

            temp.pcols = pcols[v2 == levels(v2)[i]]
            ii  = order(temp.v1,temp.pcols)
            v1.ordered = c(v1.ordered,temp.v1[ii])
            v2.ordered = c(v2.ordered,temp.v2[ii])
            pcols.ordered = c(pcols.ordered,temp.pcols[ii])

            if (length(varnames)>2) {
              temp.v3 = v3[v2 == levels(v2)[i]]
              v3.ordered = c(v3.ordered,temp.v3[ii])
            }
          }

          v1 = v1.ordered

          v2.try = try(factor(v2.ordered, labels = levelNames))     #------------------ added Oct 13th
          if(!inherits(v2.try,"try-error")) v2 = v2.try
          else v2 = factor(v2.ordered, labels = levels(factor(v2)))


          pcols = pcols.ordered
          if (length(varnames)>2)  v3 = factor(v3.ordered, labels = gpVarLbls)

      }else
          pcols = e$basicDotColor

      pcols1 = pcols

      for (j in 1:n3) {


      par(mar=c(0.1,0.1,1,0.1), bg = e$basicBackgroundDot) # ,cex=1
      if(!length(varnames) == 3){#(n3==1) {  #****************************************************change this condition

          boxpoints2(v1,v2,vn1,vn2,
            boxfill=NA,ptcol=pcols,
            errorbarcol=ifelse(year12,BoxBarCol,NA))





        }else{

        if(!is.null(e$fifthVariable))
          pcols1 = pcols[v3==levs3[j]]

          boxpoints2(v1[v3==levs3[j]],v2[v3==levs3[j]],vn1,vn2,
            #labeltext=paste("(for ",vn3," = ",levs3[j]," )",sep=""),
            labeltext=ifelse(is.null(e$fourthVariable), paste("for", vn3, "=", levs3[j]), paste("for", vn3, "=", levs3[j], " & ", e$fourthVarName, "=", (levels(e$fourthVariable)[e$sliderData2]))),

            xlims=xlims,prettyx=pretty(v1),
            boxfill=NA,ptcol=pcols1,
            errorbarcol=ifelse(year12,BoxBarCol,NA))

        }
        if(!is.null(e$fifthVariable)){
          if(!is.null(e$fifthVariableNumeric)){
            if(min(fifthVarNumeric) != max(fifthVarNumeric))
              image.plot(legend.only=TRUE, legend.shrink = 0.5, legend.width = 1.2, legend.mar = 2.3, zlim = c(min(fifthVarNumeric),max(fifthVarNumeric)), nlevels = length(levels(factor(fifthVarNumeric))), col=cols, main=e$fifthVarName, legend.args=list(text = e$fifthVarName, cex = 1, line = 1), add = TRUE, horizontal = FALSE) # legend.lab = e$fifthVarName
            else
              legend("right",as.character(min(fifthVarNumeric)),bg = "transparent",pch=19,col=cols,title=e$fifthVarName,pt.cex=1,cex=1,pt.lwd=2)
          }else
              legend("right",substr(levels(e$fifthVariableSubset),1,15),bg = "transparent",pch=1,col=cols,title=e$fifthVarName,pt.cex=1,cex=1,pt.lwd=2)
        }
      }


    }


  }

}

# To Do List (23rd March)
# Fix the problem with minimizing the graphics window

###

analysisStep3 <- function(datafile,varnames,vartypes, plotType, sliderValue, year12=FALSE) {

  #dframe = na.omit(datafile) # Do not omit NAs before taking into account fifth sixth & segment variable

  #new local variables
  fifthVarSubset = NULL
  fifthVarNumeric = NULL
  segmentVarSubset = NULL
  #segmentVarNumeric = NULL
  sixthVarSubset = NULL

  dframe = datafile

  if(e$scatterPlotView || e$dotChartView){
    if(!is.null(e$fifthVariable)){
      dframe = cbind(dframe, fifthVarSubset = e$fifthVariableSubset)
      if(!is.null(e$fifthVariableNumeric))
        dframe = cbind(dframe, fifthVarNumeric = e$fifthVariableNumeric)
    }
  }


  if(e$scatterPlotView){
    if(!is.null(e$sixthVariable))
      dframe = cbind(dframe, sixthVarSubset = e$sixthVariableSubset)
  }

  if(!e$scatterPlotView && !e$dotChartView){
    if(!is.null(e$segmentVariable)){
      dframe = cbind(dframe, segmentVarSubset = e$segmentVariableSubset)
    }
  }

  dframe = na.omit(dframe)

  if(e$scatterPlotView || e$dotChartView){
    if(!is.null(e$fifthVariable)){
      fifthVarSubset = dframe[,"fifthVarSubset"]

      if(!is.null(e$fifthVariableNumeric))
        fifthVarNumeric = dframe[,"fifthVarNumeric"]

    }
  }
  if(e$scatterPlotView){
    if(!is.null(e$sixthVariable))
      sixthVarSubset = dframe[,"sixthVarSubset"]
  }
  if(!e$scatterPlotView && !e$dotChartView){

    if(!is.null(e$segmentVariable)){
      segmentVarSubset = dframe[,"segmentVarSubset"]

    }
  }

  dframe = data.frame(dframe[,1:ncol(datafile)])
  colnames(dframe) = varnames

  if(e$sliderCreated){
    if(is.factor(svalue(tag(e$obj,"groupingVarData")))){

        e$gpVarLbls = levels(factor(dframe[,2]))


    }else{

        e$gpVarLbls = levels(convert.to.factor(dframe[,2]))

    }

    svalue(e$lbl) = paste(c("*",e$gpVarLbls), collapse = "   ")

  }



  samp.size <- nrow(dframe)
  for (i in 1:length(varnames)) {
    if (vartypes[i] == "CONT" & is.factor(dframe[,varnames[i]]))
      vartypes[i] <- "CAT"
  }
# Tweaks to 2007 Data

	if (any(varnames=='timetravel'))
    dframe$timetravel <- relevel(dframe$timetravel, 'less10')
	if (any(varnames=='futurejob'))
    dframe$futurejob <- relevel(dframe$futurejob, 'no')
  if (any(varnames=='bedtime')) {
    bedtimes <- levels(dframe$bedtime)
    if (length(bedtimes) == length(grep("^[0-9]*:[0-9][0-9]:00$",bedtimes))) {
      bedtimes <- levels(dframe$bedtime) <- gsub(":00$","",levels(dframe$bedtime))
      x = as.numeric(gsub(":",".",bedtimes))
      x = ifelse(x<12,x+24,x)
      newbedtimes = bedtimes[order(x)]
      dframe$bedtime <- factor(newbedtimes[rank(x)[as.integer(dframe$bedtime)]], levels=newbedtimes)
    }
  }
  if (any(varnames=="techmp") & !any(colnames(dframe)=="techmp"))
    varnames[varnames=="techmp"] <- "techmp3"

################################################################################


    if(vartypes[2] == "CONT")
      dframe[,2] = convert.to.factor(dframe[,2])
    else
      dframe[,2] = factor(dframe[,2])

    if (vartypes[1]=="CAT") {

      e$dotChartView = FALSE
      e$scatterPlotView = FALSE

      v1 = dframe[,1]
      v1f <- as.factor(v1)
      nv1 = length(levels(v1f))

      grp = dframe[,2]
      gpVarLbls = levels(grp)

      n3 = length(gpVarLbls)

      v3 = dframe[,2]    #***************************** 5th CHANGE (removed the as.factor since the third variable is always a factor
      vn3 = varnames[2]


      las = 0
      cex.names = 1
      if (nv1>5) {cex.names=0.8; levels(v1f)=substr(levels(v1f),1,8)}
      if (nv1>8) {
        levels(v1f)=substr(levels(v1f),1,6)
        if (max(nchar(levels(v1f))) > 2) las=2  # Vertical labels
        cex.names = 0.8 * (30 / max(30, nv1))
      }

     cols = barcols(n3,c=65,lum1=70,lum2=40)

     if(sliderValue == 0){

      if(n3 == 1)
        par(mfrow =c(1,1), bg = "white")
      else if(n3%%2 == 0)
        par(mfrow = c(n3/2, 2), bg = "white")
      else if(n3%%2 != 0)
        par(mfrow = c((n3/2)+ 0.5, 2), bg = "white")



      colSegments = barcols(length(levels(e$segmentVariableSubset)),c=65,lum1=70,lum2=40)

      for (j in 1:n3) {

        #(bottom, left, top, right)
        #par(mar=c(2,4,2,2))
         par(mar=c(4.8,4.1,1.2,0.1))

        tbl = table(v1f[v3==gpVarLbls[j]])
        phat = tbl / sum(tbl)
        #if (nv1==2) ylim=c(0,1) else ylim=c(0,max(phat))



        ylim=c(0,1)

        if (nv1<4) xlim=c(-1,1.2*(nv1+1)) else xlim=c(0,1.2*nv1)

        if(!is.null(e$segmentVariable)){

          counts <- table(segmentVarSubset[v3==gpVarLbls[j]],v1f[v3==gpVarLbls[j]])

          phat = (table(v1f[v3==gpVarLbls[j]])) / sum(table(v1f[v3==gpVarLbls[j]]))

          Colsums = colSums(counts)
          props = sweep(counts, 2, Colsums, "/")

          for(i in 1:length(phat))
            props[,i] =  props[,i]* phat[i]


          barplot(props, col = colSegments, legend.text = rownames(props), args.legend = list(title = e$segmentVarName, xjust = 1, cex = 0.9), xlim=xlim,ylim=ylim,ylab="",xlab=varnames[1],las=las, cex.names=cex.names,cex.lab=1.2,axes=FALSE)



        }else
           barplot(phat,xlab=varnames[1],xlim=xlim,ylim=ylim,ylab="",col=Barchart1varCol, las=las, cex.names=cex.names,cex.lab=1.2,axes=FALSE)
          #barplot(phat,xlab=varnames[1],xlim=xlim,ylim=ylim,ylab="",col=cols[j], las=las, cex.names=cex.names,cex.lab=1.2,axes=FALSE)


        if(e$drawIntervals){  # Must take into consideration if e$useBootstrap is on

          qval <- 1.96 #abs(qnorm(1 - 0.95))
          phat = tbl / sum(tbl)
          n <- sum(as.vector(tbl))
          se <- sqrt(phat * (1 - phat)/n)

          xmid = 1.2 * (1:nv1) - 0.5
          barlwd = min(10, max(1, 100/nv1))
          bars = qval * errorbarsize(proportion.covs(tbl))
          bars[tbl < Errorbar.threshold] <- NA
          barsize.conf = qval * se
          barsize.conf[tbl < Errorbar.threshold] <- NA

          if(e$drawBothInf) segments(xmid, phat - barsize.conf, xmid, phat + barsize.conf, col="red", lwd=1, lend=1)
          segments(xmid, phat - bars, xmid, phat + bars, col=BarchartBarCol, lwd=barlwd, lend=1)

        }


        ylabs=pretty(ylim)
        axis(2,at=ylabs,lab=paste(100*ylabs,"%",sep=''),las=1)
        #title()

        title(ifelse(is.null(e$fourthVariable), paste(varnames[1], " for " ,vn3," = ",gpVarLbls[j],sep=""), paste(varnames[1], "for" ,vn3,"=",gpVarLbls[j], " & ", e$fourthVarName, "=", (levels(e$fourthVariable)[e$sliderData2]))))
      }

      }else{
        par(mfrow = c(1,1))
        tbl = table(v1f[v3==gpVarLbls[sliderValue]])

        phat = tbl / sum(tbl)
       # if (nv1==2) ylim=c(0,1) else ylim=c(0,max(phat))

        if(e$drawIntervals){  # Must take into consideration if e$useBootstrap is on

          qval <- 1.96 #abs(qnorm(1 - 0.95))
          phat = tbl / sum(tbl)
          n <- sum(as.vector(tbl))
          se <- sqrt(phat * (1 - phat)/n)

          xmid = 1.2 * (1:nv1) - 0.5
          barlwd = min(10, max(1, 100/nv1))
          bars = qval * errorbarsize(proportion.covs(tbl))
          bars[tbl < Errorbar.threshold] <- NA
          barsize.conf = qval * se
          barsize.conf[tbl < Errorbar.threshold] <- NA

          if(e$drawBothInf){
            x.temp = max(phat + barsize.conf, na.rm = TRUE)
            if(!is.infinite(x.temp))
              ylim = c(0, x.temp)
            else ylim=c(0,1)

          }else{
            if (any(!is.na(bars))) ylim = c(0,ifelse(is.infinite(max(phat+bars,na.rm=TRUE)), 1, max(phat + bars, na.rm = TRUE)))
          }
        }else ylim=c(0,1)


        if (nv1<4) xlim=c(-1,1.2*(nv1+1)) else xlim=c(0,1.2*nv1)

        if(!is.null(e$segmentVariable)){
          colSegments = barcols(length(levels(e$segmentVariableSubset)),c=65,lum1=70,lum2=40)
          counts <- table(segmentVarSubset[v3==gpVarLbls[sliderValue]],v1f[v3==gpVarLbls[sliderValue]])

          phat = (table(v1f[v3==gpVarLbls[sliderValue]])) / sum(table(v1f[v3==gpVarLbls[sliderValue]]))

          Colsums = colSums(counts)
          props = sweep(counts, 2, Colsums, "/")


          for(i in 1:length(phat))
            props[,i] =  props[,i]* phat[i]


          barplot(props, col = colSegments, legend.text = rownames(props), args.legend = list(title = e$segmentVarName, xjust = 1, cex = 0.9),xlim=xlim,ylim=ylim,ylab="",las=las, cex.names=cex.names,cex.lab=1.2,axes=FALSE)



        }else
          barplot(phat,xlab=varnames[1],xlim=xlim,ylim=ylim,ylab="",col=Barchart1varCol, las=las, cex.names=cex.names,cex.lab=1.2,axes=FALSE)
         #barplot(phat,xlab=varnames[1],xlim=xlim,ylim=ylim,ylab="",col=cols[sliderValue], las=las,
         #cex.names=cex.names,cex.lab=1.2,axes=FALSE)              ----------- COLOR CHANGED TO DEFAULT GREEN

        if (e$drawIntervals){

          if(e$useBootstrap){

            # one interval or both?

          }else{

            if(e$drawBothInf){
            #Confidence Intervals
              segments(xmid, phat - barsize.conf, xmid, phat + barsize.conf, col="red", lwd=1, lend=1)
            }
            #Comparison Intervals
            segments(xmid, phat - bars, xmid, phat + bars, col=BarchartBarCol, lwd=barlwd, lend=1)
          }
        }



        ylabs=pretty(ylim)
        axis(2,at=ylabs,lab=paste(100*ylabs,"%",sep=''),las=1)
        #title(paste(varnames[1], " for " ,vn3," = ",gpVarLbls[sliderValue],sep=""))
        title(ifelse(is.null(e$fourthVariable), paste(varnames[1], " for " ,vn3," = ",gpVarLbls[sliderValue],sep=""), paste(varnames[1], "for" ,vn3,"=",gpVarLbls[sliderValue], " & ", e$fourthVarName, "=", (levels(e$fourthVariable)[e$sliderData2]))))
    }
  }
  else {

      e$dotChartView = TRUE
      e$scatterPlotView = FALSE
      par(mfrow = c(1,1), bg = e$basicBackgroundDot)
      vn1 = varnames[1]
      vn2 = varnames[2]
      v1 = dframe[,1]
      v2 = dframe[,2]

      ngrps = length(levels(as.factor(v2)))
      plotheight=2.5
      if (ngrps> 2) plotheight=3
      if (ngrps> 3) plotheight=4
      if (ngrps> 5) plotheight=5.2

      n3 = 1

      par(mfrow  = c(1,1), bg = e$basicBackgroundDot)

      grp = dframe[,2]
      gpVarLbls = levels(grp)

      v3 = as.factor(dframe[,2])
      vn3 = varnames[2]

      xlims=range(v1,na.rm=T)
      xlims=xlims + c(-0.2,0.04)*(xlims[2]-xlims[1])

      if(!is.null(e$fifthVariable)){

          nv5 = length(levels(e$fifthVariableSubset))
          cols = barcols(nv5,c=65,lum1=60,lum2=30)
          pcols = cols[as.numeric(as.factor(fifthVarSubset))]

          if(!is.null(e$fifthVariableNumeric)){
            par(oma = c(0.1,0.1,0.1,2), bg = e$basicBackgroundDot)
            #cols = rev(terrain.colors(length(levels(factor(fifthVarNumeric))), alpha = 1))
            #dineika.palette <- colorRampPalette(c("red", "orchid4", "blue"), space = "rgb")
            #cols = rev(dineika.palette(length(levels(factor(fifthVarNumeric)))))
            cols = rev(rainbow(length(levels(factor(fifthVarNumeric))), start = .7, end = .1))

            pcols = cols[as.numeric(as.factor(fifthVarNumeric))]
          }
          v1.ordered = numeric(0)
          v2.ordered = numeric(0)
          pcols.ordered = numeric(0)


          for(i in 1:ngrps){
            temp.v1 = v1[v2 == levels(v2)[i]]
            temp.v2 = v2[v2 == levels(v2)[i]]

            temp.pcols = pcols[v2 == levels(v2)[i]]
            ii  = order(temp.v1,temp.pcols)
            v1.ordered = c(v1.ordered,temp.v1[ii])
            v2.ordered = c(v2.ordered,temp.v2[ii])
            pcols.ordered = c(pcols.ordered,temp.pcols[ii])

          }

          v1 = v1.ordered



          #print(levelNames)
          #print(v2.ordered)
          #levelNames = levels(as.factor(v2)) #---------------------------------------------------  changed this 23rd

          levelNames = levels(as.factor(v2.ordered)) # COMMENTED THIS OUT On October 13th

          v2.try = try(as.factor(v2.ordered, labels = levelNames)) #------------------ All 3 lines Added Oct 13th
          if(!inherits(v2.try,"try-error")) v2 = v2.try
          else v2 = factor(v2.ordered, labels = levels(as.factor(v3)))

          #v2 = factor(v2.ordered, labels = levelNames)



          v3 = v2
          pcols = pcols.ordered


      }else
          pcols = e$basicDotColor

      pcols1 = pcols

     if(sliderValue == 0){


        n3 = length(gpVarLbls)
        if(n3 == 1)
          par(mfrow =c(1,1), bg = e$basicBackgroundDot)
        else if(n3%%2 == 0)
          par(mfrow = c(n3/2, 2), bg = e$basicBackgroundDot)
        else if(n3%%2 != 0)
          par(mfrow = c((n3/2)+ 0.5, 2), bg = e$basicBackgroundDot)

        for(i in 1:n3){
          levs3 = gpVarLbls[i]

          if(!is.null(e$fifthVariable))
            pcols1 = pcols[v3==levs3]

          boxpoints2(v1[v3==levs3],factor(v3[v3==levs3]),vn1,vn2,
            labeltext=ifelse(is.null(e$fourthVariable), paste("for", vn3, "=", levs3), paste("for", vn3, "=", levs3, " & ", e$fourthVarName, "=", (levels(e$fourthVariable)[e$sliderData2]))),
            xlims=xlims,prettyx=pretty(v1[v3==levs3]),
            boxfill=NA,ptcol=pcols1,
            errorbarcol=ifelse(year12,BoxBarCol,NA))

         }

      }else{
          levs3 = gpVarLbls[sliderValue]

          if(!is.null(e$fifthVariable))
            pcols1 = pcols[v3==levs3]

          boxpoints2(v1[v3==levs3],factor(v3[v3==levs3]),vn1,vn2,
            labeltext=ifelse(is.null(e$fourthVariable), paste("for", vn3, "=", levs3), paste("for", vn3, "=", levs3, " & ", e$fourthVarName, "=", (levels(e$fourthVariable)[e$sliderData2]))),
            xlims=xlims,prettyx=pretty(v1[v3==levs3]),
            boxfill=NA,ptcol=pcols1,
            errorbarcol=ifelse(year12,BoxBarCol,NA))

        }
      if(!is.null(e$fifthVariable)){
        if(!is.null(e$fifthVariableNumeric))
            image.plot(legend.only=TRUE, legend.shrink = 0.5, legend.width = 1.2, legend.mar = 2.3, zlim = c(min(fifthVarNumeric),max(fifthVarNumeric)), nlevels = length(levels(factor(fifthVarNumeric))), col=cols, main=e$fifthVarName, legend.args=list(text = e$fifthVarName, cex = 1, line = 1), add = TRUE, horizontal = FALSE) # legend.lab = e$fifthVarName
        else
            legend("right",substr(levels(e$fifthVariableSubset),1,15),bg = "transparent",pch=1,col=cols,title=e$fifthVarName,pt.cex=1,cex=1,pt.lwd=2)
      }

    }

}


#

 removeAll_ForNewData = function(){ e$addSmoother = FALSE; e$addYequalsX = FALSE;
                          e$addLinearTrend = FALSE; e$addQuadTrend = FALSE; e$addCubicTrend = FALSE;
                          e$fifthVariable = NULL; e$fifthVariableSubset = NULL; e$fifthVarName = "";
                          e$sixthVariable = NULL; e$sixthVariableSubset = NULL; e$sixthVarName = "";
                          e$segmentVariable = NULL; e$segmentVariableSubset = NULL; e$segmentVarName = "";
                          e$addRugY = FALSE; e$addRugX = FALSE; e$addRugYhat = FALSE;
                          e$addJitterX = FALSE; e$addJitterY = FALSE;
                          e$drawBoxPlots = TRUE; e$drawBothInf = FALSE; e$drawIntervals = FALSE; e$useBootstrap = FALSE;
                          e$basicScatterColor = "black"; e$basicDotColor = "grey50"
                          e$basicPlottingCharScatter = 1; e$basicPlottingCharDot = 1
                          e$scatterThickness1 = 1; e$scatterThickness2 = 2
                          e$basicCexScatter = 1; e$basicCexDot = 1
                          e$basicBackgroundDot = "white"; e$basicBackgroundScatter = "white"
                          e$drawBootLines = FALSE
                          e$joinByLines = FALSE
                          #updatePlot()
                        }

specifyFileForImport = function(...) {
  e1 = new.env()
  importFileWin = gwindow("File Browser", cont = TRUE, parent = e$win)
  fileMainGp = ggroup(cont = importFileWin, horizontal = FALSE)

  filetbl = glayout(cont = fileMainGp)

  l = list()
  l[[gettext("csv files")]] = c("csv")
  l[[gettext("2007 Excel files")]] = c("xlsx")
  l[[gettext("97-2003 Excel files")]] = c("xls")

  fileExtensions = l
  pop = function(x) x[-length(x)]
  popchar = function(str) paste(pop(unlist(strsplit(str,""))),collapse="")

  filterList = lapply(fileExtensions, function(i) list(patterns = paste("*.",i,sep="")))
  #filterList$"All files" = list(patterns=c("*"))

  ll = list()
  ll$"All files " = list(patterns=c("*"))
  filterList = c(ll,filterList)


  filetbl[2,2] = glabel("Local file")
  filetbl[2,3] <- (filebrowse = gfilebrowse(text="Specify a file",
                     action=invisible,
                     container=filetbl, filter=filterList, quote=FALSE))
  filetbl[3,2:3] <- gseparator(cont=filetbl)
  filetbl[4,2] = gettext("File type is")
  filetbl[4,3] <- (filetype = gdroplist(c("<use file extension to determine>",
      sapply(names(filterList[!filterList %in% ll]),popchar)), cont=filetbl))

  visible(filetbl) <- TRUE

  buttonGp = ggroup(cont = fileMainGp)
  addSpring(buttonGp)
  okButton = gbutton("OK", handler = function(h,...) okButtonHandler())
  cancelButton = gbutton("Cancel", handler = function(h,...)cancelButtonHandler())
  add(buttonGp, okButton)
  add(buttonGp, cancelButton)

  add(fileMainGp, glabel("Space for extra options : to define NA string, header presence etc."))




  cancelButtonHandler = function(h,...) dispose(importFileWin)
  okButtonHandler = function(h,...) {
    ## what to do? need *local* filename and type
    ## if url, but no file, then we download file name it, go
    ## if file then go to next

    theFile = svalue(filebrowse)
    ext = NULL ## the extension, figure out


    if(theFile == "Specify a file" || !file.exists(theFile)) {

    }else{
    ##  file is now theFile
    ## get extension type from droplist

    fileType = svalue(filetype)

    if(fileType != "<use file extension to determine>") {
      ## use filterList to get
      fileType = paste(fileType,"s", sep="", collapse="") ## append s back
      ext = fileExtensions[[fileType]][1]
      sprintf("Set extension to %s \n",ext)
    } else if(is.null(ext)) {
      tmp = unlist(strsplit(basename(theFile), split="\\."))
      ext = tmp[length(tmp)]
    }

    e1$importFile(theFile, ext)

  }

  }


    e1$importFile = function(theFile, ext){

      tmp = unlist(strsplit(basename(theFile), split="\\."))
      ext.tmp = tmp[length(tmp)]

      if(length(ext) == 0)
        gmessage(title = "Error", message = "Check file type", icon = "error", cont = TRUE, parent = importFileWin)
      else if(ext.tmp != ext)
        gmessage(title = "Error", message = "Chosen file is different than the selected file type", icon = "error", cont = TRUE, parent = importFileWin)
      else if(ext == "csv"){

        out = try(read.csv(theFile, header = TRUE, na.strings = c("NULL","NA","N/A","#N/A","","<NA>"), check.names = TRUE))
        if(inherits(out,"try-error")){
          sprintf("Error loading file: %s\n",out)
          enabled(okButton) = TRUE
          return(TRUE)
        }else{
          enabled(okButton) = FALSE
          out = data.frame(ROW_NAME = 1:nrow(out), out, check.names = TRUE)
          tag(e$obj,"dataSet") = out[,-1]
          tag(e$obj,"rowDataSet") = out
          tag(e$obj, "originalDataSet") = tag(e$obj,"dataSet")
          e$inDataView = TRUE
          enabled(e$dataView) = FALSE
          enabled(e$listView) = TRUE

          e$updateData()
          enabled(okButton) = TRUE
          removeAll_ForNewData()
          e$clearAllSlots()
          dispose(importFileWin)
        }
      }else if(ext == "xls" || ext == "xlsx"){

        channel <- try(odbcConnectExcel2007(theFile, readOnly = TRUE, readOnlyOptimize=TRUE))
        if(inherits(channel,"try-error")) {
          sprintf("Error loading file: %s\n",channel)
          enabled(okButton) = TRUE
          odbcCloseAll()
          return(TRUE)
        }else{

          enabled(okButton) = FALSE
          out <- try(sqlFetch(channel, sqtable = "Sheet1", na.strings = c("NULL","NA","N/A","#N/A","","<NA>"), as.is = TRUE)) #no na.omit()
          #out <- try(na.omit(sqlFetch(channel, sqtable = "Sheet1", na.strings = c("NULL","NA","N/A","#N/A","","<NA>"), as.is = TRUE))) # this was converted to a data frame before
          if(inherits(out,"try-error")){
            gmessage("Please ensure that the Excel worksheet containing the data is named as Sheet1\n\nIf the error persists, please save the dataset as a CSV (comma separated) file", parent = importFileWin)
            enabled(okButton) = TRUE
          }else{
            out = data.frame(ROW_NAME = 1:nrow(out), out)
            names(out) = make.names(names(out), unique=TRUE)  ##---------------------------------------September 9th

            for(i in 1:length(names(out))){
              x = as.numeric(out[,i])
              if(all(is.na(x))) out[,i] = factor(as.character(out[,i]))
              else out[,i] = x
            }

            tag(e$obj,"dataSet") =  out[,-1]
            tag(e$obj,"rowDataSet") = out
            tag(e$obj, "originalDataSet") = tag(e$obj,"dataSet")
            e$inDataView = TRUE
            enabled(e$dataView) = FALSE
            enabled(e$listView) = TRUE
            e$updateData()
            enabled(okButton) = TRUE
            removeAll_ForNewData()
            e$clearAllSlots()
            dispose(importFileWin)
            odbcCloseAll()
          }
        }
      }
    }
}

specifyFileForExport = function(){

    dataExportWin = gwindow("Export Data", cont = TRUE, parent = e$win, width = 200, height = 150)
    dataExportMain = ggroup(horizontal = FALSE, cont = dataExportWin, expand = TRUE)
    addSpace(dataExportMain, 5, horizontal = FALSE)
    dataExportLayout = glayout(cont = dataExportMain, expand = TRUE)

    lbl1 = glabel("Save As :")
    font(lbl1) <- list(weight="bold", family = "normal")
    lbl2 = glabel("File Type :")
    font(lbl2) <- list(weight="bold", family = "normal")
    nameBox = gtext("My Data", width = 100, heigh = 30)
    typeList = gdroplist(c("Comma delimited (.csv)","Tab delimited (.txt)", "Space separated (.txt)"), selected = 1)
    okButton = gbutton ("Write to File", handler = function(h,...){
      fileName = gsub("\\s+", "", svalue(nameBox), perl = TRUE)
      if(fileName == "") fileName = "My Data"

      if(svalue(typeList, index = TRUE) == 1)
        write.csv(tag(e$obj, "dataSet"), file = paste(fileName,".csv",sep = ""))
      else if(svalue(typeList, index = TRUE) == 2)
        write.table(tag(e$obj, "dataSet"),file=paste(fileName,".txt",sep = ""),sep="\t",row.names=F)
      else
        write.table(tag(e$obj, "dataSet"),file=paste(fileName,".txt",sep = ""),sep=" ",row.names=F)

      gmessage(paste("The file containing the data can be located at :", getwd()), parent= dataExportWin)
      dispose(dataExportWin)
    })
    dataExportLayout[1,2, anchor = c(0,0)] = lbl1
    dataExportLayout[1,4, anchor = c(0,0)] = nameBox
    dataExportLayout[3,2, anchor = c(0,0)] = lbl2
    dataExportLayout[3,4, anchor = c(0,0)] = typeList
    dataExportLayout[5,4, anchor = c(0,0)] = okButton
}

 removeAll_ForNewData = function(){ e$addSmoother = FALSE; e$addYequalsX = FALSE;
                          e$addLinearTrend = FALSE; e$addQuadTrend = FALSE; e$addCubicTrend = FALSE;
                          e$fifthVariable = NULL; e$fifthVariableSubset = NULL; e$fifthVarName = "";
                          e$sixthVariable = NULL; e$sixthVariableSubset = NULL; e$sixthVarName = "";
                          e$segmentVariable = NULL; e$segmentVariableSubset = NULL; e$segmentVarName = "";
                          e$addRugY = FALSE; e$addRugX = FALSE; e$addRugYhat = FALSE;
                          e$addJitterX = FALSE; e$addJitterY = FALSE;
                          e$drawBoxPlots = TRUE; e$drawBothInf = FALSE; e$drawIntervals = FALSE; e$useBootstrap = FALSE;
                          e$basicScatterColor = "black"; e$basicDotColor = "grey50"
                          e$basicPlottingCharScatter = 1; e$basicPlottingCharDot = 1
                          e$scatterThickness1 = 1; e$scatterThickness2 = 2
                          e$basicCexScatter = 1; e$basicCexDot = 1
                          e$basicBackgroundDot = "white"; e$basicBackgroundScatter = "white"
                          e$drawBootLines = FALSE
                          e$joinByLines = FALSE
                          #updatePlot()
                        }







  e$combineFactors = function(){
    e$combineWinOpened = TRUE

    e$combineWin = gwindow("Combine Categorical Variables", parent = e$win, width = 250, height = 400)
    addhandlerunrealize(e$combineWin, handler = function(h,...){e$combineWinOpened = FALSE; dispose(e$combineWin)})

    combineMain = ggroup(horizontal = FALSE, cont = e$combineWin, expand = TRUE)
    addSpace(combineMain, 5, horizontal = FALSE)
    lbl1 = glabel("Choose the variables you want to combine", cont = combineMain)
    font(lbl1) <- list(weight="bold", family = "normal")
    lbl2 = glabel("(Hold Ctrl to choose many)", cont = combineMain)
    font(lbl2) <- list(weight="bold", family = "normal")

    factorList = character(0)
    factorIndex = numeric(0)
    for(i in 1:length(names(tag(e$obj, "dataSet")))){
      if(is.factor(tag(e$obj, "dataSet")[,i])){
        factorList = c(factorList, names(tag(e$obj, "dataSet"))[i])
        factorIndex = c(factorIndex, i)
      }

    }

    #
    listOfFactors = gtable(factorList, multiple = TRUE, cont = combineMain, expand = TRUE)
    names(listOfFactors) = "Categorical Variables"
    lbl3 = glabel("New variable name", cont = combineMain)
    font(lbl3) <- list(weight="bold", family = "normal")
    nameBox = gtext("", cont = combineMain)

    combineFactorsButton = gbutton("- Proceed -", cont = combineMain, handler = function(h,...) {

                                      if(gsub(pattern = '\\n+', "", svalue(nameBox), perl = TRUE) %in% c("", " ", "  ", "    ", "\n"))
                                          gmessage(title = "ERROR", message = "Type in a name for the new variable", icon = "error", cont = TRUE, parent = e$combineWin)
                                      else{
                                        if(is.null(svalue(listOfFactors)))
                                          gmessage(title = "ERROR", message = "Choose two or more categorical variables", icon = "error", cont = TRUE, parent = e$combineWin)
                                        else if(length(svalue(listOfFactors))<2)
                                          gmessage(title = "ERROR", message = "Choose two or more categorical variables", icon = "error", cont = TRUE, parent = e$combineWin)
                                        else{
                                          chosenVars = svalue(listOfFactors)#which(svalue(listOfFactors) %in% names(tag(e$obj,"dataSet")))
                                          chosenVarIndices = which(names(tag(e$obj,"dataSet")) %in% chosenVars)

                                           x = data.frame(tag(e$obj, "dataSet"), newVar = interaction(tag(e$obj, "dataSet")[,chosenVarIndices]))
                                           names(x)[length(names(x))] = gsub(pattern = '\\n+', "", svalue(nameBox), perl = TRUE)
                                           tag(e$obj, "dataSet") = x
                                           gmessage(title = "INFO",
                                            message = paste("The new variable", gsub(pattern = '\\n+', "", svalue(nameBox), perl = TRUE),"will be inserted as the last column of the dataset")
                                            , icon = "info", cont = TRUE, parent = e$combineWin)
                                           if(e$inDataView)
                                              e$updateData()
                                           else
                                              e$updateList()

                                           e$combineWinOpened = FALSE
                                           dispose(e$combineWin)
                                        }
                                      }
                                    })

  }


e$reorderLevels = function(){

  e$reorderWinOpened = TRUE
  e$chosenVariableIndex = 0


  factorList = character(0)
  for(i in 1:length(names(tag(e$obj, "dataSet")))){
    if(is.factor(tag(e$obj, "dataSet")[,i]))
      factorList = c(factorList, names(tag(e$obj, "dataSet"))[i])

  }


  e$newVarName = gtext(" ", height = 30)
  reorderVarList = gdroplist(factorList,selected = 0, handler = function(h,...){ e$chosenVariableIndex = which(factorList[svalue(h$obj, index = TRUE)] == names(tag(e$obj, "dataSet")));svalue(e$newVarName) = paste(factorList[svalue(h$obj, index = TRUE)], "reordered", sep = ".")})
  proceedButton = gbutton("- Proceed -", handler = function(h,...){if(factorList[1] != "empty"){enabled(proceedButton) = FALSE; e$proceed()}})
  lbl1 = glabel("Variable to reorder :")
  font(lbl1) = list(weight = "bold", style = "normal")
  lbl2 = glabel("Name of new variable :")
  font(lbl2) = list(weight = "bold", style = "normal")

  reorderLayout1 = glayout()
  reorderLayout1[2,2] = lbl1
  reorderLayout1[2,3:6] = reorderVarList
  reorderLayout1[4,2] = lbl2
  reorderLayout1[4,3:6] = e$newVarName
  reorderLayout1[6,2:5] = proceedButton
  e$reorderWin = gwindow("Reorder Levels", cont = TRUE, parent = e$win, width = 210, height = 200)
  addhandlerunrealize(e$reorderWin, handler = function(h,...){e$reorderWinOpened = FALSE; dispose(e$reorderWin)})
  reorderMain = ggroup(cont = e$reorderWin)
  add(reorderMain, reorderLayout1)

  visible(reorderLayout1) = TRUE

 # reorder(trt, c("PLACEBO","300 MG", "600 MG", "1200 MG") )


}

e$proceed = function(){
  newName = ""
  textboxList =  list()
  levelN = levels((tag(e$obj, "dataSet"))[,e$chosenVariableIndex])
# check if the name given is correct
  if((svalue(e$newVarName) == "") || (svalue(e$newVarName) %in% names(tag(e$obj, "dataSet"))))
    newName = paste(factorList[svalue(h$obj, index = TRUE)], "reordered", sep = ".")
  else  newName = gsub('\\n+', "", svalue(e$newVarName), perl = TRUE)

  reorderLayout2 = glayout()
  lbl1 = glabel("Levels")
  font(lbl1) = list(weight = "bold", style = "normal")
  lbl2 = glabel("New Order")
  font(lbl2) = list(weight = "bold", style = "normal")
  reorderLayout2[2,2] = lbl1
  reorderLayout2[2,4] = lbl2

  for(i in 1:length(levelN)){
    eval(parse(text=paste(c("textboxList$","lbl",i, "= gtext(\"",i,"\"",",width = 30, height = 20)"), collapse="")))
    reorderLayout2[i+3,2] = glabel(as.character(levelN[i]))
    reorderLayout2[i+3,4] = eval(parse(text = paste(c("textboxList$","lbl",i), collapse="")))
  }

  finalButton = gbutton("- REORDER -", handler = function(h,...){
                                                levelOrder = character(0)
                                                for(i in 1:length(levelN))
                                                  levelOrder = c(levelOrder, gsub(pattern = '\\n+', replacement = "", x = svalue(textboxList[[i]]), perl = TRUE))



                                                if((any(is.na(as.numeric(levelOrder)))) || any(as.numeric(levelOrder) < 1) || any(as.numeric(levelOrder) > length(levelN)) || !all(1:length(levelN) %in% as.numeric(levelOrder)) )
                                                  gmessage(title = "ERROR", message = paste("Each box needs to contain one number between 1 -", length(levelN),"\n(Check for duplicate indices)"), icon = "error", cont = TRUE, parent = e$win)
                                                else{
                                                  #x = data.frame(tag(e$obj, "dataSet"), newVar = reorder((tag(e$obj, "dataSet"))[,e$chosenVariableIndex],new.order = levelN[as.numeric(levelOrder)])) ------- Changed Oct 14th

                                                  x = data.frame(tag(e$obj, "dataSet"), newVar = factor((tag(e$obj, "dataSet"))[,e$chosenVariableIndex], levels = levels(reorder(levelN,as.numeric(levelOrder)))))
                                                  names(x)[length(names(x))] = newName
                                                  tag(e$obj, "dataSet") = x
                                                  gmessage(title = "INFO",
                                                    message = paste("The new variable", newName,"will be inserted as the last column of the dataset")
                                                    , icon = "info", cont = TRUE, parent = e$win)
                                                  if(e$inDataView)
                                                    e$updateData()
                                                  else
                                                    e$updateList()

                                                  dispose(reorderWin2)
                                                }
                                             })
  reorderLayout2[length(levelN)+4,2:4] = finalButton

  dispose(e$reorderWin)
  e$reorderWinOpened = TRUE
  reorderWin2 = gwindow("Reorder Levels", cont = TRUE, parent = e$win, width = 200, height = 200)
  addhandlerunrealize(reorderWin2, handler = function(h,...){e$reorderWinOpened = FALSE; dispose(reorderWin2)})
  reorderWinMain2 = ggroup(horizontal = FALSE, cont = reorderWin2)

  visible(reorderLayout2) = TRUE
  add(reorderWinMain2, reorderLayout2)

  e$reorderWinOpened = FALSE

}



e$getOriginalData = function(){

  tag(e$obj, "dataSet") =  tag(e$obj, "originalDataSet")
  tag(e$obj,"rowDataSet") = data.frame(ROW_NAME = 1:nrow(tag(e$obj, "originalDataSet")), tag(e$obj, "dataSet"))

  removeAll_ForNewData()
  e$clearAllSlots()
  if(e$inDataView)
    e$updateData()
  else
    e$updateList()
}

e$filterData = function(){

  #e$filterDataWinOpened = TRUE

  e$filterDataWin = gwindow("Filter Data", cont = TRUE, width = 250, height = 200, parent = e$win)
  addhandlerunrealize(e$filterDataWin, handler = function(h,...){e$filterDataWinWinOpened = FALSE; dispose(e$filterDataWin)})
  filterDataMain = ggroup(cont = e$filterDataWin, horizontal = FALSE)
  filterDataSecondary = ggroup(cont = filterDataMain, horizontal = FALSE)
  filterDataTertiary= ggroup(cont = filterDataMain, horizontal = TRUE)
  lbl1 = glabel("Filter data by :")
  font(lbl1) = list(weight = "bold", style = "normal")

  e$filterList = gradio(c("levels of a categorical variable", "numeric condition", "row number"), horizontal = FALSE, selected = 1)
  filterOptionsButton = gbutton("- Proceed -", handler = function(h,...)e$filterOptions())
  addSpace(filterDataSecondary, 5)
  add(filterDataSecondary, lbl1)
  add(filterDataSecondary, e$filterList)
  addSpring(filterDataTertiary)
  add(filterDataTertiary, filterOptionsButton)
}

e$filterOptions = function(){

  if(svalue(e$filterList, index = TRUE) == 1){

    dispose(e$filterDataWin)
    #e$filterDataWinOpened = TRUE

    filterDataWin = gwindow("Filter Data", cont = TRUE, width = 250, height = 350, parent = e$win)
    addhandlerunrealize(filterDataWin, handler = function(h,...){e$filterDataWinWinOpened = FALSE; dispose(filterDataWin)})
    filterDataMain = ggroup(cont = filterDataWin, horizontal = FALSE, expand = TRUE)
    filterDataSecondary = ggroup(cont = filterDataMain, horizontal = FALSE, expand = TRUE)
    filterDataTertiary= ggroup(cont = filterDataMain)
    filterDataLayout = glayout()



    lbl1 = glabel("Filter data by :")
    font(lbl1) = list(weight = "bold", style = "normal")
    lbl2 = glabel("Select levels to include")
    font(lbl2) = list(weight = "bold", style = "normal")
    lbl3 = glabel("(Hold Ctrl to choose many)")


    factorList = character(0)
    factorIndex = numeric(0)
    for(i in 1:length(names(tag(e$obj, "dataSet")))){
      if(is.factor(tag(e$obj, "dataSet")[,i])){
        factorList = c(factorList, names(tag(e$obj, "dataSet"))[i])
        factorIndex = c(factorIndex, i)
      }
    }

    listOfLevels = gtable(" ", multiple = TRUE, )
    names(listOfLevels) = "Levels"

    factorListMenu = gdroplist(factorList, selected = 0, handler = function(h,...) listOfLevels[] = levels(tag(e$obj, "dataSet")[,svalue(factorListMenu)]))

    filterDataLayout[1,2] = lbl1
    filterDataLayout[1,4] = factorListMenu
    filterDataLayout[2,2] = lbl2
    filterDataLayout[3,2] = lbl3
    #filterDataLayout[4:7,2:4, expand = TRUE] = listOfFactors
    visible(filterDataLayout) = TRUE

    filterDataButton = gbutton("-Filter Data-", handler = function(h,...){

                                                          if(length(svalue(factorListMenu, index = TRUE)) != 0){

                                                            x = tag(e$obj, "dataSet")
                                                            chosenLevels = which((levels(x[,svalue(factorListMenu)])) %in% svalue(listOfLevels))

                                                            #print(x[,svalue(factorListMenu)])
                                                            y = x[x[,svalue(factorListMenu)] %in% (levels(x[,svalue(factorListMenu)]))[chosenLevels],]
                                                            tag(e$obj,"rowDataSet") = tag(e$obj,"rowDataSet")[x[,svalue(factorListMenu)] %in% (levels(x[,svalue(factorListMenu)]))[chosenLevels],]
                                                            y[,svalue(factorListMenu)] = factor(y[,svalue(factorListMenu)], levels = svalue(listOfLevels))
                                                            tag(e$obj, "dataSet") = y

                                                            enabled(e$dataView) = FALSE
                                                            e$updateData()
                                                            enabled(e$listView) = TRUE

                                                            removeAll_ForNewData()
                                                            e$clearAllSlots()
                                                            e$filterDataWinWinOpened = FALSE
                                                            # print(e$filterDataWinOpened);
                                                            dispose(filterDataWin)
                                                          }else gmessage(title = "ERROR", message = " ------ ", icon = "error", cont = TRUE, parent = filterDataWin)


                                                          })

    add(filterDataSecondary, filterDataLayout)
    add(filterDataSecondary, listOfLevels, expand = TRUE)
    addSpring(filterDataTertiary)
    add(filterDataTertiary, filterDataButton)
  }else if(svalue(e$filterList, index = TRUE) == 2){

    dispose(e$filterDataWin)
    #e$filterDataWinOpened = TRUE

    lessthan = gbutton("  <  ", handler = function(h,...) addToExpression("<"))
    lessthan_equal = gbutton(" <= ", handler = function(h,...) addToExpression("<="))
    greaterthan = gbutton("  >  ", handler = function(h,...) addToExpression(">"))
    greaterthan_equal = gbutton(" >= ", handler = function(h,...) addToExpression(">="))
    equal = gbutton(" == ", handler = function(h,...) addToExpression("=="))
    notequal = gbutton(" != ", handler = function(h,...) addToExpression("!="))


    filterDataWin = gwindow("Filter Data", cont = TRUE, width = 250, height = 350, parent = e$win)
    addhandlerunrealize(filterDataWin, handler = function(h,...){e$filterDataWinWinOpened = FALSE; dispose(filterDataWin)})
    filterDataMain = ggroup(cont = filterDataWin, horizontal = FALSE, expand = TRUE)
    filterDataPrimary = ggroup(cont = filterDataMain, horizontal = FALSE)
    #filterDataSecondary = ggroup(cont = filterDataMain, horizontal = TRUE)
    #filterDataTertiary= ggroup(cont = filterDataMain)
    filterDataLayout1 = glayout(cont = filterDataMain)
    filterDataLayout2 = glayout(cont = filterDataMain)
    numericVariableList = character(0)

    for(i in 1:length(names(tag(e$obj, "dataSet")))){
      if(!is.factor(tag(e$obj, "dataSet")[,i]))
        numericVariableList = c(numericVariableList, names(tag(e$obj, "dataSet"))[i])
    }
    variableList = gdroplist(numericVariableList, selected = 0, editable = TRUE)

    lbl1 = glabel("Type in your subsetting expression", cont = filterDataPrimary)
    font(lbl1) = list(weight = "bold", style = "normal")
    addSpace(filterDataPrimary, 5)
    lbl2 = glabel("eg: X >= 20", cont = filterDataPrimary)
    #font(lbl2) = list(weight = "bold", style = "normal")
    lbl3 = glabel("eg: X == 20", cont = filterDataPrimary)
    addSpace(filterDataPrimary, 5)
    lbl4 = glabel("Choose observations in the dataset where :", cont = filterDataPrimary)
    font(lbl4) = list(weight = "bold", style = "normal")

    expressionBox = gtext(" ", width = 80, height = 25)

    e$subsetExpression = character(0)
    submitButton = gbutton("Submit", handler = function(h,...){
      enabled(h$obj) = FALSE
      subsetExpression = paste(svalue(variableList), gsub(pattern = '\\n+', "", svalue(expressionBox), perl = TRUE))
      subsetData = try(subset(tag(e$obj, "dataSet"), eval(parse(text = eval(subsetExpression)))))
      if(class(subsetData)[1] == "try-error"){
        gmessage(title = "ERROR", message = "Error in expression!", icon = "error", parent = filterDataWin)
        enabled(h$obj) = TRUE
      }else{
        tag(e$obj,"rowDataSet") = subset(tag(e$obj,"rowDataSet"), eval(parse(text = eval(subsetExpression))))
        tag(e$obj, "dataSet") = subsetData
        enabled(e$dataView) = FALSE
        e$updateData()
        enabled(e$listView) = TRUE
        e$filterDataWinWinOpened = FALSE
        removeAll_ForNewData()
        e$clearAllSlots()
        enabled(h$obj) = TRUE
        dispose(filterDataWin)
      }
    })


    filterDataLayout1[1,1, anchor = c(-1,0)] = variableList
    filterDataLayout1[1,2,anchor = c(-1,0), expand = TRUE] = expressionBox

    filterDataLayout2[1,1] = equal
    filterDataLayout2[1,2] = notequal
    filterDataLayout2[1,3] = greaterthan
    filterDataLayout2[1,4] = greaterthan_equal
    filterDataLayout2[1,5] = lessthan
    filterDataLayout2[1,6] = lessthan_equal

    filterDataLayout2[4,5:6] = submitButton



    addToExpression = function(newAddition){
      if(svalue(expressionBox) %in% c(""," ")){
      #if(gsub("\\s+", "", svalue(expressionBox), perl = TRUE) %in% c("", " ")){
        e$subsetExpression = strsplit(svalue(expressionBox), " ")[[1]]
        e$subsetExpression = c(e$subsetExpression, newAddition)
        svalue(expressionBox) = paste(e$subsetExpression, collapse = " ")

      }else svalue(expressionBox) = newAddition
    }

  }else if(svalue(e$filterList, index = TRUE) == 3){

    dispose(e$filterDataWin)
    filterDataWin = gwindow("Filter Data", cont = TRUE, width = 250, height = 280, parent = e$win)
    addhandlerunrealize(filterDataWin, handler = function(h,...){e$filterDataWinWinOpened = FALSE; dispose(filterDataWin)})
    filterDataMain = ggroup(cont = filterDataWin, horizontal = FALSE, expand = TRUE)
    #filterDataSecondary= ggroup(cont = filterDataMain, horizontal = FALSE)

    lbl1 = glabel("Type in the Row.names of observations", cont = filterDataMain)
    font(lbl1) = list(weight = "bold", style = "normal")
    lbl2 = glabel("that need to be excluded", cont = filterDataMain)
    font(lbl2) = list(weight = "bold", style = "normal")
    addSpace(filterDataMain, 4)
    lbl3 = glabel("(separate each value by a comma)", cont = filterDataMain)
    font(lbl2) = list(weight = "bold", style = "normal")

    addSpace(filterDataMain, 7)

    lbl2 = glabel("EXAMPLE", cont = filterDataMain)
    font(lbl2) = list(weight = "bold", style = "normal")
    lbl3 = glabel("1,5,99,45,3", cont = filterDataMain)

    addSpace(filterDataMain, 5)
    unwantedObs = gtext("   ", cont = filterDataMain, width = 200, height = 20)


    addSpring(filterDataMain)
    submitButton = gbutton("- Proceed -", handler = function(h,...){

    rowNumbers =   try(as.numeric(strsplit(gsub(pattern = '\\s+', replacement = "", svalue(unwantedObs), perl = TRUE), ",", fixed = TRUE)[[1]] ))

    if(inherits(rowNumbers,"try-error") || is.na(rowNumbers)){
      gmessage(title = "ERROR", message = "Error in typed values.\nCheck for missing commas or non-existing Row.names", icon = "error", parent = filterDataWin)

    }else{
      d = tag(e$obj,"rowDataSet")   #tag(e$obj, "dataSet")

      if(!all(rowNumbers %in% d$ROW_NAME))
        gmessage(title = "ERROR", message = "You have entered one or more non-existing Row.names", icon = "error", parent = filterDataWin)
      else{
        enabled(h$obj) = FALSE
        tag(e$obj,"rowDataSet") = tag(e$obj,"rowDataSet")[!(d$ROW_NAME %in% c(rowNumbers)),]
        tag(e$obj, "dataSet") = tag(e$obj,"rowDataSet")[,-1]
        enabled(e$dataView) = FALSE
        e$updateData()
        enabled(e$listView) = TRUE
        removeAll_ForNewData()
        e$clearAllSlots()
        e$filterDataWinWinOpened = FALSE
        enabled(h$obj) = TRUE
        dispose(filterDataWin)
      }
    }


    }, cont = filterDataMain)
    #add(filterDataMain, submitButton)
    #filterDataSecondary= ggroup(cont = filterDataMain, horizontal = FALSE)
#    addSpring(filter


  }
}


e$binNumeric = function(){
  if(!e$binNumericWinOpened){
  numericList = character(0)
  numericIndex = numeric(0)
  for(i in 1:length(names(tag(e$obj, "dataSet")))){
    if(!is.factor(tag(e$obj, "dataSet")[,i])){
        numericList = c(numericList, names(tag(e$obj, "dataSet"))[i])
        numericIndex = c(numericIndex, i)
    }
  }

    lbl1 = glabel("Choose variable :")
    font(lbl1) = list(weight = "bold", style = "normal")
    lbl2 = glabel("New variable    :")
    font(lbl2) = list(weight = "bold", style = "normal")
    lbl3 = glabel("New level names :")
    font(lbl3) = list(weight = "bold", style = "normal")
    lbl4 = glabel("Method :")
    font(lbl4) = list(weight = "bold", style = "normal")
    lbl5 = glabel("Number of intervals :")
    font(lbl5) = list(weight = "bold", style = "normal")

    newVarName = gtext(" ", height = 20, width = 30)
    NumericListMenu = gdroplist(numericList, selected = 0, handler = function(h,...) svalue(newVarName) = paste(svalue(h$obj),"f", sep = "."))
    binSlider = gslider(from = 2, to = 20, by = 1)
    levelNameChoices = gradio(c("Ranges", "Specify names", "Numbers"), horizontal = FALSE, selected = 1)
    binningChoices = gradio(c("Equal width intervals", "Equal count intervals", "Specified intervals"), horizontal = FALSE, selected = 1)


  e$binNumericWinOpened = TRUE
  binNumericWin = gwindow("Form Class Intervals", width = 250, height = 300, parent = e$win)
  addhandlerunrealize(binNumericWin, handler = function(h,...){e$binNumericWinOpened = FALSE; binNow = FALSE; dispose(h$obj)})
  binNumericMain = ggroup(horizontal = FALSE, cont = binNumericWin)
  binNumericLayout = glayout()
  binNumericLayout[2,2] = lbl1
  binNumericLayout[2,4] = NumericListMenu
  binNumericLayout[3,2] = lbl2
  binNumericLayout[3,4, expand = TRUE] = newVarName
  binNumericLayout[4,2] = lbl5
  binNumericLayout[5,2:4] = binSlider
  binNumericLayout[6,2] = lbl3
  binNumericLayout[6,4] = lbl4
  binNumericLayout[7,2] = levelNameChoices
  binNumericLayout[7, 4] = binningChoices
  binNumericLayout[9, 4] = gbutton("- Proceed -", handler = function(h,...){

    if(gsub(pattern = '\\n+', "", svalue(newVarName), perl = TRUE) %in% c("", " ")) gmessage(title = "ERROR", message = "Provide a valid name for the new variable", icon = "error", parent = binNumericWin)
    else{
      binNow = FALSE
      e$levelLabels = NULL
		  if (svalue(levelNameChoices) == "Numbers"){

          e$levelLabels = FALSE
          values = tag(e$obj, "dataSet")[,svalue(NumericListMenu)]
          bins = svalue(binSlider)

          if(svalue(binningChoices) == "Equal width intervals"){ x = cut(values, bins, labels = e$levelLabels); binNow = TRUE}
      		else if(svalue(binningChoices) == "Equal count intervals"){ x = cut(values, quantile(values, probs=seq(0,1,1/bins), na.rm=TRUE),
      				include.lowest = TRUE, labels=e$levelLabels); binNow = TRUE}
      		else if(svalue(binningChoices) == "Specified intervals"){

              textboxList =  list()
              breaksNeeded = svalue(binSlider) - 1

              newBreaks = glayout()

              breaksWin = gwindow("User Intervals", cont = TRUE, parent = binNumericWin, width = 150, height = 200)
              #addhandlerunrealize(levelNamesWin, handler = function(h,...){dispose(levelNamesWin)})
              breaksMain = ggroup(horizontal = FALSE, cont = breaksWin)

              lbl1 = glabel(paste("Specified", svalue(binSlider), "intervals.\nNeed", breaksNeeded, "break points"), cont = breaksMain)
              font(lbl1) = list(weight = "bold", style = "normal")

              newBreaks[1,2] = glabel(as.character(min(values, na.rm = TRUE)))

              for(i in 1:breaksNeeded){                                                     #,",width = 60, height = 20 )"
                eval(parse(text=paste(c("textboxList$","lbl",i, "= gtext(\"","\"",",width = 80, height = 20)"), collapse="")))
                newBreaks[i+1,2] = eval(parse(text = paste(c("textboxList$","lbl",i), collapse="")))
              }

              newBreaks[breaksNeeded+2,2] = glabel(as.character(max(values, na.rm = TRUE)))

              visible(newBreaks) = TRUE
              add(breaksMain, newBreaks)

              finalButton = gbutton("Submit Breaks", handler = function(h,...){

                  cutOffPoints = numeric(0)
                  for(i in 1:breaksNeeded)
                    cutOffPoints= c(cutOffPoints, gsub(pattern = '\\n+', replacement = "", x = svalue(textboxList[[i]]), perl = TRUE))

                  cutOffPoints = c(min(values, na.rm = TRUE), gsub(pattern = '\\s+', replacement = "", x = cutOffPoints, perl = TRUE), max(values, na.rm = TRUE))

                    if(any(cutOffPoints %in% c("", " ", "", "   ", "\n", "\n\n")))
                      gmessage(title = "ERROR", message = "Fill in all text boxes", icon = "error", cont = TRUE, parent = breaksWin)
                    else if(length(unique(cutOffPoints[c(-1,-length(cutOffPoints))])) != length(cutOffPoints)-2)
                      gmessage(title = "ERROR", message = "Breaks must be unique values.", icon = "error", cont = TRUE, parent = breaksWin)
                    else{

                  	   x = as.factor(x = cut(values, cutOffPoints, labels = e$levelLabels))

                       newName = gsub(pattern = '\\n+', "", svalue(newVarName), perl = TRUE)
                       oldNames = names(tag(e$obj, "dataSet"))
                       d = data.frame(tag(e$obj, "dataSet"), x)
                       names(d) = make.names(c(oldNames, newName), unique = TRUE)
                       tag(e$obj, "dataSet") = d

                       gmessage(title = "INFO",
                        message = paste("The new variable", newName,"will be inserted as the last column of the dataset")
                        , icon = "info", cont = TRUE, parent = breaksWin)
                       if(e$inDataView)
                        e$updateData()
                       else
                        e$updateList()

                       dispose(breaksWin)
                       dispose(binNumericWin)

                    }




              })
              add(breaksMain, finalButton)



      		}

        if(binNow){
      	   x = as.factor(x)
           newName = gsub(pattern = '\\n+', "", svalue(newVarName), perl = TRUE)
           oldNames = names(tag(e$obj, "dataSet"))
           d = data.frame(tag(e$obj, "dataSet"), x)
           names(d) = make.names(c(oldNames, newName), unique = TRUE)
           tag(e$obj, "dataSet") = d

           gmessage(title = "INFO",
            message = paste("The new variable", newName,"will be inserted as the last column of the dataset")
            , icon = "info", cont = TRUE, parent = binNumericWin)

           if(e$inDataView)
            e$updateData()
           else
            e$updateList()
           dispose(binNumericWin)
        }

      }else if (svalue(levelNameChoices) == "Ranges"){

          e$levelLabels = NULL
          values = tag(e$obj, "dataSet")[,svalue(NumericListMenu)]
          bins = svalue(binSlider)

          if(svalue(binningChoices) == "Equal width intervals"){x = cut(values, bins, labels = e$levelLabels); binNow = TRUE}
      		else if (svalue(binningChoices) == "Equal count intervals"){ x = cut(values, quantile(values, probs=seq(0,1,1/bins), na.rm=TRUE),
      				include.lowest = TRUE, labels=e$levelLabels); binNow = TRUE}

      		else if(svalue(binningChoices) == "Specified intervals"){

              textboxList =  list()
              breaksNeeded = svalue(binSlider) - 1

              newBreaks = glayout()

              breaksWin = gwindow("User Intervals", cont = TRUE, parent = binNumericWin, width = 150, height = 200)
              #addhandlerunrealize(levelNamesWin, handler = function(h,...){dispose(levelNamesWin)})
              breaksMain = ggroup(horizontal = FALSE, cont = breaksWin)

              lbl1 = glabel(paste("Specified", svalue(binSlider), "intervals.\nNeed", breaksNeeded, "break points"), cont = breaksMain)
              font(lbl1) = list(weight = "bold", style = "normal")

              newBreaks[1,2] = glabel(as.character(min(values, na.rm = TRUE)))

              for(i in 1:breaksNeeded){                                                     #,",width = 60, height = 20 )"
                eval(parse(text=paste(c("textboxList$","lbl",i, "= gtext(\"","\"",",width = 80, height = 20)"), collapse="")))
                newBreaks[i+1,2] = eval(parse(text = paste(c("textboxList$","lbl",i), collapse="")))
              }

              newBreaks[breaksNeeded+2,2] = glabel(as.character(max(values, na.rm = TRUE)))

              visible(newBreaks) = TRUE
              add(breaksMain, newBreaks)

              finalButton = gbutton("Submit Breaks", handler = function(h,...){

                  cutOffPoints = numeric(0)
                  for(i in 1:breaksNeeded)
                    cutOffPoints= c(cutOffPoints, gsub(pattern = '\\n+', replacement = "", x = svalue(textboxList[[i]]), perl = TRUE))

                  cutOffPoints = c(min(values, na.rm = TRUE), gsub(pattern = '\\s+', replacement = "", x = cutOffPoints, perl = TRUE), max(values, na.rm = TRUE))

                    if(any(cutOffPoints %in% c("", " ", "", "   ", "\n", "\n\n")))
                      gmessage(title = "ERROR", message = "Fill in all text boxes", icon = "error", cont = TRUE, parent = breaksWin)
                    else if(length(unique(cutOffPoints[c(-1,-length(cutOffPoints))])) != length(cutOffPoints)-2)
                      gmessage(title = "ERROR", message = "Breaks must be unique values.", icon = "error", cont = TRUE, parent = breaksWin)
                    else{

                  	   x = as.factor(x = cut(values, cutOffPoints, labels = e$levelLabels))

                       newName = gsub(pattern = '\\n+', "", svalue(newVarName), perl = TRUE)
                       oldNames = names(tag(e$obj, "dataSet"))
                       d = data.frame(tag(e$obj, "dataSet"), x)
                       names(d) = make.names(c(oldNames, newName), unique = TRUE)
                       tag(e$obj, "dataSet") = d

                       gmessage(title = "INFO",
                        message = paste("The new variable", newName,"will be inserted as the last column of the dataset")
                        , icon = "info", cont = TRUE, parent = breaksWin)

                       if(e$inDataView)
                        e$updateData()
                       else
                        e$updateList()

                       dispose(breaksWin)
                       dispose(binNumericWin)

                    }




              })
              add(breaksMain, finalButton)



      		}



          if(binNow){
      	   x = as.factor(x)

           newName = gsub(pattern = '\\n+', "", svalue(newVarName), perl = TRUE)
           oldNames = names(tag(e$obj, "dataSet"))
           d = data.frame(tag(e$obj, "dataSet"), x)
           names(d) = make.names(c(oldNames, newName), unique = TRUE)
           tag(e$obj, "dataSet") = d

           gmessage(title = "INFO",
            message = paste("The new variable", newName,"will be inserted as the last column of the dataset")
            , icon = "info", cont = TRUE, parent = binNumericWin)

           if(e$inDataView)
            e$updateData()
           else
            e$updateList()

           #e$newVariableWinOpened = FALSE
           dispose(binNumericWin)
         }
      }else{

        textboxList =  list()
        levelN = svalue(binSlider)

        newLevels = glayout()

        levelNamesWin = gwindow("Level Names", cont = TRUE, parent = binNumericWin, width = 150, height = 200)
        #addhandlerunrealize(levelNamesWin, handler = function(h,...){dispose(levelNamesWin)})
        levelNamesMain = ggroup(horizontal = FALSE, cont = levelNamesWin)

        lbl1 = glabel(paste(levelN, "intervals. Need", levelN, "level names"), cont = levelNamesMain)
        font(lbl1) = list(weight = "bold", style = "normal")


        for(i in 1:levelN){                                                     #,",width = 60, height = 20 )"
          eval(parse(text=paste(c("textboxList$","lbl",i, "= gtext(\"",i,"\"",",width = 80, height = 20)"), collapse="")))
          newLevels[i+1,2] = eval(parse(text = paste(c("textboxList$","lbl",i), collapse="")))
        }


        visible(newLevels) = TRUE
        add(levelNamesMain, newLevels)

        finalButton = gbutton("Submit Levels", handler = function(h,...){
            levelLabels = character(0)
            for(i in 1:levelN)
              levelLabels = c(levelLabels, gsub(pattern = '\\n+', replacement = "", x = svalue(textboxList[[i]]), perl = TRUE))

            levelLabels = gsub(pattern = '\\s+', replacement = "", x = levelLabels, perl = TRUE)

              if(any(levelLabels %in% c("", " ", "", "   ", "\n", "\n\n")))
                gmessage(title = "ERROR", message = "Fill in all text boxes", icon = "error", cont = TRUE, parent = levelNamesWin)
              else if(length(unique(levelLabels)) != length(levelLabels))
                gmessage(title = "ERROR", message = "Level names must be unique.", icon = "error", cont = TRUE, parent = levelNamesWin)
              else{

                e$levelLabels = levelLabels
                values = tag(e$obj, "dataSet")[,svalue(NumericListMenu)]
                bins = svalue(binSlider)

                if(svalue(binningChoices) == "Equal width intervals"){ x = cut(values, bins, labels = e$levelLabels); binNow = TRUE}
            		else if (svalue(binningChoices) == "Equal count intervals"){ x = cut(values, quantile(values, probs=seq(0,1,1/bins), na.rm=TRUE),
            				include.lowest = TRUE, labels=e$levelLabels); binNow = TRUE}
            		else if(svalue(binningChoices) == "Specified intervals"){

                    textboxList =  list()
                    breaksNeeded = svalue(binSlider) - 1

                    newBreaks = glayout()

                    breaksWin = gwindow("User Intervals", cont = TRUE, parent = binNumericWin, width = 150, height = 200)
                    #addhandlerunrealize(levelNamesWin, handler = function(h,...){dispose(levelNamesWin)})
                    breaksMain = ggroup(horizontal = FALSE, cont = breaksWin)

                    lbl1 = glabel(paste("Specified", svalue(binSlider), "intervals.\nNeed", breaksNeeded, "break points"), cont = breaksMain)
                    font(lbl1) = list(weight = "bold", style = "normal")

                    newBreaks[1,2] = glabel(as.character(min(values, na.rm = TRUE)))

                    for(i in 1:breaksNeeded){                                                     #,",width = 60, height = 20 )"
                      eval(parse(text=paste(c("textboxList$","lbl",i, "= gtext(\"","\"",",width = 80, height = 20)"), collapse="")))
                      newBreaks[i+1,2] = eval(parse(text = paste(c("textboxList$","lbl",i), collapse="")))
                    }

                    newBreaks[breaksNeeded+2,2] = glabel(as.character(max(values, na.rm = TRUE)))

                    visible(newBreaks) = TRUE
                    add(breaksMain, newBreaks)

                    finalButton = gbutton("Submit Breaks", handler = function(h,...){

                        cutOffPoints = numeric(0)
                        for(i in 1:breaksNeeded)
                          cutOffPoints= c(cutOffPoints, gsub(pattern = '\\n+', replacement = "", x = svalue(textboxList[[i]]), perl = TRUE))

                        cutOffPoints = c(min(values, na.rm = TRUE), gsub(pattern = '\\s+', replacement = "", x = cutOffPoints, perl = TRUE), max(values, na.rm = TRUE))

                          if(any(cutOffPoints %in% c("", " ", "", "   ", "\n", "\n\n")))
                            gmessage(title = "ERROR", message = "Fill in all text boxes", icon = "error", cont = TRUE, parent = breaksWin)
                          else if(length(unique(cutOffPoints[c(-1,-length(cutOffPoints))])) != length(cutOffPoints)-2)
                            gmessage(title = "ERROR", message = "Breaks must be unique values.", icon = "error", cont = TRUE, parent = breaksWin)
                          else{

                        	   x = as.factor(x = cut(values, cutOffPoints, labels = e$levelLabels)) #, include.lowest = TRUE


                             newName = gsub(pattern = '\\n+', "", svalue(newVarName), perl = TRUE)
                             oldNames = names(tag(e$obj, "dataSet"))
                             d = data.frame(tag(e$obj, "dataSet"), x)
                             names(d) = make.names(c(oldNames, newName), unique = TRUE)
                             tag(e$obj, "dataSet") = d


                             gmessage(title = "INFO",
                              message = paste("The new variable", newName,"will be inserted as the last column of the dataset")
                              , icon = "info", cont = TRUE, parent = breaksWin)

                             if(e$inDataView)
                              e$updateData()
                             else
                              e$updateList()

                             dispose(breaksWin)
                             dispose(binNumericWin)

                          }




                    })
                    add(breaksMain, finalButton)



      		}

                if(binNow){
              	   x = as.factor(x)

                   newName = gsub(pattern = '\\n+', "", svalue(newVarName), perl = TRUE)
                   oldNames = names(tag(e$obj, "dataSet"))
                   d = data.frame(tag(e$obj, "dataSet"), x)
                   names(d) = make.names(c(oldNames, newName), unique = TRUE)
                   tag(e$obj, "dataSet") = d

                   gmessage(title = "INFO",
                    message = paste("The new variable", newName,"will be inserted as the last column of the dataset")
                    , icon = "info", cont = TRUE, parent = binNumericWin)


                   if(e$inDataView)
                    e$updateData()
                   else
                    e$updateList()

                   #e$newVariableWinOpened = FALSE
                   dispose(binNumericWin)
                   dispose(levelNamesWin)
                }
              }
                                             })
         add(levelNamesMain, finalButton)

      }


    }
  })

  visible(binNumericLayout) = TRUE
  add(binNumericMain, binNumericLayout)

 }
}

e$standardVariable = function(){

  e$standardWinOpened = TRUE
  numericList = character(0)
  numericIndex = numeric(0)
  for(i in 1:length(names(tag(e$obj, "dataSet")))){
    if(!is.factor(tag(e$obj, "dataSet")[,i])){
        numericList = c(numericList, names(tag(e$obj, "dataSet"))[i])
        numericIndex = c(numericIndex, i)
    }
  }
    standardWin = gwindow("Standardise Variables", parent = e$win, width = 250, height = 400)
    addhandlerunrealize(standardWin, handler = function(h,...){e$standardWinOpened = FALSE; dispose(standardWin)})

    standardMain = ggroup(horizontal = FALSE, cont = standardWin, expand = TRUE)
    addSpace(standardMain, 5, horizontal = FALSE)
    lbl1 = glabel("Numeric Variables", cont = standardMain)
    font(lbl1) <- list(weight="bold", family = "normal")
    lbl2 = glabel("(Hold Ctrl to choose many)", cont = standardMain)
    font(lbl2) <- list(weight="bold", family = "normal")

    listOfNumeric = gtable(numericList, multiple = TRUE, cont = standardMain, expand = TRUE)
    names(listOfNumeric) = "Variables"

    addSpace(standardMain, 5, horizontal = FALSE)
    standardizeButton = gbutton("- Standardise -", cont = standardMain, handler = function(h,...) {

                                        if(is.null(svalue(listOfNumeric)))
                                          gmessage(title = "ERROR", message = "Choose at least one variable", icon = "error", cont = TRUE, parent = standardWin)
                                        else if(length(svalue(listOfNumeric)) == 0)
                                          gmessage(title = "ERROR", message = "Choose at least one variable", icon = "error", cont = TRUE, parent = standardWin)
                                        else{
                                          enabled(standardizeButton) = FALSE
                                          chosenVars = svalue(listOfNumeric)
                                          chosenVarIndices = which(names(tag(e$obj,"dataSet")) %in% chosenVars)

                                           x = tag(e$obj, "dataSet")

                                           #if(names(x) == "ROW_NAME"){
#                                            gmessage(title = "INFORMATION", message = "The ROW_NAME variable should not be standardized", icon = "info", cont = TRUE, parent = standardWin)
#                                           }else{
                                              for(i in 1:length(chosenVars)){
                                                #x[,chosenVarIndices[i]] = scale(x[,chosenVarIndices[i]], center = TRUE, scale = TRUE)
                                                index =  chosenVarIndices[i]
                                                newVar = scale(x[,index], center = TRUE, scale = TRUE)
                                                oldVarNames = names(tag(e$obj,"dataSet"))
                                                new.varName = paste(names(tag(e$obj,"dataSet"))[chosenVarIndices[i]], "std", sep = ".")




                                                if(index != length(names(x))){
                                                    x = data.frame(x[,1:index], newVar , x[,(index+1):(length(oldVarNames))])
                                                    names(x)[index] = oldVarNames[index]
                                                    names(x)[(index+1):(ncol(x))] = c(new.varName,(oldVarNames[(index+1):(length(oldVarNames))]))
                                                }else{
                                                    x = transform(x, new.var = newVar)
                                                    names(x)[length(x)] = new.varName
                                                }

                                              }
                                              ##x[,chosenVarIndices[i]] = round((x[,chosenVarIndices[i]]-mean(x[,chosenVarIndices[i]]))/ sqrt(var(x[,chosenVarIndices[i]])),2)
                                           #}
                                           tag(e$obj, "dataSet") = x

                                         gmessage(title = "INFO",
                                          message = paste("The new variables (with suffix .std) will be inserted next to their old non-standardised versions")
                                          , icon = "info", cont = TRUE, parent = standardWin)


                                           # Updating the data automatically because users should be able to see the change immedietly
                                           #if(e$inDataView)
                                           enabled(e$dataView) = FALSE
                                              e$updateData()
                                           enabled(e$listView) = TRUE
                                           #else
#                                              e$updateList()

                                           e$standardWinOpened = FALSE
                                           enabled(standardizeButton) = TRUE
                                           dispose(standardWin)
                                        }
                                      }
                                    )

}


# ------------------------------------------------------------------------------

  e$transformHandler = function(){

    e$transformWinOpened = TRUE
    twin = gwindow("Transform Variables", parent = e$win)
    addhandlerunrealize(twin, handler = function(h, ...){e$transformWinOpened = FALSE; dispose(twin)})

    transformGroup = ggroup(container = twin, horizontal = FALSE)
    addSpace(transformGroup, 20, horizontal = FALSE)
    transform.instruction = glabel("Drag and drop variable names onto the labels below\n            to create new transformed variables", cont = transformGroup)
    font(transform.instruction) = list(weight="bold", family = "normal", size = "medium")

    addSpace(transformGroup, 20, horizontal = FALSE)
    log.label = glabel("LOG (e) ", container = transformGroup)
    font(log.label) = list(weight="bold", family = "normal", size = "x-large", color = "navy")
    addSpace(transformGroup, 3, horizontal = FALSE)

    log10.label = glabel("LOG (10)", container = transformGroup)
    font(log10.label) = list(weight="bold", family = "normal", size = "x-large", color = "navy")
    addSpace(transformGroup, 3, horizontal = FALSE)

    exp.label = glabel("EXPONENTIAL", container = transformGroup)
    font(exp.label) = list(weight="bold", family = "normal", size = "x-large", color = "navy")
    addSpace(transformGroup, 3, horizontal = FALSE)

    sqr.label = glabel("SQUARE", container = transformGroup)
    font(sqr.label) = list(weight="bold", family = "normal", size = "x-large", color = "navy")
    addSpace(transformGroup, 3, horizontal = FALSE)

    sqrroot.label = glabel("SQUARE ROOT", container = transformGroup)
    font(sqrroot.label) = list(weight="bold", family = "normal", size = "x-large", color = "navy")
    addSpace(transformGroup, 3, horizontal = FALSE)

    reciprocal.label = glabel("RECIPROCAL", container = transformGroup)
    font(reciprocal.label) = list(weight="bold", family = "normal", size = "x-large", color = "navy")
    addSpace(transformGroup, 3, horizontal = FALSE)


    adddroptarget(sqr.label,
                handler = function(h, ...) {
                  variableName = id(h$dropdata)
                  variableData = svalue(h$dropdata)

                  n = names(tag(e$obj, "dataSet"))
                  if(!e$inDataView)
                      variableData =((tag(e$obj, "dataSet"))[,which(n == h$dropdata)])

                  if(all(is.factor(variableData))) gmessage(title = "ERROR", message = "Categorical variables cannot be transformed!", parent = twin)
                  else{

                    out = round((variableData)^2,3)
                    new.varName = paste(c("sqr.",variableName), collapse = "")
                    currData = tag(e$obj, "dataSet")
                    index = which(names(currData) == variableName)

                    if(index != length(names(currData))){
                      newData = data.frame(currData[,1:index], out, currData[,(index+1):(length(names(currData)))])
                      names(newData)[index] = names(currData)[index]
                      names(newData)[(index+1):(length(currData)+1)] = c(new.varName,(names(currData)[(index+1):(length(names(currData)))]))

                    }
                    else{
                     newData = transform(currData, new.varName = out)
                     names(newData)[length(newData)] = new.varName
                    }

                    tag(e$obj, "dataSet") =  newData
                    if(e$inDataView)
                      e$updateData()
                    else
                      e$updateList()
                    }

                  })

    adddroptarget(sqrroot.label,
                handler = function(h, ...) {
                  variableName = id(h$dropdata)
                  variableData = svalue(h$dropdata)

                  n = names(tag(e$obj, "dataSet"))
                  if(!e$inDataView)
                      variableData =((tag(e$obj, "dataSet"))[,which(n == h$dropdata)])

                  if(all(is.factor(variableData))) gmessage(title = "ERROR", message = "Categorical variables cannot be transformed!", parent = twin)
                  else{

                    out = round(sqrt(variableData),3)
                    new.varName = paste(c("sqroot.",variableName), collapse = "")
                    currData = tag(e$obj, "dataSet")
                    index = which(names(currData) == variableName)

                    if(index != length(names(currData))){
                      newData = data.frame(currData[,1:index], out, currData[,(index+1):(length(names(currData)))])
                      names(newData)[index] = names(currData)[index]
                      names(newData)[(index+1):(length(currData)+1)] = c(new.varName,(names(currData)[(index+1):(length(names(currData)))]))

                    }
                    else{
                     newData = transform(currData, new.varName = out)
                     names(newData)[length(newData)] = new.varName
                    }

                    tag(e$obj, "dataSet") =  newData
                    if(e$inDataView)
                      e$updateData()
                    else
                      e$updateList()
                    }

                  })

     adddroptarget(exp.label,
                  handler = function(h, ...) {
                  variableName = id(h$dropdata)
                  variableData = svalue(h$dropdata)

                  n = names(tag(e$obj, "dataSet"))
                  if(!e$inDataView)
                      variableData =((tag(e$obj, "dataSet"))[,which(n == h$dropdata)])

                  if(all(is.factor(variableData))) gmessage(title = 'ERROR', message = "Categorical variables cannot be transformed!", parent = twin)
                  else{

                    out = round(exp(variableData),3)
                    new.varName = paste(c("exp.",variableName), collapse = "")
                    currData = tag(e$obj, "dataSet")
                    index = which(names(currData) == variableName)

                    if(index != length(names(currData))){
                      newData = data.frame(currData[,1:index], out, currData[,(index+1):(length(names(currData)))])
                      names(newData)[index] = names(currData)[index]
                      names(newData)[(index+1):(length(currData)+1)] = c(new.varName,(names(currData)[(index+1):(length(names(currData)))]))
                    }
                    else{
                     newData = transform(currData, new.varName = out)
                     names(newData)[length(newData)] = new.varName
                    }

                    tag(e$obj, "dataSet") =  newData

                    if(e$inDataView)
                      e$updateData()
                    else
                      e$updateList()

                  }

                })

     adddroptarget(reciprocal.label,
                  handler = function(h, ...) {
                  variableName = id(h$dropdata)
                  variableData = svalue(h$dropdata)

                  n = names(tag(e$obj, "dataSet"))
                  if(!e$inDataView)
                      variableData =((tag(e$obj, "dataSet"))[,which(n == h$dropdata)])

                  if(all(is.factor(variableData))) gmessage(title = 'ERROR', message = "Categorical variables cannot be transformed!", parent = twin)
                  else{

                    out = round(1/(variableData),3)
                    new.varName = paste(c("recip.",variableName), collapse = "")
                    currData = tag(e$obj, "dataSet")
                    index = which(names(currData) == variableName)

                    if(index != length(names(currData))){
                      newData = data.frame(currData[,1:index], out, currData[,(index+1):(length(names(currData)))])
                      names(newData)[index] = names(currData)[index]
                      names(newData)[(index+1):(length(currData)+1)] = c(new.varName,(names(currData)[(index+1):(length(names(currData)))]))
                    }
                    else{
                     newData = transform(currData, new.varName = out)
                     names(newData)[length(newData)] = new.varName
                    }

                    tag(e$obj, "dataSet") =  newData

                    if(e$inDataView)
                      e$updateData()
                    else
                      e$updateList()

                  }

                })

     adddroptarget(log.label,
                  handler = function(h, ...) {
                  variableName = id(h$dropdata)
                  variableData = svalue(h$dropdata)

                  n = names(tag(e$obj, "dataSet"))
                  if(!e$inDataView)
                      variableData =((tag(e$obj, "dataSet"))[,which(n == h$dropdata)])

                  if(all(is.factor(variableData))) gmessage(title = 'ERROR', message = "Categorical variables cannot be transformed!", parent = twin)
                  else{

                    out = round(log(variableData),3)
                    new.varName = paste(c("log.e.",variableName), collapse = "")
                    currData = tag(e$obj, "dataSet")
                    index = which(names(currData) == variableName)

                    if(index != length(names(currData))){
                      newData = data.frame(currData[,1:index], out, currData[,(index+1):(length(names(currData)))])
                      names(newData)[index] = names(currData)[index]
                      names(newData)[(index+1):(length(currData)+1)] = c(new.varName,(names(currData)[(index+1):(length(names(currData)))]))
                    }
                    else{
                     newData = transform(currData, new.varName = out)
                     names(newData)[length(newData)] = new.varName
                    }

                    tag(e$obj, "dataSet") =  newData
                    if(e$inDataView)
                      e$updateData()
                    else
                      e$updateList()
                  }

                })


     adddroptarget(log10.label,
                  handler = function(h, ...) {
                  variableName = id(h$dropdata)
                  variableData = svalue(h$dropdata)

                  n = names(tag(e$obj, "dataSet"))
                  if(!e$inDataView)
                      variableData =((tag(e$obj, "dataSet"))[,which(n == h$dropdata)])

                  if(all(is.factor(variableData))) gmessage(title = 'ERROR', message = "Categorical variables cannot be transformed!", parent = twin)
                  else{

                    out = round(log10(variableData),3)
                    new.varName = paste(c("log.10.",variableName), collapse = "")
                    currData = tag(e$obj, "dataSet")
                    index = which(names(currData) == variableName)

                    if(index != length(names(currData))){
                      newData = data.frame(currData[,1:index], out, currData[,(index+1):(length(names(currData)))])
                      names(newData)[index] = names(currData)[index]
                      names(newData)[(index+1):(length(currData)+1)] = c(new.varName,(names(currData)[(index+1):(length(names(currData)))]))
                    }
                    else{
                     newData = transform(currData, new.varName = out)
                     names(newData)[length(newData)] = new.varName
                    }

                    tag(e$obj, "dataSet") =  newData
                    if(e$inDataView)
                      e$updateData()
                    else
                      e$updateList()
                  }

                })
  }












  e$collapseHandler = function(){

     if(!e$collapseWinOpened){

         e$collapseWinOpened = TRUE


         getType = function() {
           e$currData = tag(e$obj,"dataSet")
           indices = numeric(0)
           for(i in 1 : length(names(e$currData))){
             if(!is.numeric(eval(parse(text = paste("e$currData$", names(e$currData[i]),sep="")))))indices = c(indices, i)
           }
           indices
         }

         collapseLevels = function(h, ...){

             e$collapseWinOpened = TRUE

             e$currData = tag(e$obj,"dataSet")
             factorIndices = getType()

             e$collapseWin = gwindow("Collapse Levels", cont = TRUE, horizontal = TRUE, parent = e$win, height = 350, width = 190)
             addhandlerunrealize(e$collapseWin, handler = function(h, ...){e$collapseWinOpened = FALSE; dispose(e$collapseWin)})

             e$menuGroup = ggroup(cont = e$collapseWin, horizontal = FALSE)

             instruction1 = glabel("Choose a variable")
             font(instruction1) = list(weight="bold", family = "normal")
             instruction2 = glabel("Choose two or more levels", family = "normal")
             font(instruction2) = list(weight = "bold")

             instruction3 = glabel("(Hold Ctrl to choose many)")
             font(instruction3) <- list(weight="bold", family = "normal")

             factorMenu = gdroplist((names(e$currData))[factorIndices], selected = 0, handler = selectFactor)
             e$levelsTable = gtable("", multiple= TRUE)
             names(e$levelsTable) = "Levels"

             e$collapseButt = gbutton(" - COLLAPSE - ", handler = collapseChosenLvls)
             font(e$collapseButt) = list(weight = "bold", family = "normal")
             add(e$menuGroup, instruction1)
             add(e$menuGroup, factorMenu)
             addSpace(e$menuGroup, 5, horizontal = FALSE)
             add(e$menuGroup, instruction2)
             add(e$menuGroup, instruction3)
             addSpace(e$menuGroup, 5, horizontal = FALSE)
             add(e$menuGroup, e$levelsTable, expand = TRUE)
             add(e$menuGroup, e$collapseButt)


             e$counter = 0
             gseparator(horizontal = FALSE, container = e$collapseWin, expand = TRUE)

         }

         selectFactor = function(h, ...){
           e$counter = e$counter + 1
           selectedFactor = svalue(h$obj)
           tag(e$obj, "selectedFactor") = selectedFactor
           lvls = eval(parse(text = paste(c("levels(as.factor(e$currData$", selectedFactor, "))"),collapse = "")))

           if(e$counter > 1){

               e$usedLevels = character(0)
               e$levelCombination = list()

               if(!is.null(e$thirdPanel)){
                  delete(e$thirdPanel, e$labelGroup)
                  delete(e$thirdPanel, e$textGroup)

                  delete(e$thirdPanel, e$thirdGroup)
                  delete(e$collapseWin, e$thirdPanel)
               }
               #delete(e$collapseWin, e$x1)

           }
           e$levelsTable[] = lvls
           e$buttonPushed = 0
           e$usedLevels = character(0)
           #e$x1 = gseparator(horizontal = FALSE, container = e$collapseWin, expand = TRUE)

         }




         getNewLevel = function(levelNames){
           eval(paste(levelNames, collapse = "_"))

         }

         clearAllCollapse = function(h, ...){
            chosenLvls = character(0)
            e$usedLevels = character(0)
            delete(e$collapseWin, e$thirdPanel)
            e$buttonPushed = 0
            e$textboxList =  list()
            e$levelCombination = list()
            chosenLvls.temp = NULL
         }



         submit = function(h, ...){
            e$changedData = tag(e$obj, "dataSet")

            if(length(e$textboxList) != 0){
                index = which(names(e$changedData) == tag(e$obj, "selectedFactor"))
                x = as.character(e$changedData[,index])

                for(i in 1:length(e$textboxList)){
                    newVar = as.factor(ifelse(x %in% e$levelCombination[[i]], gsub("\\n", "", svalue(e$textboxList[[i]])), x))
                    x = as.character(newVar)

                }
            }

            new.varName = paste(names(e$changedData)[index],".coll", sep = "")
            oldVarNames = names(e$changedData)
            if(new.varName %in% oldVarNames)
               e$changedData[, which(oldVarNames == new.varName)] = newVar

            if(index != length(names(e$changedData))){
                e$changedData = data.frame(e$changedData[,1:index], newVar , e$changedData[,(index+1):(length(oldVarNames))])
                names(e$changedData)[index] = oldVarNames[index]
                names(e$changedData)[(index+1):(ncol(e$changedData))] = c(new.varName,(oldVarNames[(index+1):(length(oldVarNames))]))
            }else{
                e$changedData = transform(e$changedData, new.var = newVar)
                names(e$changedData)[length(e$changedData)] = new.varName
            }

            tag(e$obj, "dataSet") = e$changedData

            gmessage(title = "INFO",
              message = paste("The new variable", new.varName, "will be inserted next to", names(e$changedData)[index], "in the dataset")
              , icon = "info", cont = TRUE, parent = e$collapseWin)

            if(e$inDataView)
              e$updateData()
            else
              e$updateList()


            e$collapseWinOpened = FALSE
            dispose(e$collapseWin)
         }



         collapseChosenLvls =  function(h, ...){

           e$buttonPushed = e$buttonPushed + 1

           if(e$buttonPushed == 1){
               e$labelGroup = ggroup(horizontal = "FALSE", expand = TRUE)
               e$textGroup = ggroup(horizontal = "FALSE", expand = TRUE)
               e$thirdGroup = ggroup(horizontal = "TRUE", expand = TRUE)
               e$thirdPanel = ggroup(horizontal = "FALSE", expand = TRUE)
               add(e$thirdGroup, e$labelGroup, expand = TRUE)
               add(e$thirdGroup, e$textGroup, expand = TRUE)
               clearButton = gbutton("CLEAR ALL", handler = clearAllCollapse)
               font(clearButton) = list(weight = "bold", family = "normal")
               finishButton = gbutton("ALL DONE", handler = submit)
               font(finishButton) = list(weight = "bold", family = "normal")
               add(e$thirdPanel, e$thirdGroup, expand = TRUE)
               add(e$thirdPanel, clearButton)
               add(e$thirdPanel, finishButton)
               add(e$collapseWin, e$thirdPanel, expand = TRUE)

               e$textboxList =  list()
               e$levelCombination = list()
               chosenLvls.temp = NULL
           }
           chosenLvls.temp = svalue(e$levelsTable)
           if("" %in% svalue(e$levelsTable)) chosenLvls.temp = chosenLvls.temp[chosenLvls.temp != ""]

           if(is.null(svalue(e$levelsTable))){

                gmessage("Need to select at least two levels to collapse", title="ALERT", icon = "warning", parent = e$collapseWin)
                e$buttonPushed = e$buttonPushed - 1
                if(length(e$textboxList) == 0) delete(e$collapseWin, e$thirdPanel)

           }else if(length(svalue(e$levelsTable))<2){

                gmessage("Need to select at least two levels to collapse", title="ALERT", icon = "warning", parent = e$collapseWin)
                e$buttonPushed = e$buttonPushed - 1
                if(length(e$textboxList) == 0) delete(e$collapseWin, e$thirdPanel)

           }else if(length(chosenLvls.temp) >= 2){

               chosenLvls = svalue(e$levelsTable)
               if("" %in% chosenLvls) chosenLvls = chosenLvls[chosenLvls != ""]


               if(any(chosenLvls %in% e$usedLevels)){
                 gmessage(message = "One or more levels have already been collapsed!\nClear the previous selections or choose new levels", title = "ALERT", icon = "warning", parent = e$collapseWin)
                 selectedFactor = tag(e$obj, "selectedFactor")
                 e$buttonPushed = e$buttonPushed - 1
               }
               else{
                 e$usedLevels = c(e$usedLevels,chosenLvls)
                 if("" %in% e$usedLevels) e$usedLevels = e$usedLevels[e$usedLevels != ""]
                 label = paste(paste(chosenLvls, collapse = " + ")," -> ",collapse = "")
                 add(e$labelGroup, glabel(label))
                 addSpace(e$labelGroup, 15)
                 newLevel = getNewLevel(chosenLvls)

                 eval(parse(text=paste(c("e$textboxList$","lbl",e$buttonPushed, "= gtext(\"",newLevel,"\",width = 200, height = 20)"), collapse="")))

                 add(e$textGroup, eval(parse(text = paste(c("e$textboxList$","lbl",e$buttonPushed), collapse=""))))


                 selectedFactor = tag(e$obj, "selectedFactor")
                 x = character(0)
                 e$levelCombination[[e$buttonPushed]] = chosenLvls
               }
           }else{
               gmessage("Need to select at least two levels to collapse", title="ALERT", icon = "warning", parent = e$collapseWin)
               e$buttonPushed = e$buttonPushed - 1
               if(length(e$textboxList) == 0) delete(e$collapseWin, e$thirdPanel)
           }

       }

       collapseLevels()
   }
  }


  e$convertToFactor = function(){

    e$cVariableData = NULL
    e$convertWinOpened = TRUE

    convertWin = gwindow("Convert to Categorical", horizontal = FALSE, width = 200, height = 250, parent = e$win, )
    addhandlerunrealize(convertWin, handler = function(h,...){e$convertWinOpened = FALSE; dispose(convertWin)})

    mainGroup = ggroup(horizontal = FALSE)
    convertGroup1 = ggroup(horizontal = FALSE)
    addSpace(convertGroup1, 20, horizontal = FALSE)
    convert.instruction = glabel("1. Drag and drop a variable name onto the label below\n  to create a categorical version of that variable", cont = convertGroup1)
    font(convert.instruction) = list(weight="bold", family = "normal")
    addSpace(convertGroup1, 10, horizontal = FALSE)


    convertGroup2 = ggroup(horizontal = FALSE)
    convert.label = glabel(" DROP VARIABLE HERE ", expand = TRUE)
    font(convert.label) = list(size = "x-large")
    add(convertGroup2, convert.label, expand = TRUE)
    addSpace(convertGroup2, 10, horizontal = FALSE)

    convertGroup3 = ggroup(horizontal = TRUE)
    addSpace(convertGroup3, 10, horizontal = FALSE)
    name.label = glabel("2. Type name for the new variable: ")
    font(name.label) = list(weight="bold", family = "normal")
    name.text = gtext("N/A", width = 80, height = 20)
    glay = glayout()
    glay[1,2] = name.label
    glay[2,2:15] = name.text
    add(convertGroup3, glay)
    visible(glay) = TRUE

    convertGroup4 = ggroup(horizontal = FALSE)
    ok.button = gbutton("Update Data", cont = convertGroup4, handler = function(h,...){

                  if(all(is.factor(e$cVariableData))) gmessage("Already a categorical variable!",title="INFO", parent = e$win)
                  else{
                    out = as.factor(e$cVariableData)
                    new.varName = ifelse(svalue(h$obj) == "", paste(e$cVariableName, ".g", sep = ""), gsub('\\n+', "", svalue(name.text), perl = TRUE) )
                    currData = tag(e$obj, "dataSet")
                    index = which(names(currData) == e$cVariableName)

                    if(index != length(names(currData))){
                      newData = data.frame(currData[,1:index], out, currData[,(index+1):(length(names(currData)))])
                      names(newData)[(index+1):(length(currData)+1)] = c(new.varName,(names(currData)[(index+1):(length(names(currData)))]))
                    }
                    else{
                      newData = transform(currData, new.varName = out)
                      names(newData)[length(newData)] = new.varName
                    }

                    gmessage(title = "INFO",
                      message = paste("The new variable", new.varName,"will be inserted next to", names(currData)[index], "in the dataset")
                      , icon = "info", cont = TRUE, parent = e$win)

                    tag(e$obj, "dataSet") =  newData

                    if(e$inDataView)
                      e$updateData()
                    else
                      e$updateList()
                  }

                  e$convertWinOpened = FALSE
                  dispose(convertWin)
    })
    font(ok.button) = list(weight="bold", family = "normal")

    adddroptarget(convert.label,
                handler = function(h, ...) {
                  e$cVariableData = svalue(h$dropdata)

                  n = names(tag(e$obj, "dataSet"))
                  if(!e$inDataView)
                      e$cVariableData =((tag(e$obj, "dataSet"))[,which(n == h$dropdata)])

                  if(all(is.factor(e$cVariableData))) gmessage("Already a categorical variable!", parent = e$win)
                  else{
                      #e$cVariableData = svalue(h$dropdata)
                      e$cVariableName = id(h$dropdata)
                      svalue(name.text) = paste(e$cVariableName, ".g", sep = "")
                  }
                  })

    add(mainGroup, convertGroup1)
    add(mainGroup, gseparator(horizontal = TRUE))

    add(mainGroup, convertGroup2, expand = TRUE)

    add(mainGroup, gseparator(horizontal = TRUE))
    add(mainGroup, convertGroup3)
    add(mainGroup, convertGroup4)
    add(convertWin, mainGroup, expand = TRUE)
    #addSpace(convertWin, horizontal = FALSE)

  }

  e$trashVar = function(){

    e$trashWinOpened = TRUE
    trashWin = gwindow("Trash Variables", horizontal = FALSE, parent = e$win, )
    addhandlerunrealize(trashWin, handler = function(h,...){e$trashWinOpened = FALSE; dispose(trashWin)})

    mainGroup = ggroup(horizontal = FALSE)



    trashImage = gimage(filename = paste(OrigPath,"/trash.jpg",sep=""), size = "dialog")
    adddroptarget(trashImage, handler = function(h,...){

          #unwantedVar = id(h$dropdata)
         n = names(tag(e$obj, "dataSet"))
         if(length(n) != 1){

           if(id(h$dropdata) == "ROW_NAME")
             gmessage("The variable ROW_NAME cannot be deleted.", parent = trashWin)
           else{
             tag(e$obj, "dataSet") = subset(tag(e$obj, "dataSet"), select = n[-(which(n == id(h$dropdata))[1])])

             #head(tag(e$obj, "dataSet"))
             if(e$inDataView)
                e$updateData()
             else
                e$updateList()
          }
        }else gmessage("Last variable remaining in dataset not deleted!", parent = trashWin)



    })

    addSpace(mainGroup, 10,  horizontal = FALSE)
    add(mainGroup, glabel("Drag any unwanted variables onto the image below"))
    addSpace(mainGroup, 10,  horizontal = FALSE)
    add(mainGroup, trashImage)
    add(trashWin, mainGroup)

  }


e$newVariable = function(){

    e$newVariableWinOpened = TRUE
    newVariableWin = gwindow("Create New Variables", parent = e$win, width = 250, height = 200)
    addhandlerunrealize(newVariableWin, handler = function(h,...){e$newVariableWinOpened = FALSE; dispose(newVariableWin)})

    newVariableMain = ggroup(horizontal = FALSE, cont = newVariableWin)

    addSpace(newVariableMain, 5, horizontal = FALSE)
    lbl1 = glabel("Type in an expression to compute a new variable", cont = newVariableMain)
    font(lbl1) <- list(weight="bold", family = "normal")
    addSpace(newVariableMain, 5, horizontal = FALSE)
    lbl2 = glabel("EXAMPLES", cont = newVariableMain)
    font(lbl2) <- list(weight="bold", family = "normal")

    lbl3 = glabel("av.height = (m.height + f.height)/2")
    lbl4 = glabel("wgt.diff = wgt.After - wgt.Before")
    addSpace(newVariableMain, 5, horizontal = FALSE)
    newVariableLayout = glayout(cont = newVariableMain)
    newVariableSecondary = ggroup(horizontal = TRUE, cont = newVariableMain)

    newVarText = gtext("new.variable", width = 50, height = 20)
    lbl5 = glabel(" = ")
    font(lbl5) <- list(weight="bold", family = "normal")
    expressionText = gtext("  ")

    #newVariableLayout[1,2:4, anchor = c(-1,1)] = lbl3
    #newVariableLayout[2,2:4, anchor = c(-1,1)] = lbl4

    newVariableLayout[1,2, anchor = c(-1,1)] = "av.height"
    newVariableLayout[1,3, anchor = c(-1,1)] = "="
    newVariableLayout[1,4, anchor = c(-1,1)] = "(m.height + f.height)/2"
    newVariableLayout[2,2, anchor = c(-1,1)] = "wgt.diff"
    newVariableLayout[2,3, anchor = c(-1,1)] = "="
    newVariableLayout[2,4, anchor = c(-1,1)] = "wgt.After - wgt.Before"

    newVariableLayout[4,2,anchor = c(-1,1)] = newVarText
    newVariableLayout[4,3,anchor = c(-1,1)] = lbl5
    newVariableLayout[4,4, expand = TRUE, anchor = c(-1,1)] = expressionText

    submitButton = gbutton(" - SUBMIT -", handler = function(h,...){

        newValues = try(eval(parse(text = paste("with(tag(e$obj, \"dataSet\"),", gsub(pattern = '\\n+', "", svalue(expressionText), perl = TRUE), ")"))))
        if(class(newValues)[1] == "try-error")
          gmessage(title = "ERROR", message = "Error in expression!", icon = "error", parent = newVariableWin)
        else{
          newVarName = gsub(pattern = '\\n+', "", svalue(newVarText), perl = TRUE)
          oldNames = names(tag(e$obj, "dataSet"))
          d = data.frame(tag(e$obj, "dataSet"), newValues)
          names(d) = make.names(c(oldNames, newVarName), unique = TRUE)
          tag(e$obj, "dataSet") = d

          gmessage(title = "INFO",
            message = paste("The new variable", newVarName,"will be inserted as the last column of the dataset")
            , icon = "info", cont = TRUE, parent = newVariableWin)

          if(e$inDataView)
            e$updateData()
          else
            e$updateList()

          e$newVariableWinOpened = FALSE
          dispose(newVariableWin)
        }
    })

    addSpring(newVariableMain)
    addSpring(newVariableSecondary)
    add(newVariableSecondary, submitButton)


}

e$renameLevels = function(){

  e$renameLWinOpened = TRUE
  e$chosenVariableIndex_2 = 0


  factorList_2 = character(0)
  for(i in 1:length(names(tag(e$obj, "dataSet")))){
    if(is.factor(tag(e$obj, "dataSet")[,i]))
      factorList_2 = c(factorList_2, names(tag(e$obj, "dataSet"))[i])

  }


  e$newVarName_2 = gtext(" ", height = 30)
  reorderVarList_2 = gdroplist(factorList_2,selected = 0, handler = function(h,...){ e$chosenVariableIndex_2 = which(factorList_2[svalue(h$obj, index = TRUE)] == names(tag(e$obj, "dataSet")));svalue(e$newVarName_2) = paste(factorList_2[svalue(h$obj, index = TRUE)], "2", sep = ".")})
  proceedButton = gbutton("- PROCEED -", handler = function(h,...){if(factorList_2[1] != "empty"){enabled(proceedButton) = FALSE; e$proceed_2()}})
  font(proceedButton) = list(weight = "bold")

  lbl1 = glabel("Variable :")
  font(lbl1) = list(weight = "bold", style = "normal")
  lbl2 = glabel("New variable :")
  font(lbl2) = list(weight = "bold", style = "normal")

  renameLayout1 = glayout()
  renameLayout1[2,2] = lbl1
  renameLayout1[2,3:5] = reorderVarList_2
  #renameLayout1[4,2] = lbl2
  #renameLayout1[4,3:6] = e$newVarName_2
  renameLayout1[4,2:5] = proceedButton
  e$renameLWin = gwindow("Rename Levels", cont = TRUE, parent = e$win, width = 200, height = 200)
  addhandlerunrealize(e$renameLWin, handler = function(h,...){e$renameLWinOpened = FALSE; dispose(e$renameLWin)})
  renameMain = ggroup(cont = e$renameLWin)
  add(renameMain, renameLayout1)

  visible(renameLayout1) = TRUE

}

e$proceed_2 = function(){
  newName = ""
  textboxList =  list()
  levelN = levels((tag(e$obj, "dataSet"))[,e$chosenVariableIndex_2])
# check if the name given is correct
#  if((svalue(e$newVarName_2) == "") || (svalue(e$newVarName_2) %in% names(tag(e$obj, "dataSet"))))
#    newName = paste(factorList_2[svalue(h$obj, index = TRUE)], "reordered", sep = ".")
#  else  newName = gsub('\\n+', "", svalue(e$newVarName_2), perl = TRUE)

  renameLayout = glayout()
  lbl1 = glabel("Old Levels")
  font(lbl1) = list(weight = "bold", style = "normal")
  lbl2 = glabel("New Levels")
  font(lbl2) = list(weight = "bold", style = "normal")
  renameLayout[2,2] = lbl1
  renameLayout[2,4] = lbl2

  for(i in 1:length(levelN)){
    eval(parse(text=paste(c("textboxList$","lbl",i, "= gtext(\"",levelN[i],"\"",",width = 55, height = 35)"), collapse="")))
    renameLayout[i+3,2] = glabel(as.character(levelN[i]))
    renameLayout[i+3,4:6] = eval(parse(text = paste(c("textboxList$","lbl",i), collapse="")))
  }

  finalButton = gbutton("- RENAME -", handler = function(h,...){
                                                levelNames = character(0)
                                                for(i in 1:length(levelN))
                                                  levelNames = c(levelNames, gsub(pattern = '\\s+', replacement = "", x = svalue(textboxList[[i]]), perl = TRUE))


                                                if("" %in% levelNames){
                                                  gmessage(title = "INFO",
                                                    message = paste("Please provide", length(levelN),"level names"), icon = "info", cont = TRUE, parent = e$win)
                                                }else{
                                                  x = tag(e$obj, "dataSet")
                                                  x[,e$chosenVariableIndex_2] = factor((tag(e$obj, "dataSet"))[,e$chosenVariableIndex_2], labels = levelNames)
                                                  tag(e$obj, "dataSet") = x
                                                  gmessage(title = "INFO",
                                                    message = paste("The levels of the variable", names(tag(e$obj, "dataSet"))[e$chosenVariableIndex_2],"will be changed")
                                                    , icon = "info", cont = TRUE, parent = e$win)
                                                  if(e$inDataView)
                                                    e$updateData()
                                                  else
                                                    e$updateList()

                                                  dispose(renameWin2)
                                                }

                                             })
  font(finalButton) = list(weight = "bold")
  renameLayout[length(levelN)+4,2:5] = finalButton

  dispose(e$renameLWin)
  e$renameLWinOpened = TRUE
  renameWin2 = gwindow("Rename Levels", cont = TRUE, parent = e$win, width = 200, height = 200)
  addhandlerunrealize(renameWin2, handler = function(h,...){e$renameLWinOpened = FALSE; dispose(renameWin2)})
  reorderWinMain2 = ggroup(horizontal = FALSE, cont = renameWin2)

  visible(renameLayout) = TRUE
  add(renameWin2, renameLayout)

  e$renameLWinOpened = FALSE

}




e$renameVariables = function(){
  namesN = names(tag(e$obj, "dataSet"))
  textboxList =  list()
  renameLayout = glayout()
  lbl1 = glabel("Old Variables")
  font(lbl1) = list(weight = "bold", style = "normal")
  lbl2 = glabel("New Variables")
  font(lbl2) = list(weight = "bold", style = "normal")
  renameLayout[2,2] = lbl1
  renameLayout[2,4] = lbl2

  for(i in 1:length(namesN)){
    eval(parse(text=paste(c("textboxList$","lbl",i, "= gtext(\"",namesN[i],"\"",",width = 55, height = 35)"), collapse="")))
    renameLayout[i+3,2] = glabel(as.character(namesN[i]))
    renameLayout[i+3,4:6] = eval(parse(text = paste(c("textboxList$","lbl",i), collapse="")))
  }

  finalButton = gbutton("- RENAME -", handler = function(h,...){
                                                varNames = character(0)
                                                for(i in 1:length(namesN))
                                                  varNames = c(varNames, gsub(pattern = '\\s+', replacement = "", x = svalue(textboxList[[i]]), perl = TRUE))


                                                if("" %in% varNames){
                                                  gmessage(title = "INFO",
                                                    message = paste("Please provide", length(namesN),"variable names"), icon = "info", cont = TRUE, parent = e$win)
                                                }else{
                                                  x = tag(e$obj, "dataSet")
                                                  names(x) = make.names(varNames, unique = TRUE)
                                                  tag(e$obj, "dataSet") = x
                                                  gmessage(title = "INFO", message = "The variables names will be updated"
                                                    , icon = "info", cont = TRUE, parent = e$win)
                                                  if(e$inDataView)
                                                    e$updateData()
                                                  else
                                                    e$updateList()

                                                  dispose(renameWin2)
                                                }

                                             })
  font(finalButton) = list(weight = "bold")
  renameLayout[length(namesN)+4,2:5] = finalButton


  e$renameVWinOpened = TRUE
  renameWin2 = gwindow("Rename Variables", cont = TRUE, parent = e$win, width = 190, height = 200)
  addhandlerunrealize(renameWin2, handler = function(h,...){e$renameVWinOpened = FALSE; dispose(renameWin2)})
  reorderWinMain2 = ggroup(horizontal = FALSE, cont = renameWin2)

  visible(renameLayout) = TRUE
  add(renameWin2, renameLayout)

}

  e$scatterPlotMatrix = function(h,...){
      e$scatterPlotWinOpened = TRUE
      varList = names(tag(e$obj, "dataSet"))

      scatterPlotWin = gwindow("Scatter Plot Matrix", parent = e$win, width = 250, height = 350)
      addhandlerunrealize(scatterPlotWin, handler = function(h,...){e$scatterPlotWinOpened = FALSE; dispose(scatterPlotWin)})

      scatterPlotMain = ggroup(horizontal = FALSE, cont = scatterPlotWin, expand = TRUE)
      addSpace(scatterPlotMain, 5, horizontal = FALSE)
      lbl1 = glabel("Dataset Variables", cont = scatterPlotMain)
      font(lbl1) <- list(weight="bold", family = "normal")
      lbl2 = glabel("(Hold Ctrl to choose many)", cont = scatterPlotMain)
      font(lbl2) <- list(weight="bold", family = "normal")

      listOfVars = gtable(varList, multiple = TRUE, cont = scatterPlotMain, expand = TRUE)
      names(listOfVars) = "Variables"

      addSpace(scatterPlotMain, 5, horizontal = FALSE)
      plotButton = gbutton("- Plot -", cont = scatterPlotMain, handler = function(h,...) {

          chosenVars = svalue(listOfVars)
          chosenVarIndices = which(names(tag(e$obj,"dataSet")) %in% chosenVars)

          x11()
          pairs(tag(e$obj, "dataSet")[,chosenVarIndices])
          #dispose(scatterPlotWin)
      })
      font(plotButton) = list(weight = "bold")

  }
  


e$scatterPlotMatrix = function(h,...){
    e$scatterPlotWinOpened = TRUE
    varList = names(tag(e$obj, "dataSet"))

    scatterPlotWin = gwindow("Scatter Plot Matrix", parent = e$win, width = 250, height = 350)
    addhandlerunrealize(scatterPlotWin, handler = function(h,...){e$scatterPlotWinOpened = FALSE; dispose(scatterPlotWin)})

    scatterPlotMain = ggroup(horizontal = FALSE, cont = scatterPlotWin, expand = TRUE)
    addSpace(scatterPlotMain, 5, horizontal = FALSE)
    lbl1 = glabel("Dataset Variables", cont = scatterPlotMain)
    font(lbl1) <- list(weight="bold", family = "normal")
    lbl2 = glabel("(Hold Ctrl to choose many)", cont = scatterPlotMain)
    font(lbl2) <- list(weight="bold", family = "normal")

    listOfVars = gtable(varList, multiple = TRUE, cont = scatterPlotMain, expand = TRUE)
    names(listOfVars) = "Variables"

    addSpace(scatterPlotMain, 5, horizontal = FALSE)
    plotButton = gbutton("- Plot -", cont = scatterPlotMain, handler = function(h,...) {

        chosenVars = svalue(listOfVars)
        chosenVarIndices = which(names(tag(e$obj,"dataSet")) %in% chosenVars)

        x11()
        pairs(tag(e$obj, "dataSet")[,chosenVarIndices])
        #dispose(scatterPlotWin)
    })
    font(plotButton) = list(weight = "bold")

}
  e$modelFitting = function(){

    e$modellingWinOpened = TRUE                  #width = 710 if Help is included
    modellingWin = gwindow(" ", height = 650, width = 715, cont = TRUE, horizontal = FALSE)

    addhandlerunrealize(modellingWin, handler = function(h,...){e$modellingWinOpened = FALSE; dispose(modellingWin)})

    mainGp = ggroup(cont = modellingWin, horizontal = FALSE)
    menuGp = ggroup(cont = mainGp, expand = FALSE, horizontal = FALSE)

    tblist = list()
    tblist$Summ <- gmenu(list("Summary" = list("summary(current.model)" = list(handler = function(h,...) getModelSummary(), icon = "symbol_diamond"))))
    #tblist$Summ$label <- "summary()"
    #tblist$Summ$icon <- "summary()"
    tblist$sep1$separator <- TRUE

    tblist$Anova <- gmenu(list("Anova" = list("anova(current.model)" = list(handler = function(h,...) getModelAnova(), icon = "symbol_diamond"),
                                              "Compare two models" = list(handler = function(h,...) defHandler(), icon = "symbol_square"))
                          ))
    #tblist$Anova$label = "anova()"
    #tblist$Anova$icon <- "anova()"
    tblist$sep2$separator <- TRUE

    tblist$gof = gmenu(list("Goodness of Fit" = list("AIC" = list(handler = function(h,...) getAIC(), icon = "symbol_diamond"),
                                                     "BIC" = list(handler = function(h,...) getBIC(), icon = "symbol_square"))
                        ))
    #tblist$gof$icon = "symbol_dot"
#    tblist$sep3$separator <- TRUE
#
#    tblist$selection = gmenu(list("Model Selection" = list("Forward" = list(handler = function(h,...)defHandler(), icon = "symbol_diamond"),
#                                        "Backward" = list(handler = function(h,...)defHandler(), icon = "symbol_square"),
#                                        "Stepwise" = list(handler = function(h,...)defHandler(), icon = "symbol_dntriangle"),
#                                        "All possible subsets" = list(handler = function(h,...)defHandler(), icon = "symbol_circle"))
#                        ))
    #tblist$gof$icon = "symbol_dot"

    tblist$sep4$separator <- TRUE


    tblist$diagnostics2 = gmenu(list("Graphical Diagnostics" = list("Scatter Plot Matrix" = list(handler = function(h,...) getScatterplotMatrix(), icon = "symbol_diamond"),
                                                                    "Basic Plots (4 types)" = list(handler = function(h,...) getBasicPlots(), icon = "symbol_square"),
                                                                    "Added Variable Plots" = list(handler = function(h,...) getEffectsPlots(), icon = "symbol_dntriangle"))
                        ))

    tblist$sep5$separator <- TRUE

    # 330 level or 20x level <- until that question is answered shouldn't actually implement too much of the handlers
    tblist$diagnostics1 = gmenu(list("Drop Observations" = list("Specify obs to drop" = list(handler = function(h,...) dropObs(), icon = "symbol_diamond"))
                          ))

#    tblist$diagnostics1 = gmenu(list("Numerical Diagnostics" = list("Variance Inflation Factors" = list(handler = function(h,...) getVIFs(), icon = "symbol_diamond"),
#                                                                    "D-W test" = list(handler = function(h,...)defHandler(), icon = "symbol_square"))
#                        ))

    tblist$sep6$separator <- TRUE

    # 330 level or 20x level <- until that question is answered shouldn't actually implement too much of the handlers
    tblist$prediction = gmenu(list("Prediction" = list("Use current.model for prediction" = list(handler = function(h,...) makePredictions(), icon = "symbol_diamond"))
                          ))

    #tblist$sep6$separator <- TRUE

    tblist2 = list()

    tblist2$dropObs = gmenu(list("Drop Observations" = list("Omit outliers when fitting model" = list(handler = function(h,...) dropObs(), icon = "symbol_diamond"))
                        ))

    tblist2$sep1$separator <- TRUE

    tblist2$prediction = gmenu(list("Predict" = list("Use current.model for prediction" = list(handler = function(h,...)makePredictions(), icon = "symbol_diamond"))
                        ))



#    tblist$sep6$separator <- TRUE
#    tblist$helpM = gmenu(list("Help" = list("A" = list(handler = function(h,...)defHandler(), icon = "symbol_diamond"),
#                                            "B" = list(handler = function(h,...)defHandler(), icon = "symbol_square"),
#                                            "C" = list(handler = function(h,...)defHandler(), icon = "symbol_dntriangle"),
#                                            "D" = list(handler = function(h,...)defHandler(), icon = "symbol_circle"))
#                        ))

    #addSpace(menuGp, 5, horizontal = FALSE)
    #gtoolbar(tblist, cont = menuGp, expand = TRUE)

    addSpace(menuGp, 5, horizontal = FALSE)
    instruct1.m1 = glabel("Example :  ")
    instruct.m1 = glabel("log( height )")
    instruct.m2 = glabel(" ~ ")
    instruct.m3 = glabel("age * gender + armspan + I (armspan ^ 2)")
    font(instruct1.m1) <- list(weight="bold", family = "normal")
    font(instruct.m1) <- list(weight="bold", family = "normal", color = "blue")
    font(instruct.m2) <- list(weight="bold", family = "normal")
    font(instruct.m3) <- list(weight="bold", family = "normal", color = "blue")
    #add(menuGp, instruct.m)
    #addSpace(menuGp, 10, horizontal = FALSE)

    layoutGp = ggroup(cont = mainGp, expand = TRUE, horizontal = FALSE)
    layout.m1 = glayout()
    varList.m = gcombobox(c("",names(tag(e$obj,"dataSet"))),selected = 1, handler = function(h,...) addToEquation(svalue(varList.m)))
    #responseList.m = gcombobox(names(tag(e$obj,"dataSet")),selected = 0, editable = TRUE)



    responseTxt = gcombobox(names(tag(e$obj,"dataSet")),selected = 0, editable = TRUE, width = 100)         #responseList.m    #gtext(width = 100, height = 25, font.attr = c(style="normal", weights="bold",sizes="medium"))
    #covariateTxt = gtext(width = 390, height = 15, font.attr = c(style="normal", weights="bold",sizes="medium"))
    covariateTxt = gtext(width = 30, height = 25, font.attr = c(style="normal", weights="bold",sizes="medium"))
    tilda = glabel(" ~ ")
    font(tilda) <- list(weight="bold")

    plus = gbutton(" + ", handler = function(h,...) addToEquation("+"))
    multiply = gbutton(" * ", handler = function(h,...) addToEquation("*"))
    interact = gbutton(" : ", handler = function(h,...) addToEquation(":"))
    divide = gbutton(" / ", handler = function(h,...) addToEquation("/"))
    toPower = gbutton(" ^ ", handler = function(h,...) addToEquation("^"))
    openBracket = gbutton(" ( ", handler = function(h,...) addToEquation("("))
    closeBracket = gbutton(" ) ", handler = function(h,...) addToEquation(")"))

    heading = glabel("MODEL FITTING")
    font(heading) <- list(weight="bold", sizes = "large", color = "navy")

    layout.m1[1,3:9] = heading
    layout.m1[2,1] = instruct1.m1
    layout.m1[3,1] = instruct.m1; layout.m1[3,2] = instruct.m2; layout.m1[3,3] = instruct.m3
    layout.m1[4,4] = plus; layout.m1[4,5] = multiply; layout.m1[4,6] = interact; layout.m1[4,7] = divide; layout.m1[4,8] = toPower; layout.m1[4,9] = openBracket; layout.m1[4,10] = closeBracket;
    layout.m1[5,8:10] = varList.m

    e$rhs.equation = character(0)
    addToEquation = function(newAddition){
        if(svalue(covariateTxt) != ""){

          e$rhs.equation = strsplit(svalue(covariateTxt), " ")[[1]]
          e$rhs.equation = c(e$rhs.equation, newAddition)
          svalue(covariateTxt) = paste(e$rhs.equation, collapse = " ")

        }else svalue(covariateTxt) = newAddition
    }
    addButton = gbutton("Add to Model", handle = function(h,...){addToEquation(svalue(varList.m))})

    e$listOfModels = "Current model not yet chosen"
    names(e$listOfModels) =  "        - "
    e$listOfDroppedObs = list()
    e$listOfDroppedObs[[1]] = numeric(0)
    e$currentModel = ""
    e$currentModelIndex = 1
    currentModelLabel = glabel("Current model not yet chosen")
    #font(currentModelLabel) <- list(weight="bold", family = "normal")




    modelChooser = gcombobox(names(e$listOfModels),selected = 1, handler = function(h,...){
                                if(!is.null(svalue(h$obj, index = TRUE)))
                                  e$currentModelIndex = svalue(h$obj, index = TRUE)
                                #if(is.null(e$currentModelIndex)) e$currentModelIndex = 1

                                if(length(e$listOfDroppedObs[[e$currentModelIndex]]) == 0)
                                  svalue(currentModelLabel) = e$listOfModels[e$currentModelIndex]
                                else{

                                  svalue(currentModelLabel) = gsub('\\n+', "", paste(e$listOfModels[e$currentModelIndex], "with dropped observations", paste(e$listOfDroppedObs[[e$currentModelIndex]],collapse = " , ")), perl = TRUE)
                                }
                             })




    saveButton = gbutton("Save Model", handler = function(h,...){
      if(!e$saveModelWinOpened){
        e$saveModelWinOpened = TRUE
        saveModelWin = gwindow("Save", height = 45, width = 100, cont = TRUE, parent = modellingWin, icon = "alert")
        addhandlerunrealize(saveModelWin, handler = function(h,...){e$saveModelWinOpened = FALSE; dispose(saveModelWin)})
        gp = ggroup(horizontal = FALSE, cont = saveModelWin)
        saveGp = ggroup(horizontal = TRUE)
        lbl1 = glabel("Save model as :")
        font(lbl1) <- list(weight="bold", family = "normal")
        nameTxt = gtext( paste("model",length(e$listOfModels),sep="_"), width = 85, height = 40)
        queryGp = ggroup(horizontal = TRUE)
        lbl2 = glabel("Set as current.model?")
        font(lbl2) <- list(weight="bold", family = "normal")
        lbl2checkBox = gcheckbox("", checked = TRUE)

        saveButtonInside = gbutton(". SAVE .", handler = function(h,...){
                        e$listOfModels = c(e$listOfModels, x = paste(c("lm(", gsub('\\n+', "", svalue(responseTxt), perl = TRUE), "~", gsub('\\n+', "", svalue(covariateTxt), perl = TRUE), ")"), collapse = " "))
                        names(e$listOfModels)[length(names(e$listOfModels))] = gsub('\\n+', "", svalue(nameTxt), perl = TRUE)
                        e$listOfDroppedObs[[length(names(e$listOfModels))]] = numeric(0)

                        if(svalue(lbl2checkBox)){
                          modelChooser[] = names(e$listOfModels)
                          svalue(modelChooser) = names(e$listOfModels)[length(e$listOfModels)]
                          e$currentModelIndex = svalue(modelChooser, index = TRUE)
                        }else{
                          i = svalue(modelChooser, index = TRUE)      # this works so e$currentModelIndex seems to be redundant
                          modelChooser[] =  names(e$listOfModels)
                          svalue(modelChooser, index = TRUE) = i
                          #e$currentModelIndex = i
                        }

                        e$saveModelWinOpened = FALSE
                        dispose(saveModelWin)
                     })

        add(saveGp,lbl1)
        add(saveGp,nameTxt)   # expand = TRUE
        add(queryGp, lbl2)
        add(queryGp, lbl2checkBox)
        add(queryGp, saveButtonInside) # expand = TRUE
        add(gp, saveGp)
        add(gp, queryGp)

      }
    })

    layout.m1[5,11] = addButton
    #"gWidgetsRGtk2-rarrow"
    layout.m1[6,1] = responseTxt#responseList.m
    layout.m1[6,2] = tilda
    layout.m1[6,3:10] = covariateTxt
    #layout.m1[6,11] = saveButton
    layout.m1[7:11,8:11] = saveButton

    layout.m1[6,11] = gbutton(" Drop Last ", handler = function(h,...){
          if(svalue(covariateTxt) != ""){
            e$rhs.equation = strsplit(svalue(covariateTxt), " ")[[1]]
            e$rhs.equation = e$rhs.equation[-length(e$rhs.equation)]
            svalue(covariateTxt) = paste(e$rhs.equation, collapse = " ")
          }
        })

    fitLabel = glabel("Choose current.model :")

    font(fitLabel) <- list(weight="bold", family = "normal")

    layout.m2 = glayout()
    layout.m2[1,1:2] = fitLabel
    layout.m2[1,3:5] = modelChooser
    layout.m2[1,6] = gbutton("Fit Model", handler = function(h,...){getModelSummary();getModelAnova()})
    #layout.m2[1,6:10] = currentModelLabel  <- do not include in the layout because it makes no sense

    add(layoutGp, layout.m1)
    add(layoutGp, layout.m2) # remove if necessary and have everything in the first layout
    gseparator(horizontal = TRUE, container = layoutGp)
    add(layoutGp, currentModelLabel)
    gseparator(horizontal = TRUE, container = layoutGp)

    toolbar = gtoolbar(tblist, expand = TRUE)
    toolbar2 = gtoolbar(tblist2, expend = TRUE)
    addSpace(layoutGp, 5, horizontal = FALSE)
    add(layoutGp, toolbar, expand = FALSE)

    #add(layoutGp, toolbar2) <---------------------------------------------------------------------------- THE SECOND TOOLBAR

    outputLabel = glabel("OUTPUT", expand = TRUE)
    font(outputLabel) <- list(weight="bold", family = "normal")
    outputTxt = gtext("")
    #add(layoutGp , outputLabel)
    add(layoutGp, outputTxt, expand = TRUE)

    getModelSummary = function(){

      modelIndex = svalue(modelChooser, index = TRUE)

      if(modelIndex != 1){

       	options(show.error.messages = FALSE)

        result = try(eval(parse(text = paste("with(tag(e$obj, \"dataSet\"), summary(", e$listOfModels[modelIndex], "))", collapse = ""))))
        if(class(result)[1] == "try-error")
          gmessage(title = "ERROR", message = "No output produced.\nCheck current model for errors", icon = "error", cont = TRUE, parent = modellingWin)
        else{
          insert(outputTxt, paste("> summary(", svalue(modelChooser),  ")", sep = ""), font.attr=c(style = "monospace", color = "black", sizes="medium"))
          add(outputTxt, capture.output(eval(result)), font.attr=c(style = "monospace", color = "blue", sizes="medium"))
          add(outputTxt, "----------------------------------------------------------------------------------", font.attr=c(style = "monospace", color = "black", sizes="medium"))
        }

        options(show.error.messages = TRUE)

      }else gmessage(title = "ERROR", message = "Select a model first then try again", icon = "error", cont = TRUE, parent = modellingWin)

    }

    getModelAnova = function(){

      modelIndex = svalue(modelChooser, index = TRUE)

      if(modelIndex != 1){

       	options(show.error.messages = FALSE)

        result = try(eval(parse(text = paste("with(tag(e$obj, \"dataSet\"), anova(", e$listOfModels[modelIndex], "))", collapse = ""))))
        if(class(result)[1] == "try-error")
          gmessage(title = "ERROR", message = "No output produced.\nCheck current model for errors", icon = "error", cont = TRUE, parent = modellingWin)
        else{
          insert(outputTxt, paste("> anova(", svalue(modelChooser),  ")", sep = ""), font.attr=c(style = "monospace", color = "black", sizes="medium"))
          add(outputTxt, capture.output(eval(result)), font.attr=c(style = "monospace", color = "black", sizes="medium"))
          add(outputTxt, "----------------------------------------------------------------------------------", font.attr=c(style = "monospace", color = "black", sizes="medium"))
        }

        options(show.error.messages = TRUE)

      }else gmessage(title = "ERROR", message = "Select a model first then try again", icon = "error", cont = TRUE, parent = modellingWin)

    }

    getAIC = function(){

      modelIndex = svalue(modelChooser, index = TRUE)

      if(modelIndex != 1){

       	options(show.error.messages = FALSE)

        result = try(eval(parse(text = paste("with(tag(e$obj, \"dataSet\"), AIC(", e$listOfModels[modelIndex], "))", collapse = ""))))
        if(class(result)[1] == "try-error")
          gmessage(title = "ERROR", message = "No output produced.\nCheck current model for errors", icon = "error", cont = TRUE, parent = modellingWin)
        else{
          insert(outputTxt, paste("> AIC(", svalue(modelChooser),  ")", sep = ""), font.attr=c(style = "monospace", color = "black", sizes="medium"))
          insert(outputTxt, capture.output(eval(result)), font.attr=c(style = "monospace", color = "black", sizes="medium"))
          insert(outputTxt, "----------------------------------------------------------------------------------", font.attr=c(style = "monospace", color = "black", sizes="medium"))
        }

        options(show.error.messages = TRUE)

      }else gmessage(title = "ERROR", message = "Select a model first then try again", icon = "error", cont = TRUE, parent = modellingWin)

    }

    getBIC = function(){
      modelIndex = svalue(modelChooser, index = TRUE)

      if(modelIndex != 1){

       	options(show.error.messages = FALSE)

        result = try(eval(parse(text = paste("with(tag(e$obj, \"dataSet\"), AIC(", e$listOfModels[modelIndex], ",k = log(nrow(tag(e$obj, \"dataSet\")))))", collapse = ""))))
        if(class(result)[1] == "try-error")
          gmessage(title = "ERROR", message = "No output produced.\nCheck current model for errors", icon = "error", cont = TRUE, parent = modellingWin)
        else{
          insert(outputTxt, paste("> AIC(", svalue(modelChooser),  ", k = log(", nrow(tag(e$obj, "dataSet")),"))", sep = ""), font.attr=c(style = "monospace", color = "black", sizes="medium"))
          insert(outputTxt, capture.output(eval(result)), font.attr=c(style = "monospace", color = "black", sizes="medium"))
          insert(outputTxt, "----------------------------------------------------------------------------------", font.attr=c(style = "monospace", color = "black", sizes="medium"))
        }

        options(show.error.messages = TRUE)

      }else gmessage(title = "ERROR", message = "Select a model first then try again", icon = "error", cont = TRUE, parent = modellingWin)

    }

    getVIFs = function(){
      modelIndex = svalue(modelChooser, index = TRUE)

      if(modelIndex != 1){

       	options(show.error.messages = FALSE)

        result = try(eval(parse(text = paste("with(tag(e$obj, \"dataSet\"), vif(", e$listOfModels[modelIndex], "))", collapse = ""))))
        if(class(result)[1] == "try-error")
          gmessage(title = "ERROR", message = "No output produced.\nCheck current model for errors", icon = "error", cont = TRUE, parent = modellingWin)
        else{
          insert(outputTxt, paste("> vif(", svalue(modelChooser),  ")", sep = ""), font.attr=c(style = "monospace", color = "black", sizes="medium"))
          insert(outputTxt, capture.output(eval(result)), font.attr=c(style = "monospace", color = "black", sizes="medium"))
          insert(outputTxt, "----------------------------------------------------------------------------------", font.attr=c(style = "monospace", color = "black", sizes="medium"))
        }

        options(show.error.messages = TRUE)

      }else gmessage(title = "ERROR", message = "Select a model first then try again", icon = "error", cont = TRUE, parent = modellingWin)


    }

    getBasicPlots = function(){


      modelIndex = svalue(modelChooser, index = TRUE)

      if(modelIndex != 1){

       	options(show.error.messages = FALSE)

        result = try(eval(parse(text = paste("with(tag(e$obj, \"dataSet\"),", e$listOfModels[modelIndex], ")", collapse = ""))))
        if(class(result)[1] == "try-error")
          gmessage(title = "ERROR", message = "No output produced.\nCheck current.model for errors", icon = "error", cont = TRUE, parent = modellingWin)
        else{
          x11()
          plot.new()
          par(mfrow = c(2,2))
          plot(eval(parse(text = paste("with(tag(e$obj, \"dataSet\"),", e$listOfModels[modelIndex], ")", collapse = ""))))
        }

        options(show.error.messages = TRUE)

      }else gmessage(title = "ERROR", message = "Select a model first then try again", icon = "error", cont = TRUE, parent = modellingWin)





    }




    getScatterplotMatrix = function(){

      modelIndex = svalue(modelChooser, index = TRUE)

      if(modelIndex != 1){

        names_list = names(tag(e$obj, "dataSet"))
        logical_list = logical(length(names_list))
        for(i in 1:length(names_list))
          logical_list[i] = grepl(names_list[i], e$listOfModels[modelIndex], ignore.case = FALSE, extended = TRUE, perl = FALSE, fixed = FALSE, useBytes = FALSE)

        x11() # This will need to be changed in a mac
        pairs(tag(e$obj, "dataSet")[,logical_list])

      }else gmessage(title = "ERROR", message = "Select a model first then try again", icon = "error", cont = TRUE, parent = modellingWin)

    }

    getEffectsPlots = function(){

      modelIndex = svalue(modelChooser, index = TRUE)

      if(modelIndex != 1){

       	options(show.error.messages = FALSE)

        result = try(eval(parse(text = paste("with(tag(e$obj, \"dataSet\"),", e$listOfModels[modelIndex], ")", collapse = ""))))
        if(class(result)[1] == "try-error")
          gmessage(title = "ERROR", message = "No output produced.\nCheck current.model for errors", icon = "error", cont = TRUE, parent = modellingWin)
        else{

          fit = substr(e$listOfModels[modelIndex], 1, nchar(e$listOfModels[modelIndex])-1)
          fit = paste(fit, ", data = tag(e$obj, \"dataSet\"))", collapse = "")
          x11()
          plot(eval(parse(text = paste("allEffects(", fit, ")", collapse = ""))), ask=FALSE)

        }

        options(show.error.messages = TRUE)

      }else gmessage(title = "ERROR", message = "Select a model first then try again", icon = "error", cont = TRUE, parent = modellingWin)
    # this needs to be checked again  can we follow the same thing as the other handlers // a lot  of repetition

    }

    dropObs = function(){
      modelIndex = svalue(modelChooser, index = TRUE)
      if(modelIndex != 1){

        dropObsWin = gwindow("Drop Observations", cont = TRUE, parent = modellingWin)
        dropObsMainGp = ggroup(cont = dropObsWin, horizontal = FALSE)
        dropObsSecondaryGp = ggroup(cont = dropObsMainGp)
        #addSpring(dropObsSecondaryGp, horizontal = FALSE)
        droplt = glayout()
        glbl1 = glabel("Current Model : ", cont = dropObsSecondaryGp)
        font(glbl1) <- list(weight="bold", family = "normal")
        glbl2 = glabel(svalue(currentModelLabel), cont = dropObsSecondaryGp, expand = TRUE)

        add(dropObsMainGp, gseparator(horizontal = TRUE))

        glbl3 = glabel("Observations to be dropped from the current model :")
        font(glbl3) <- list(weight="bold", family = "normal")
        gt = gtext("eg:  1, 86, 7", width = 120, height = 25)
        droplt[2,1] = glbl3
        #droplt[3,1] = glabel("()")
        droplt[2,2:3] = gt

        dropObsTertiaryGp = ggroup()
        lbl1 = glabel("Save model as :", cont = dropObsTertiaryGp)
        font(lbl1) <- list(weight="bold", family = "normal")
        nameTxt = gtext(paste(svalue(modelChooser), ".obsDropped",sep=""), cont = dropObsTertiaryGp)

        dropObsFourthGp = ggroup()
        lbl2 = glabel("Set as current.model?", cont = dropObsFourthGp)
        font(lbl2) <- list(weight="bold", family = "normal")
        lbl2checkBox = gcheckbox("", checked = TRUE, cont = dropObsFourthGp)
        addSpring(dropObsFourthGp, horizontal = TRUE)

        is.wholenumber = function(x, tol = .Machine$double.eps^0.5)  abs(x - round(x)) < tol

        saveButtonInDropGp = gbutton(". SAVE .", cont = dropObsFourthGp,  handler = function(h,...){
                        print(" save handler")
                        #enabled(modelChooser) = FALSE
                        e$listOfModels = c(e$listOfModels, x = e$listOfModels[length(e$listOfModels)])
                        names(e$listOfModels)[length(names(e$listOfModels))] = gsub('\\n+', "", svalue(nameTxt), perl = TRUE)  #what if the user's keep it blank?

                        x = getDroppedObs(gsub('\\n+', "", svalue(gt), perl = TRUE))
                        e$listOfDroppedObs[[length(names(e$listOfModels))]] = unique(c(e$listOfDroppedObs[[svalue(modelChooser, index = TRUE)]], round(x[is.wholenumber(x)])))

                        #enabled(modelChooser) = TRUE
                        if(svalue(lbl2checkBox)){
                          modelChooser[] = names(e$listOfModels)
                          svalue(modelChooser) = names(e$listOfModels)[length(e$listOfModels)]
                          e$currentModelIndex = svalue(modelChooser, index = TRUE)
                        }else{
                          i = svalue(modelChooser, index = TRUE)      # this works so e$currentModelIndex seems to be redundant
                          modelChooser[] =  names(e$listOfModels)
                          svalue(modelChooser, index = TRUE) = i
                          e$currentModelIndex = i
                        }

                        e$saveModelWinOpened = FALSE      #------------------------------------****************************** CHANGE THIS

                        dispose(dropObsWin)
                     })

        visible(droplt) = TRUE
        add(dropObsMainGp, droplt)
        add(dropObsMainGp, dropObsTertiaryGp)
        add(dropObsMainGp, dropObsFourthGp)



      }else
        gmessage(title = "ERROR", message = "Select a model first then try again", icon = "error", cont = TRUE, parent = modellingWin)

    }

    getDroppedObs = function(charString){

      x = strsplit(charString, split = ",", perl = TRUE)
      y = strsplit(x[[1]], " +")
      z = character(0)
      for(i in 1:length(y))
        z = c(z,y[[i]])

      z = na.omit(as.numeric(unique(z)))     # should try to remove Inf ?
      z = z[!is.nan(z)]
      z = z[!is.infinite(z)]
    }

    makePredictions = function(){

      predictionsWin = gwindow("Prediction", parent = modellingWin)
      predictionsMain = ggroup(horizontal = FALSE, cont = predictionsWin, expand = TRUE)
      addSpace(predictionsMain, 10, horizontal = FALSE)
      lbl1 = glabel(paste("Current Model :", e$listOfModels[svalue(modelChooser, index = TRUE)]), cont = predictionsMain)
      font(lbl1) <- list(weight="bold", family = "normal")
      addSpace(predictionsMain, 10, horizontal = FALSE)
      lbl2 = glabel("Type expressions needed for prediction and submit the command", cont = predictionsMain)
      font(lbl2) <- list(weight="bold", family = "normal")
      lbl3 = glabel("Submit one expression at a time", cont = predictionsMain)
      addSpace(predictionsMain, 5, horizontal = FALSE)
      e$predictionsText = gtext(cont = predictionsMain)
      submitButtGroup = ggroup(cont = predictionsMain)
      addSpring(submitButtGroup)
      submitButt = gbutton("Submit", handler = function(h,...) submitExpression())
      add(submitButtGroup, submitButt)
      e$outputText = gtext(cont = predictionsMain, expand = TRUE)
      helpButtGroup = ggroup(cont = predictionsMain)
      addSpring(helpButtGroup)
      helpButt = gbutton(" Help ", handler = function(h,...){})  # NEED TO ADD A SCREEN CAP IMAGE FOR HELP
      add(helpButtGroup, helpButt)
    }
    submitExpression = function(){

      inputExpression = svalue(e$predictionsText)
      result = try(eval(parse(text = inputExpression)))
        if(class(result)[1] == "try-error")
          gmessage(title = "ERROR", message = "No output produced.\nCheck submitted expression for errors", icon = "error", cont = TRUE, parent = predictionsWin)
        else
          insert(e$outputText, capture.output(eval(result)), font.attr=c(style = "monospace", color = "black", sizes="medium"))

    }
  }
  
  #

iNZight = function(container=NULL) {

  dynamicWarning = "Editing values doesn't work with dynamic data"

################################################################################
################################################################################


# Setting up the layout of the GUI

  if(is.null(container))
    e$win = gwindow("iNZight", visible=TRUE, width = 870, height = 600)

  g = gpanedgroup(cont = e$win, expand = TRUE)
  e$obj = g
  e$gp1 = ggroup(horizontal = FALSE, container = g, expand = TRUE) # Left side group
  gp2 = ggroup(horizontal = FALSE, container = g, expand = TRUE)   # Right side group

  tag(e$obj,"dropHandlers") <- list()


# Setting up the menu bar in the top left hand corner

  defHandler = function(h,...) gmessage("Not Implemented Yet", parent = e$win)

  mbl1 = list("Data IN/OUT"       = list("Import Data" = list(handler = function(h,...) e$fileReader(), icon = "symbol_diamond"),
                                         "Export Data" = list(handler = function(h,...) e$fileWriter(), icon = "symbol_square")),
             "Filter Data" = list("Select Cases" = list(handler = function(h,...){if(!e$filterDataWinOpened) e$filterData()}, icon = "symbol_diamond"),
                             "Restore Dataset" = list(handler = function(h,...) e$getOriginalData(), icon = "symbol_square")),
             "Manipulate Variables" = list(
                                      "Convert to Categorical" = list(handler = function(h,...){if(!e$convertWinOpened)e$convertToFactor()}, icon = "symbol_diamond"),
                                      "Transform Variables" = list(handler = function(h,...){if(!e$transformWinOpened) e$transformHandler()}, icon = "symbol_square"),
                                      "Collapse Levels" = list(handler = function(h,...){if(!e$collapseWinOpened) e$collapseHandler()}, icon = "symbol_dntriangle"),
                                      "Reorder Levels" = list(handler = function(h,...){if(!e$reorderWinOpened)e$reorderLevels()}, icon ="symbol_dot"),
                                      "Rename Levels" = list(handler = function(h,...){if(!e$renameLWinOpened)e$renameLevels()}, icon ="symbol_star"),
                                      "Combine Categorical Variables" = list(handler = function(h,...){if(!e$combineWinOpened)e$combineFactors()}, icon = "symbol_circle"),
                                      "Create New Variables" = list(handler = function(h,...){if(!e$newVariableWinOpened)e$newVariable()}, icon ="symbol_square"),
                                      "Form Class Intervals" = list(handler = function(h,...){if(!e$binNumericWinOpened)e$binNumeric()}, icon ="symbol_diamond"),
                                      "Rename Variables" = list(handler = function(h,...){if(!e$renameVWinOpened)e$renameVariables()}, icon ="symbol_cross"),
                                      "Standardise Variables" = list(handler = function(h,...){if(!e$standardWinOpened)e$standardVariable()}, icon = "symbol_dntriangle")),

             "Trash" = list("Trash Variables" = list(handler = function(h,...){if(!e$trashWinOpened) e$trashVar()}, icon = "symbol_diamond"))
             )

  mbl2 = list("Advanced" = list("3D Scatter Plot" = list(handler = function(h,..)e$plot3D(), icon = "symbol_diamond"),
                                "Model Fitting" = list(handler = function(h,...) e$modelFitting(), icon = "symbol_square"),
                                "Scatter Plot Matrix" = list(handler = function(h,...){if(!e$scatterPlotWinOpened) e$scatterPlotMatrix(h,...)}, icon = "symbol_circle"))
             )

  mb1 = gmenu(mbl1, cont = e$gp1)
  mb2 = gmenu(mbl2, cont = e$gp1)


# Setting up the group for the buttons to switch between data/variable list views

  viewGroup = ggroup()
  addSpring(viewGroup)
  e$dataView = gbutton("View Data Set", handler = function(h,...) e$viewData(h,...))
  e$listView = gbutton("View Variables", handler = function(h,...) e$viewList(h,...))


  font(e$dataView) <- list(weight="bold", family = "normal", color = "navy")
  font(e$listView) <- list(weight="bold", family = "normal", color = "navy")


  add(viewGroup, e$dataView)
  add(viewGroup, e$listView)
  add(e$gp1, viewGroup)

# Setting up group to either embed the data frame or present a list of variables

  e$dataGp =  ggroup(horizontal = TRUE, expand = TRUE)
  add(e$gp1, e$dataGp, expand = TRUE)#, width = 25)


# At start-up an (near)empty dataframe is embedded

  #dat = data.frame(read.csv("mySample500.csv", header = TRUE, na.strings = c("NULL","NA","N/A","#N/A","")))
  #tag(e$obj,"dataSet") = dat

  #dframe = data.frame(Aids2)

#-------------------------------------------------------------------------------

#  dframe = data.frame(read.csv("ReducedDataSet2.csv", header = TRUE, na.strings = c("NULL","NA","N/A","#N/A","")))
#
#
#  for(i in 1:ncol(dframe)){
#    dframe[,i] = replace(dframe[,i],which(((dframe[,i] %in% c("NULL","NA","N/A","#N/A",""," ",NA,"<NA>"))) || (nchar(dframe[,i]) == 0) || eval(parse(text = dframe[,i]))== NA), NA)
#    if(is.factor(dframe[,i])) dframe[,i] = factor(dframe[,i], exclude = c(NA, "<NA>", "NA", ""))
#  }
#
#  tag(e$obj,"dataSet") = na.omit(dframe)

#-------------------------------------------------------------------------------

  tag(e$obj,"dataSet") = data.frame(empty = " ")
  tag(e$obj,"originalDataSet") = data.frame(empty = " ")
#-------------------------------------------------------------------------------

  e$dataSt = gdf(tag(e$obj,"dataSet"), width = 20, height = 50, expand = TRUE)
  add(e$dataGp, e$dataSt, expand = TRUE)

  e$dataList1 = NULL
  e$dataList2 = NULL
# Setting up the labels and drag and drop places on the bottom right section

  tbl = glayout(expand = FALSE)

  tbl[3,1, anchor = c(0,0)] = glabel(" Variable 1 :")
  tbl[5,1, anchor = c(0,0)] = glabel(" Variable 2 :")
  tbl[7,1, anchor = c(0,0)] = glabel(" subset by  :")

  #tbl[2,2:5] = gseparator(horizontal = TRUE, expand = TRUE)
  #tbl[4,2:5] = gseparator(horizontal = TRUE, expand = TRUE)
  #tbl[6,2:5] = gseparator(horizontal = TRUE)
  #tbl[8,2:5] = gseparator(horizontal = TRUE)
  #tbl[2:8,2] = gseparator(horizontal = FALSE)
  #tbl[2:8,5] = gseparator(horizontal = FALSE)

  yVar = glabel("Drop name here")
  font(yVar) <- list(weight="bold", family = "normal")
  tag(e$obj,"yVarData") <- NULL
  tbl[5,3, anchor = c(0,0)] = yVar


  xVar = glabel("Drop name here")
  font(xVar) <- list(weight="bold", family = "normal")
  tag(e$obj,"xVarData") <- NULL
  tbl[3,3, anchor = c(0,0)] = xVar

  groupingVar = glabel("Drop name here")
  font(groupingVar) <- list(weight="bold", family = "normal")
  tag(e$obj,"groupingVarData") <- NULL
  tbl[7,3, anchor = c(0,0)] = groupingVar

  tbl[3,7, anchor = c(0,0)] = gbutton("clear", handler=function(h,...) clear1())
  tbl[5,7, anchor = c(0,0)] = gbutton("clear", handler=function(h,...) clear2())
  tbl[7,7, anchor = c(0,0)] = gbutton("clear", handler=function(h,...) clear3())




  add(e$gp1,tbl,expand = FALSE)
  visible(tbl) <- TRUE


# Group for first slider

  e$firstSliderGp = ggroup(horizontal = FALSE)
  add(e$gp1,e$firstSliderGp)

# Group for label and drag and drop box for the second subsetting variable

  tbl2 = glayout(expand = FALSE)
  tbl2[2,1] = glabel(" subset by  :")

  groupingVar2 = glabel("Drop name here")
  font(groupingVar2) <- list(weight="bold", family = "normal")
  tag(e$obj,"groupingVarData2") <- NULL
  tbl2[2,3] = groupingVar2
  tbl2[2,7, anchor = c(0,0)] = gbutton("clear", handler=function(h,...) clear4())

  #enabled(groupingVar2) = FALSE
  #tbl2[1:3,3] = gseparator(horizontal = FALSE)
  #tbl2[1:3,7] = gseparator(horizontal = FALSE)
  #tbl2[1,3:7] = gseparator(horizontal = TRUE)
  #tbl2[3,3:7] = gseparator(horizontal = TRUE)

  add(e$gp1,tbl2,expand = FALSE)
  visible(tbl2) <- TRUE

  e$secondSliderGp = ggroup(horizontal = FALSE, expand = FALSE)
  add(e$gp1,e$secondSliderGp, expand = FALSE)



################################################################################
################################################################################


# Setting up the plot notebook (each new plot will appear as a new leaf)

  nb = gnotebook(container = gp2, expand = TRUE)

  gg = ggraphics(container = nb, label="plot", expand = TRUE)


  addhandlerrightclick(nb, handler = function(h, ...) {

                    saveWin = gwindow("Save Plot", height = 50, width = 120, cont = TRUE, parent = e$win)
                    saveMain = ggroup(cont = saveWin)
                    savelayout = glayout()
                    lbl1 = glabel("Name of plot :")
                    font(lbl1) = list(weight = "bold")
                    lbl2 = glabel("Type of file :")
                    font(lbl2) = list(weight = "bold")
                    savelayout[2,1, anchor = c(-1,0)] = lbl1
                    savelayout[2,2, anchor = c(-1,0)] = (saveTxt = gtext("My Plot", width = 110, height = 20))
                    savelayout[4,1, anchor = c(-1,0)] = lbl2
                    savelayout[4,2, anchor = c(-1,0)] = (saveList = gdroplist(c("EMF","JPEG","PNG","BMP"), selected = 2))
                    savelayout[6,1:2, anchor = c(0,0)] = (savePlotButton = gbutton(" - SAVE - ",
                              handler = function(h,...){

                                plotName = gsub(pattern = '\\n+', replacement = "", svalue(saveTxt), perl = TRUE)

                                if(plotName == "") plotName = "My Plot"

                                if(svalue(saveList) == "EMF"){
                                  dev.copy(win.metafile, file = paste(plotName,".emf",collapse =""), width = 9)
                                  dev.off()


                                }else if(svalue(saveList) == "JPEG"){
                                  dev.copy(jpeg, file = paste(plotName,".jpg",collapse =""), width = 650, height = 650)
                                  dev.off()
                                }else if(svalue(saveList) == "PNG"){
                                  dev.copy(png, file = paste(plotName,".png",collapse =""), width = 650, height = 650)
                                  dev.off()
                                }else if(svalue(saveList) == "BMP"){
                                  dev.copy(bmp, file = paste(plotName,".bmp",collapse =""),width = 650, height = 650)
                                  dev.off()
                                }
                                dispose(saveWin)
                              }))


                    font(savePlotButton) = list(weight = "bold", color = "navy")
                    add(saveMain, savelayout)
                    visible(savelayout) = TRUE


#    ginput("Save plot as:", text="plot 1", title="Input", icon = "question",
#            handler = function(h,...){
#             plotName = ifelse(h$input == "", "plot", h$input)
#             names(nb)[svalue(nb)] = plotName
#             dev.copy(win.metafile, file = paste(plotName,".emf",collapse =""), width = 8)
#
#             \dev.copy(pdf, file = paste(plotName,".pdf",collapse =""), width = 8)
#             dev.off()
#
#            }, parent = e$win)
  })

# ------------------------------------------------------------------------------


# ------------------------------------------------------------------------------
  tblist <- list()
  tblist$New$handler <- function(h,...) add(nb, ggraphics(expand = TRUE),label = "plot")
  tblist$New$icon <- "newplot"
  tblist$NamePlot$handler <- function(h,...)
      ginput("Name Plot as:", text="plot 1", title="Input", icon = "question", parent = e$win,
            handler = function(h,...)names(nb)[svalue(nb)] = h$input)
  tblist$NamePlot$icon <- "rename"
  tblist$RefreshPlot$handler <- function(h,...) updatePlot()
  tblist$RefreshPlot$icon <- "refresh"
  tblist$NamePlot$icon <- "rename"
  tblist$tmp1$separator <- TRUE
  tblist$Save$handler <- function(h,...){



                    saveWin = gwindow("Save Plot", height = 50, width = 120, cont = TRUE, parent = e$win)
                    saveMain = ggroup(cont = saveWin)
                    savelayout = glayout()
                    lbl1 = glabel("Name of plot :")
                    font(lbl1) = list(weight = "bold")
                    lbl2 = glabel("Type of file :")
                    font(lbl2) = list(weight = "bold")
                    savelayout[2,1, anchor = c(-1,0)] = lbl1
                    savelayout[2,2, anchor = c(-1,0)] = (saveTxt = gtext("My Plot", width = 110, height = 20))
                    savelayout[4,1, anchor = c(-1,0)] = lbl2
                    savelayout[4,2, anchor = c(-1,0)] = (saveList = gdroplist(c("EMF","JPEG","PNG","BMP"), selected = 2))
                    savelayout[6,1:2, anchor = c(0,0)] = (savePlotButton = gbutton(" - SAVE - ",
                              handler = function(h,...){

                                plotName = gsub(pattern = '\\n+', replacement = "", svalue(saveTxt), perl = TRUE)

                                if(plotName == "") plotName = "My Plot"

                                if(svalue(saveList) == "EMF"){
                                  dev.copy(win.metafile, file = paste(plotName,".emf",collapse =""), width = 9)
                                  dev.off()
                                  add(nb, ggraphics(expand = TRUE),label = "plot")
                                  updatePlot()
                                }else if(svalue(saveList) == "JPEG"){
                                  dev.copy(jpeg, file = paste(plotName,".jpg",collapse =""), width = 650, height = 650)
                                  dev.off()
                                  add(nb, ggraphics(expand = TRUE),label = "plot")
                                  updatePlot()
                                }else if(svalue(saveList) == "PNG"){
                                  dev.copy(png, file = paste(plotName,".png",collapse =""), width = 650, height = 650)
                                  dev.off()
                                  add(nb, ggraphics(expand = TRUE),label = "plot")
                                  updatePlot()
                                }else if(svalue(saveList) == "BMP"){
                                  dev.copy(bmp, file = paste(plotName,".bmp",collapse =""),width = 650, height = 650)
                                  dev.off()
                                  add(nb, ggraphics(expand = TRUE),label = "plot")
                                  updatePlot()
                                }
                                dispose(saveWin)
                              }))


                    font(savePlotButton) = list(weight = "bold", color = "navy")
                    add(saveMain, savelayout)
                    visible(savelayout) = TRUE





#            handler = function(h,...){


#             plotName = ifelse(h$input == "", "plot", h$input)
#             dev.copy(win.metafile, file = paste(plotName,".emf",collapse =""), width = 8)    # EMF instead of PDF
#             #\dev.copy(pdf, file = paste(plotName,".pdf",collapse =""), width = 8)
#             dev.off()
#            }, parent = e$win)
  }
  tblist$Save$icon <- "save"
  tblist$Close$handler <- function(h,...){dispose(nb);if(length(nb)==0) add(nb, ggraphics(expand = TRUE),label = "plot")}
  tblist$Close$icon <- "close"
  tblist$tmp2$separator <- TRUE


  # Choosing plots and adding to plots
  e$choosePlot = gdroplist(c("Default", "-----------------", "dot chart", "box plot", "dot + box", "histogram", "pie chart", "scatter plot", "scatt.plot.matrix"), selected = 1)
  #tblist$drpList = e$choosePlot

  # Opens a new window that changes depending on the types and number of variables that have already been dragged and dropped
  # If it is 2 continuous variables, it allows students to draw smoothers and regression lines.
  tblist$Button = gbutton("Add to Plot", border=TRUE, handler = function(h, ...){
    if(e$dndDisabled || e$addToPlotWin)
      gmessage("A window has already been opened", parent = e$win)
    else
      addToPlot()
  })
  tblist$tmp3$separator <- TRUE

  tblist$removeAdditions = gbutton("Remove\nAdditions", handler = function(h,...){e$removeAdditions()})



  tblist$tmp4$separator <- TRUE
  # A toolbar that allows to exit the current plot, to open a new page for a new plot
  # to save plots etc.
  tblist$addInf = gbutton("Inference\nInformation", handler = function(h,...){
                  if(e$dndDisabled || e$inferenceWinOpened)
                    gmessage("A window has already been opened", parent = e$win)
                  else
                    addInferenceInfo()


                  })  # This could either be a button or a menu // need to decide
                 #gmenu(list("Inference\nInformation" = list("Error Bars" = list(handler = function(h,...){}, icon = "symbol_diamond"))))

  tblist$tmp5$separator <- TRUE

  gtoolbar(tblist, cont = gp2)


################################################################################
################################################################################


  e$viewData = function(h, ...){

    if(is.null(tag(e$obj, "dataSet"))){
      gmessage("Please load a new data set (with named columns)", parent = e$win)
    }else{
      if((names(tag(e$obj, "dataSet"))[1] == "empty"))
        gmessage("Please load a new data set", parent = e$win)
      else{

        enabled(h$obj) = FALSE
        e$updateData()
        enabled(e$listView) = TRUE
        e$inDataView = TRUE
      }
    }

  }
# ------------------------------------------------------------------------------
  e$viewList = function(h, ...){
    if(is.null(tag(e$obj, "dataSet"))){
      gmessage("Please load a new data set (with named columns)", parent = e$win)
    }else{
      if(names(tag(e$obj, "dataSet"))[1] == "empty")
        gmessage("Please load a new data set", parent = e$win)
      else{

        enabled(h$obj) = FALSE
        e$updateList()
        enabled(e$dataView) = TRUE
        e$inDataView = FALSE
      }
    }

  }
# ------------------------------------------------------------------------------


  getInferenceSumm = function(){

    if(!e$summaryButtonPressed){

      #if(!e$scatterPlotView){
        inquiryWin = gwindow("Query", width = 80, height =  50, cont = TRUE, parent = e$win)
        inquiryMain = ggroup(container = inquiryWin, horizontal = FALSE)
        addSpace(inquiryMain,5,horizontal=FALSE)
        lbl1 = glabel("Choose Method\n             To Generate Inference :", container = inquiryMain)
        font(lbl1) = list(weight="bold", size = "medium", color = "blue")
        addSpace(inquiryMain,5, horizontal = FALSE)
        infMethod = gradio(c("Normal", "Bootstrap"), selected = 1, handler = function(h,...) e$inferenceMethod = svalue(h$obj), cont = inquiryMain)
        okButton = gbutton(" - OK - ", handler = function(h,...){e$inferenceMethod = svalue(infMethod); showSummary();dispose(inquiryWin)}, cont = inquiryMain, expand = FALSE)
        font(okButton) = list(weight="bold")

      #}else{
        # This is where we do whatever to the scatter plots
      #  showSummary()

      #}
    }
  }

  showSummary = function(h, ...){

    xVarData = tag(e$obj,"xVarData")
    yVarData = tag(e$obj,"yVarData")
    groupingVarData = tag(e$obj,"groupingVarData")

    if(is.null(xVarData))
      gmessage("Drag and drop variables first", title = "ALERT", icon = "warning", parent = e$win)
    else{

      valueX = svalue(xVarData)
      if(!is.null(e$fourthVariable))
        valueX = (valueX[e$fourthVariable == (levels(e$fourthVariable)[e$sliderData2])])

        nameX = svalue(xVar)

      if(is.null(yVarData) && is.null(groupingVarData)){

        eval(parse(text = paste(c(ifelse(e$summaryButtonPressed,"addSumm","showInf"),"(data.frame(\"",nameX,"\" = valueX),\"",nameX,"\", ifelse(all(is.factor(valueX)),'CAT','CONT'), paste(outdir,\"",nameX,"\",sep=''))"),collapse = "")))

      }else if(!(is.null(yVarData)) && is.null(groupingVarData)){

        nameY = svalue(yVar)

        valueY =  svalue(yVarData)
        if(!is.null(e$fourthVariable))
          valueY = (valueY[e$fourthVariable == (levels(e$fourthVariable)[e$sliderData2])])

        vartypes = c(ifelse(all(is.factor(valueX)),'CAT','CONT'), ifelse(all(is.factor(valueY)),'CAT','CONT'))
        eval(parse(text = paste(c(ifelse(e$summaryButtonPressed,"addSumm","showInf"),"(data.frame(\"",nameX,"\" = valueX,\"",nameY,"\" = valueY), c(\"",nameX,"\",\"",nameY,"\"), vartypes, paste(outdir,\"",nameX,"\",sep=''))"), collapse = "")))

      }else if(is.null(yVarData) && !(is.null(groupingVarData))) {

        nameG = svalue(groupingVar)

        valueG = svalue(groupingVarData)

        if(!is.null(e$fourthVariable))
          valueG = (valueG[e$fourthVariable == (levels(e$fourthVariable)[e$sliderData2])])

        if(!is.factor(valueG))
          valueG = convert.to.factor(valueG)
           #

        vartypes = c(ifelse(all(is.factor(valueX)),'CAT','CONT'),'EMPTY','CAT')

        eval(parse(text = paste(c(ifelse(e$summaryButtonPressed,"addSumm","showInf"),"(data.frame(\"",nameX,"\" = valueX,\"",nameG,"\" = valueG), c(\"",nameX,"\",\"",nameG,"\"), vartypes, e$sliderData)"), collapse = "")))


      }else if(!(is.null(yVarData)) && !(is.null(groupingVarData))){

        nameY = svalue(yVar)
        nameG = svalue(groupingVar)

        valueY =  svalue(yVarData)
        if(!is.null(e$fourthVariable))
          valueY = (valueY[e$fourthVariable == (levels(e$fourthVariable)[e$sliderData2])])

        valueG = svalue(groupingVarData)

        if(!is.null(e$fourthVariable))
          valueG = (valueG[e$fourthVariable == (levels(e$fourthVariable)[e$sliderData2])])
        if(!is.factor(valueG))
          valueG = convert.to.factor(valueG)

        vartypes = c(ifelse(all(is.factor(valueX)),'CAT','CONT'), ifelse(all(is.factor(valueY)),'CAT','CONT'), 'CAT')
        eval(parse(text = paste(c(ifelse(e$summaryButtonPressed, "addSumm", "showInf"), "(data.frame(\"",nameX,"\" = valueX,\"",nameY,"\" = valueY,\"",nameG,"\" = valueG), c(\"",nameX,"\",\"",nameY,"\",\"",nameG,"\"), vartypes, e$sliderData)"), collapse = "")))
      }
    }

  }

# Add the Get Summary button

  summaryInferenceGp = ggroup(cont = e$gp1)

  e$summButton = gbutton("Get Summary", handler = function(h,...){ e$summaryButtonPressed = TRUE; e$inferenceButtonPressed = FALSE; showSummary()})
  font(e$summButton) <- list(weight="bold", family = "normal", color = "navy")
  e$inferenceButton = gbutton("Get Inference", handler = function(h,...){ e$summaryButtonPressed = FALSE; e$inferenceButtonPressed = TRUE; getInferenceSumm()})
  font(e$inferenceButton) <- list(weight="bold", family = "normal", color = "navy")
  add(summaryInferenceGp, e$summButton, expand = TRUE)
  #addSpring(summaryInferenceGp)
  add(summaryInferenceGp, e$inferenceButton, expand = TRUE)


  #addSpace(e$gp1, 10, horizontal = FALSE)
  #add(e$gp1, e$summButton, expand = FALSE)
# ------------------------------------------------------------------------------



  addHandlerChanged(xVar,
                    handler = function(h,...) {
                      cat(dynamicWarning,"\n")
                      ids = tag(e$obj,"dropHandlers")
                      if(length(ids) > 0) {
                        removehandler(e$obj,ids)
                        tag(e$obj,"dropHandlers") <- list()
                      }
                      if(!is.null(h$e$obj))
                        tag(e$obj, "xVarData") <- svalue(h$e$obj)

                     # update()
                    })
  adddroptarget(xVar,
                handler=function(h, ...) {
                  n = names(tag(e$obj, "dataSet"))
                  if(!e$dndDisabled){
                    if(e$inDataView)
                      tag(e$obj,"xVarData") <- h$dropdata
                    else
                      tag(e$obj,"xVarData") <- ((tag(e$obj, "dataSet"))[,which(n == h$dropdata)])

                    svalue(xVar) <- id(h$dropdata)

                    #updatePlotList()
                    updatePlot()

                    if(is.gdataframecolumn(h$dropdata)) {
                      view.col = h$dropdata
                      id = addHandlerChanged(view.col,
                        signal = "edited",
                        handler=function(h,...) updatePlot()
                        )
                      dropHandlers = tag(e$obj,"dropHandlers")
                      dropHandlers[[length(dropHandlers)+1]] = list(
                                    view.col = view.col,
                                    id = id
                                    )
                      tag(e$obj,"dropHandlers") <- dropHandlers
                    }
                  }
                })
  ## yvar
  addHandlerChanged(yVar,
                    handler = function(h,...) {
                      cat(dynamicWarning,"\n")
                      ids = tag(e$obj,"dropHandlers")
                      if(length(ids) > 0) {
                        removehandler(e$obj,ids)
                        tag(e$obj,"dropHandlers") <- list()
                      }
                      if(!is.null(h$e$obj))
                        tag(e$obj,  "yVarData") <-  svalue(h$e$obj)

                      #update()
                    })
  adddroptarget(yVar,
                handler=function(h, ...) {
                  if(!e$dndDisabled){
                    n = names(tag(e$obj, "dataSet"))
                    if(e$inDataView)
                      tag(e$obj,"yVarData") <- h$dropdata
                    else
                      tag(e$obj,"yVarData") <- ((tag(e$obj, "dataSet"))[,which(n == h$dropdata)])

                    svalue(yVar) <-  id(h$dropdata)

                    #updatePlotList()
                    updatePlot()


                    if(is.gdataframecolumn(h$dropdata)) {
                      view.col = h$dropdata
                      id = addHandlerChanged(view.col,
                        signal = "edited",
                        handler=function(h,...) updatePlot()
                        )
                      dropHandlers = tag(e$obj,"dropHandlers")
                      dropHandlers[[length(dropHandlers)+1]] = list(
                                    view.col = view.col,
                                    id = id
                                    )
                      tag(e$obj,"dropHandlers") <- dropHandlers
                    }
                  }
                })


  addHandlerChanged(groupingVar,
                    handler = function(h,...) {
                      cat(dynamicWarning,"\n")
                      ids = tag(e$obj,"dropHandlers")
                      if(length(ids) > 0) {
                        removehandler(e$obj,ids)
                        tag(e$obj,"dropHandlers") <- list()
                      }
                      if(!is.null(h$e$obj))
                        tag(e$obj,  "groupingVarData") <-  svalue(h$e$obj)
                   #update()



                    })
  adddroptarget(groupingVar,
                handler=function(h, ...) {

                  if(!e$dndDisabled){
                    if(svalue(groupingVar2) != id(h$dropdata)){

                      svalue(groupingVar) <-  id(h$dropdata)

                      n = names(tag(e$obj, "dataSet"))
                      if(e$inDataView)
                        tag(e$obj,"groupingVarData") <- h$dropdata
                      else
                        tag(e$obj,"groupingVarData") <- ((tag(e$obj, "dataSet"))[,which(n == h$dropdata)])



                      if(e$sliderCreated){
                         delete(e$firstSliderGp, e$grpSlider)
                         delete(e$firstSliderGp, e$lbl)
                         e$sliderCreated = FALSE
                      }
                      if(!e$sliderCreated){           ################################################## Need to change this when we force continuous vars to be factors

                          if(is.factor(svalue(tag(e$obj,"groupingVarData")))){
                            if(is.null(e$fourthVariable))
                              e$gpVarLbls = levels(factor(svalue(tag(e$obj,"groupingVarData"))))
                            else
                              e$gpVarLbls = levels(factor(svalue(tag(e$obj,"groupingVarData"))[e$fourthVariable == (levels(e$fourthVariable)[e$sliderData2])]))

                          }else{
                            if(is.null(e$fourthVariable))
                                e$gpVarLbls = levels(convert.to.factor(svalue(tag(e$obj,"groupingVarData"))))
                            else
                                e$gpVarLbls = levels(convert.to.factor((svalue(tag(e$obj,"groupingVarData")))[e$fourthVariable == (levels(e$fourthVariable)[e$sliderData2])]))
                          }
                          e$grpSlider = gslider(from = 0, to = length(e$gpVarLbls), by = 1, handler = function(h,...){tag(e$obj,  "sliderData") = svalue(e$grpSlider,index=FALSE); updatePlot()})
                          add(e$firstSliderGp, e$grpSlider)
                          e$lbl = glabel(paste(c("*",e$gpVarLbls), collapse = "   "))
                          if(sum(nchar(paste(c("*",e$gpVarLbls)))) < 60)
                            add(e$firstSliderGp, e$lbl)
                          tag(e$obj,  "sliderData") = 0
                          e$sliderCreated = TRUE
                          e$sliderData = 0

                      }

                      #updatePlotList()
                      updatePlot()

                      ## now bind to be dynamic *if* a treeviewcolumn
                      if(is.gdataframecolumn(h$dropdata)) {
                        view.col = h$dropdata
                        id = addHandlerChanged(view.col,
                          signal = "edited",
                          handler=function(h,...) updatePlot()
                          )
                        dropHandlers = tag(e$obj,"dropHandlers")
                        dropHandlers[[length(dropHandlers)+1]] = list(
                                      view.col = view.col,
                                      id = id
                                      )
                        tag(e$obj,"dropHandlers") <- dropHandlers

                        }

                    }else{
                      gmessage("STOP! You are trying to use the same variable in both subsetting slots", parent = e$win)
                    }
                  }
                })


  adddroptarget(groupingVar2,
                handler=function(h, ...) {

                  if(!e$dndDisabled){
                    if(svalue(groupingVar) != id(h$dropdata)){
                      n = names(tag(e$obj, "dataSet"))
                      if(e$inDataView)
                        tag(e$obj,"groupingVarData2") <- h$dropdata
                      else
                        tag(e$obj,"groupingVarData2") <- ((tag(e$obj, "dataSet"))[,which(n == h$dropdata)])

                      svalue(groupingVar2) <-  id(h$dropdata)

                      if(e$sliderCreated2){
                         delete(e$secondSliderGp, e$grpSlider2)
                         delete(e$secondSliderGp, e$lbl2)
                         e$sliderCreated2 = FALSE
                      }
                      if(!e$sliderCreated2){           ################################################## Need to change this when we force continuous vars to be factors

                          if(is.factor(svalue(tag(e$obj,"groupingVarData2"))))
                            e$gpVarLbls2 = levels(factor(svalue(tag(e$obj,"groupingVarData2"))))
                          else
                            e$gpVarLbls2 = levels(convert.to.factor(svalue(tag(e$obj,"groupingVarData2"))))

                          e$grpSlider2 = gslider(from = 0, to = length(e$gpVarLbls2), by = 1,
                                         handler = function(h,...){
                                            tag(e$obj,  "sliderData2") = svalue(e$grpSlider2,index=FALSE)
                                            if(!is.null(tag(e$obj,"groupingVarData"))){


                                                #e$groupingVarData = NULL
                                                #tag(e$obj,"groupingVarData") = NULL
                                                #tag(e$obj,  "sliderData") = NULL

                                                oldLevelsNum = length(e$gpVarLbls)
                                                delete(e$firstSliderGp, e$lbl)
                                                fourthVariable = numeric(0)

                                                if((svalue(h$obj, index = TRUE) != 0) && is.factor(svalue(tag(e$obj,"groupingVarData2")))){
                                                  fourthVariable = svalue(tag(e$obj,"groupingVarData2"))
                                                }else if(svalue(h$obj, index = TRUE) != 0){
                                                  fourthVariable = convert.to.factor(svalue(tag(e$obj,"groupingVarData2")))
                                                }

                                                if(is.factor(svalue(tag(e$obj,"groupingVarData")))){
                                                    if(svalue(h$obj, index = TRUE) == 0)
                                                      e$gpVarLbls = levels(factor(svalue(tag(e$obj,"groupingVarData"))))
                                                    else
                                                      e$gpVarLbls = levels(factor((svalue(tag(e$obj,"groupingVarData")))[fourthVariable == (levels(fourthVariable)[svalue(h$obj, index = TRUE)])]))


                                                }else{
                                                    if(svalue(h$obj, index = TRUE) == 0)
                                                      e$gpVarLbls = levels(convert.to.factor(svalue(tag(e$obj,"groupingVarData"))))
                                                    else
                                                      e$gpVarLbls = levels(convert.to.factor((svalue(tag(e$obj,"groupingVarData")))[fourthVariable == (levels(fourthVariable)[svalue(h$obj, index = TRUE)])]))

                                                }
                                                e$lbl = glabel(paste(c("*",e$gpVarLbls), collapse = "   "))
                                                if(sum(nchar(paste(c("*",e$gpVarLbls)))) < 60)

                                                if(oldLevelsNum != length(e$gpVarLbls)){
                                                  e$grpSlider[] = seq(0,length(e$gpVarLbls),1)
                                                }

                                                add(e$firstSliderGp, e$lbl)

                                            }


                                            updatePlot()})



                          add(e$secondSliderGp, e$grpSlider2)
                          e$lbl2 = glabel(paste(c("__",e$gpVarLbls2), collapse = "   "))
                          if(sum(nchar(paste(c("__",e$gpVarLbls2)))) < 60)
                            add(e$secondSliderGp, e$lbl2)
                          tag(e$obj,  "sliderData2") = 0
                          e$sliderCreated2 = TRUE
                          e$sliderData2 = 0

                      }

                      #updatePlotList()
                      updatePlot()

                      ## now bind to be dynamic *if* a treeviewcolumn
                      if(is.gdataframecolumn(h$dropdata)) {
                        view.col = h$dropdata
                        id = addHandlerChanged(view.col,
                          signal = "edited",
                          handler=function(h,...) updatePlot()
                          )
                        dropHandlers = tag(e$obj,"dropHandlers")
                        dropHandlers[[length(dropHandlers)+1]] = list(
                                      view.col = view.col,
                                      id = id
                                      )
                        tag(e$obj,"dropHandlers") <- dropHandlers

                        }

                    }else{
                      gmessage("STOP! You are trying to use the same variable in both subsetting slots", parent = e$win)
                    }
                  }
                })
# ------------------------------------------------------------------------------

  if(!is.null(e$grpSlider)){
    addHandlerChanged(e$grpSlider, handler = function(h,...) { updatePlot()})
  }

  if(!is.null(e$grpSlider2)){
    addHandlerChanged(e$grpSlider2, handler = function(h,...) { updatePlot()})
  }
# ------------------------------------------------------------------------------

#disableMenu = function(wantedIndices){
#    for(i in (1:8)){
#      if(!(i %in% wantedIndices)) enabled(actionsGroup[[i]]) <- FALSE
#      else enabled(actionsGroup[[i]]) <- TRUE
#    }
#}


#sapply(actionsGroup, function(i){ if(!(i %in% wantedIndices)) enabled(i) <- FALSE})}

updatePlot = function(){


    ### get variables
    e$xVarData = tag(e$obj,"xVarData")
    e$yVarData = tag(e$obj,"yVarData")
    e$groupingVarData = tag(e$obj,"groupingVarData")
    e$groupingVarData2 = tag(e$obj,"groupingVarData2") # Check this out further

    plotType = svalue(e$choosePlot)
    e$fourthVariable = NULL
    e$fourthVarName = ""
    if(is.null(plotType)) plotType = "X"

    e$sliderData2 = tag(e$obj,  "sliderData2")

    if(!is.null(e$groupingVarData2)){
      if(e$sliderData2 != 0 && is.factor(svalue(e$groupingVarData2)))
        e$fourthVariable = svalue(e$groupingVarData2)
      else if(e$sliderData2 != 0 && !is.factor(svalue(e$groupingVarData2)))
        e$fourthVariable = convert.to.factor(svalue(e$groupingVarData2))

       e$fourthVarName = svalue(groupingVar2)

    }
    if(!is.null(e$fifthVariable)){
      e$fifthVariableNumeric = NULL

      e$fifthVariableSubset = e$fifthVariable
      if(!is.null(e$fourthVariable))
          e$fifthVariableSubset = e$fifthVariable[e$fourthVariable == (levels(e$fourthVariable)[e$sliderData2])]


      if(!is.factor(e$fifthVariableSubset)){
        e$fifthVariableNumeric = e$fifthVariableSubset
        e$fifthVariableSubset = convert.to.factor(e$fifthVariableSubset)

      }
    }

    if(!is.null(e$segmentVariable)){
      #e$segmentVariableNumeric = NULL

      e$segmentVariableSubset = e$segmentVariable
      if(!is.null(e$fourthVariable))
          e$segmentVariableSubset = e$segmentVariable[e$fourthVariable == (levels(e$fourthVariable)[e$sliderData2])]


      if(!is.factor(e$segmentVariableSubset)){
        #e$fifthVariableNumeric = e$fifthVariableSubset
        e$segmentVariableSubset = convert.to.factor(e$segmentVariableSubset)

      }
    }



    if(!is.null(e$sixthVariable)){

      e$sixthVariableSubset = e$sixthVariable

      if(!is.null(e$fourthVariable))
          e$sixthVariableSubset = e$sixthVariable[e$fourthVariable == (levels(e$fourthVariable)[e$sliderData2])]

#      if(!is.factor(e$sixthVariableSubset))    ------------- THE SIXTH VARIABLE WILL NOT BE A FACTOR.......OR WILL IT? dun dun duuuuuuuun
#        e$sixthVariableSubset = convert.to.factor(e$sixthVariableSubset)


    }



    if(is.null(e$xVarData)) {
      gmessage("Drop data into the first variable slot", parent = e$win)
      return()
    }else{
      e$dotChartView = FALSE
      e$scatterPlotView = FALSE

      valueX =  svalue(e$xVarData)
      if(!is.null(e$fourthVariable))
        valueX = (svalue(e$xVarData)[e$fourthVariable == (levels(e$fourthVariable)[e$sliderData2])])  # 5th and 6th variables should be done similar to this

       nameX = id(e$xVarData)

       if(nameX == "e$xVarData")
          nameX = svalue(xVar)


      vartypes = c(ifelse(all(is.factor(valueX)),'CAT','CONT'))


      if(is.null(e$yVarData) && is.null(e$groupingVarData)) {

       if(vartypes == 'CONT') e$dotChartView = TRUE

       eval(parse(text = paste(c("analysisStep(data.frame(\"",nameX,"\" = valueX),\"",nameX,"\", vartypes, \"",plotType,"\",FALSE)"),collapse = "")))

      }else{

        if(!(is.null(e$yVarData)) && is.null(e$groupingVarData)) {

            valueX =  svalue(e$xVarData)
            if(!is.null(e$fourthVariable))
              valueX = (svalue(e$xVarData)[e$fourthVariable == (levels(e$fourthVariable)[e$sliderData2])])

            valueY =  svalue(e$yVarData)
            if(!is.null(e$fourthVariable))
              valueY = (svalue(e$yVarData)[e$fourthVariable == (levels(e$fourthVariable)[e$sliderData2])])

            nameX = id(e$xVarData)
            nameY = id(e$yVarData)
            if(nameX == "e$xVarData")
              nameX = svalue(xVar)
            if(nameY == "e$yVarData")
              nameY = svalue(yVar)

            vartypes = c(ifelse(all(is.factor(valueX)),'CAT','CONT'), ifelse(all(is.factor(valueY)),'CAT','CONT'))

            if(all(c('CAT','CONT') %in% vartypes)) e$dotChartView = TRUE else if(all(vartypes %in% c('CONT','CONT'))) e$scatterPlotView = TRUE


            eval(parse(text = paste(c("analysisStep(data.frame(\"",nameX,"\" = valueX,\"",nameY,"\" = valueY), c(\"",nameX,"\",\"",nameY,"\"), vartypes, \"",plotType,"\", FALSE)"), collapse = "")))

        }else if((is.null(e$yVarData)) && !(is.null(e$groupingVarData))) {

            valueX =  svalue(e$xVarData)
            valueG = svalue(e$groupingVarData)


            if(!is.null(e$fourthVariable)){
              valueX = (svalue(e$xVarData)[e$fourthVariable == (levels(e$fourthVariable)[e$sliderData2])])
              valueG = (svalue(e$groupingVarData)[e$fourthVariable == (levels(e$fourthVariable)[e$sliderData2])])
            }

            nameX = id(e$xVarData)
            nameG = id(e$groupingVarData)

            if(nameX == "e$xVarData")
              nameX = svalue(xVar)
            if(nameG == "e$groupingVarData")
              nameG = svalue(groupingVar)

            vartypes = c(ifelse(all(is.factor(valueX)),'CAT','CONT'), ifelse(all(is.factor(valueG)),'CAT','CONT'))
            e$sliderData = tag(e$obj,  "sliderData")

            if(vartypes[1] == 'CONT') e$dotChartView = TRUE

            if(is.null(e$sliderData)) e$sliderData = 0 # <- What does this condition do?

            eval(parse(text = paste(c("analysisStep3(data.frame(\"",nameX,"\" = valueX,\"",nameG,"\" = valueG), c(\"",nameX,"\",\"",nameG,"\"), vartypes, \"",plotType,"\",", e$sliderData, ",FALSE)"), collapse = "")))


        }else if(!(is.null(e$yVarData)) && !(is.null(e$groupingVarData))){       ##

            nameY = id(e$yVarData)
            nameG = id(e$groupingVarData)

            valueY =  svalue(e$yVarData)
            valueG = svalue(e$groupingVarData)


            if(!is.null(e$fourthVariable)){
              valueY = (svalue(e$yVarData)[e$fourthVariable == (levels(e$fourthVariable)[e$sliderData2])])
              valueG = (svalue(e$groupingVarData)[e$fourthVariable == (levels(e$fourthVariable)[e$sliderData2])])
            }

            if(nameY == "e$yVarData")
              nameY = svalue(yVar)
            if(nameG == "e$groupingVarData")
              nameG = svalue(groupingVar)


            vartypes = c(ifelse(all(is.factor(valueX)),'CAT','CONT'), ifelse(all(is.factor(valueY)),'CAT','CONT'), ifelse(all(is.factor(valueG)),'CAT','CONT'))
            if(all(c('CAT','CONT') %in% vartypes[1:2]))e$dotChartView = TRUE else if(all(vartypes[1:2] %in% c('CONT','CONT'))) e$scatterPlotView = TRUE

            e$sliderData = tag(e$obj,  "sliderData")
            if(is.null(e$sliderData)) e$sliderData = 0 # <- What does this condition do?
            if(!e$sliderCreated || e$sliderData == 0 )
              eval(parse(text = paste(c("analysisStep(data.frame(\"",nameX,"\" = valueX,\"",nameY,"\" = valueY,\"",nameG,"\" = valueG), c(\"",nameX,"\",\"",nameY,"\",\"",nameG,"\"), vartypes, \"",plotType,"\",FALSE)"), collapse = "")))
            else
              eval(parse(text = paste(c("analysisStep2(data.frame(\"",nameX,"\" = valueX,\"",nameY,"\" = valueY,\"",nameG,"\" = valueG), c(\"",nameX,"\",\"",nameY,"\",\"",nameG,"\"), vartypes, \"",plotType,"\",", e$sliderData, ",FALSE)"), collapse = "")))

        }
      }
    }

    #print(paste("In update plot", "dotchart", e$dotChartView, "scatterplot", e$scatterPlotView, sep = "-"))

    rmCol = FALSE
    rmSize = FALSE
    backgroundChanged = FALSE
    lineThicknessChanged = FALSE
    fillColor = FALSE
    connectingLines = FALSE


    if(e$dotChartView){
      if(e$basicDotColor != "grey50") rmCol = TRUE
      if(e$basicCexDot != 1) rmSize = TRUE
      if(e$basicBackgroundDot != "white") backgroundChanged = TRUE
      if(e$basicPlottingCharDot != 1) fillColor = TRUE

    }else if(e$scatterPlotView){
      if(e$basicScatterColor != "black") rmCol = TRUE
      if(e$basicCexScatter != 1) rmSize = TRUE
      if(e$basicBackgroundScatter != "white") backgroundChanged = TRUE
      #if(e$scatterThickness1 != 1 || e$scatterThickness2 != 2) lineThicknessChanged = TRUE
      if(e$scatterThickness1 != 1) lineThicknessChanged = TRUE
      if(e$basicPlottingCharScatter != 1) fillColor = TRUE
      if(e$joinByLines) connectingLines = TRUE
    }


    #e$removeAddIndices =  c(TRUE, e$addSmoother, ifelse(e$scatterPlotView, e$addYequalsX, FALSE), (e$addLinearTrend || e$addQuadTrend || e$addCubicTrend), !is.null(e$fifthVariable), !is.null(e$sixthVariable), !is.null(e$segmentVariable), (e$addRugY || e$addRugX || e$addRugYhat), (e$addJitterX || e$addJitterY), rmCol, rmSize, backgroundChanged, (e$drawIntervals || e$drawBootLines), fillColor, lineThicknessChanged )

    e$removeAddIndices =  c(TRUE,
                            !is.null(e$fifthVariable),
                            !is.null(e$sixthVariable),
                            (e$addLinearTrend || e$addQuadTrend || e$addCubicTrend),
                            ifelse(e$scatterPlotView, e$addYequalsX, FALSE),
                            e$addSmoother,
                            (e$addJitterX || e$addJitterY),
                            (e$addRugY || e$addRugX || e$addRugYhat),
                            connectingLines,
                            !is.null(e$segmentVariable),
                            (e$drawIntervals || e$drawBootLines),
                            fillColor,
                            rmCol,
                            rmSize,
                            backgroundChanged,
                            lineThicknessChanged)

  }

# ------------------------------------------------------------------------------

  addHandlerChanged(e$choosePlot,
        handler = function(h,...){

        })

# ------------------------------------------------------------------------------

# Code for the three clear buttons

  clear1 = function() {

    svalue(xVar) <- "Drop name here"
    e$xVarData = NULL
    tag(e$obj,"xVarData") = NULL
    #clearDropHandlers()
    #svalue(e$choosePlot, index = TRUE) = 1
    dispose(nb)
    add(nb, ggraphics(expand = TRUE),label = "plot")
    updatePlot()
  }



  clear2 = function() {

    svalue(yVar) <- "Drop name here"
    e$yVarData = NULL
    tag(e$obj,"yVarData") = NULL
    #clearDropHandlers()
    #svalue(e$choosePlot, index = TRUE) = 1
    updatePlot()
  }

  clear3 = function() {
    svalue(groupingVar) <- "Drop name here"
    e$groupingVarData = NULL
    tag(e$obj,"groupingVarData") = NULL
    tag(e$obj,  "sliderData") = NULL
    if(e$sliderCreated){
      delete(e$firstSliderGp, e$grpSlider)
      delete(e$firstSliderGp, e$lbl)
      e$sliderCreated = FALSE
    }
    #clearDropHandlers()
    #svalue(e$choosePlot, index = TRUE) = 1
    updatePlot()
  }
  clear4 = function() {
    e$fourthVariable = NULL
    e$fourthVarName = ""
    svalue(groupingVar2) <- "Drop name here"
    e$groupingVarData2 = NULL
    tag(e$obj,"groupingVarData2") = NULL
    tag(e$obj,  "sliderData2") = NULL

    #clearDropHandlers()
    #svalue(e$choosePlot, index = TRUE) = 1

    if(e$sliderCreated){
      oldLevelsNum = length(e$gpVarLbls)
      if(is.factor(svalue(tag(e$obj,"groupingVarData")))){
          e$gpVarLbls = levels(svalue(tag(e$obj,"groupingVarData")))
      }else{
          e$gpVarLbls = levels(convert.to.factor(svalue(tag(e$obj,"groupingVarData"))))

      }
      delete(e$firstSliderGp, e$lbl)
      e$lbl = glabel(paste(c("*",e$gpVarLbls), collapse = "   "))

      if(oldLevelsNum != length(e$gpVarLbls)){
        e$grpSlider[] = seq(0,length(e$gpVarLbls),1)
      }

      if(sum(nchar(paste(c("*",e$gpVarLbls)))) < 60)
          add(e$firstSliderGp, e$lbl)

    }
    if(e$sliderCreated2){
      delete(e$secondSliderGp, e$grpSlider2)
      delete(e$secondSliderGp, e$lbl2)
      e$sliderCreated2 = FALSE
    }

    updatePlot()

  }
# ------------------------------------------------------------------------------

  addToPlot = function(h, ...){

    xVarData = tag(e$obj,"xVarData")
    yVarData = tag(e$obj,"yVarData")
    groupingVarData = tag(e$obj,"groupingVarData")
    showSmoothnessSlider = FALSE

    optionsForDotcharts = FALSE
    optionsForBarCharts = FALSE
    e$dotChartView = FALSE
    e$scatterPlotView = FALSE

    if(!is.null(e$xVarData)){

      if(!is.factor(svalue(e$xVarData))) optionsForDotcharts = TRUE
      else  optionsForBarCharts = TRUE

      if(!is.null(yVarData)){
        optionsForBarCharts = FALSE
        if(optionsForDotcharts && is.factor(svalue(e$yVarData))) optionsForDotcharts = TRUE
        else if(!optionsForDotcharts && !is.factor(svalue(e$yVarData))) optionsForDotcharts = TRUE
        else optionsForDotcharts = FALSE
      }


     if(optionsForDotcharts){

         e$dotChartView = TRUE
         e$scatterPlotView = FALSE

         e$addToPlotWin = TRUE
         gw = gwindow(" Add to Plot ", container = TRUE, height = 20, width = 300,  parent = e$win)
         mainGp = ggroup(horizontal = FALSE, expand = TRUE)
         queryGp = ggroup(horizontal = TRUE, expand = FALSE)
         lbl1 = glabel("I want to")
         font(lbl1) <- list(weight="bold", family = "normal", size = "large")

         addHandlerUnrealize(gw, handler = function(h, ...){



            delete(mainGp, e$optionsGp)
            e$presentMoreVarOps = FALSE
            e$presentCustomOps = FALSE
#            e$segmentVariable = NULL
#            e$segmentVariableSubset = NULL
#            e$segmentVarName = ""

            e$dndDisabled = FALSE
            e$addToPlot = FALSE
            e$addToPlotWin = FALSE
            dispose(gw)



          })

         e$changePlotLayout = glayout()
         e$customLayout = glayout()


         e$optionsGp = ggroup(horizontal = FALSE, expand = FALSE)

         option = gradio(c("Code more variables","Change plot appearance"), selected = 1, horizontal = FALSE)
         okButt1 = gbutton(" OK ", horizontal = TRUE, handler = function(h, ...){
         #Need to make it so that it cannot be pressed more than once"
                      if(svalue(option, index = TRUE) == 1){


                        if(!e$presentMoreVarOps){


                        delete(e$optionsGp, e$customLayout)
                        e$changePlotLayout = glayout()


                        lbl1 = glabel("Code More Variables")
                        font(lbl1) <- list(weight="bold", family = "normal", size = "medium")

                        lbl2 = glabel("Colour by levels of :")



                        selectedFifth = ifelse(e$fifthVarName == "", 1, which(e$fifthVarName == names(tag(e$obj, "dataSet"))) + 1)
                        codingVarList = gdroplist(c("",names(tag(e$obj, "dataSet"))), selected = selectedFifth)



                        e$changePlotLayout[3,2:4, anchor = c(-1,-1)] = lbl1

                        e$changePlotLayout[4,2, anchor = c(-1,-1)] = lbl2
                        e$changePlotLayout[4,3] = codingVarList


                        okButton = gbutton(" Show Changes ", handler = function(h,...){

                                                            if(svalue(codingVarList, index = TRUE) != 1){
                                                              e$fifthVariable = tag(e$obj, "dataSet")[,(svalue(codingVarList, index = TRUE))-1]
                                                              e$fifthVarName = svalue(codingVarList)

                                                              updatePlot()

                                                            }else{
                                                              e$fifthVariable = NULL
                                                              e$fifthVariableNumeric = NULL
                                                              e$fifthVariableSubset = NULL
                                                              e$fifthVarName = ""

                                                              updatePlot()
                                                            }

                                                            })
                        font(okButton) <- list(weight="bold", family = "normal", color = "navy")
                        e$changePlotLayout[6, 2:5] = okButton


                        e$presentMoreVarOps = TRUE
                        e$presentCustomOps = FALSE


                        }

                      }else if(svalue(option, index = TRUE) == 2){

                        if(!e$presentCustomOps){


                        delete(e$optionsGp, e$changePlotLayout)

                        e$customLayout = glayout()

                        lbl1 = glabel("Customise Dot Plots")
                        font(lbl1) <- list(weight="bold", family = "normal", size = "medium")

                        lbl2 = glabel("Colour of symbols :") # Mention that coded colors will override this until it is turned off
                        lbl3 = glabel("Background colour :")
                        lbl4 = glabel("Size of symbols  :")
                        lbl5 = glabel("Thickness of symbols :")

                        lbl6 = glabel("(Use drop down list or type in if desired color is unavailable)")
                        font(lbl6) <- list(weight="bold", family = "normal", size = "small")


                        pointCols = c(e$basicDotColor, "darkblue", "darkgreen", "darkmagenta", "darkslateblue", "hotpink4", "lightsalmon2", "palegreen3", "steelblue3")
                        backgroundCols = c(e$basicBackgroundDot, "antiquewhite", "azure3", "bisque", "cornsilk", "darkolivegreen2", "darkslategray1", "greenyellow", "lightblue1", "lightpink", "rosybrown1", "slategray1", "thistle1", "wheat1")


                        symbolColList = gdroplist(pointCols, selected = which(pointCols == e$basicDotColor)[1], editable = TRUE)
                        backgroundColList = gdroplist(backgroundCols, selected = which(backgroundCols == e$basicBackgroundDot)[1], editable = TRUE)

                        fillColor = gcheckbox("Colour symbol interior", checked = (e$basicPlottingCharDot != 1))
                        cexSlider = gslider(from = 0.5, to = 3.5, by = 0.5, value = e$basicCexDot)
                        #thicknessSlider = gslider(from = 0.5, to = 3.5, by = 0.5, value = e$scatterThickness)



                        e$customLayout[3,2:4, anchor = c(-1,-1)] = lbl1

                        e$customLayout[4,2, anchor = c(-1,-1)] = lbl2
                        e$customLayout[4,3, anchor = c(-1,-1)] = symbolColList
                        e$customLayout[5,2:4] = lbl6

                        e$customLayout[6,3, anchor = c(-1,-1)] = fillColor

                        e$customLayout[7,2, anchor = c(-1,-1)] = lbl3
                        e$customLayout[7,3, anchor = c(-1,-1)] = backgroundColList

                        e$customLayout[9,2, anchor = c(-1,-1)] = lbl4
                        e$customLayout[9,3, anchor = c(-1,-1)] = cexSlider
#                        e$customLayout[10,2, anchor = c(-1,-1)] = lbl5
#                        e$customLayout[10,3, anchor = c(-1,-1)] = thicknessSlider




                        okButton = gbutton(" Show Changes ", handler = function(h,...){

                            if(!svalue(symbolColList) %in% colors())gmessage("Invalid Colour for Symbols", parent = gw)
                            else if(!svalue(backgroundColList) %in% colors())  gmessage("Invalid Colour for Background", parent = gw)
                            else{
                            e$basicDotColor = gsub("\\s+", "", svalue(symbolColList), perl = TRUE)
                            e$basicBackgroundDot =  gsub("\\s+", "", svalue(backgroundColList), perl = TRUE)
                            e$basicCexDot = svalue(cexSlider)
                            e$dndDisabled = FALSE
                            e$addToPlotWin = FALSE

                            if(svalue(fillColor)) e$basicPlottingCharDot = 19 else e$basicPlottingCharDot = 1
                            #e$scatterThickness1 = svalue(thicknessSlider)
#                            e$scatterThickness2 = svalue(thicknessSlider)

                            if(!is.null(e$fifthVariable))
                              gmessage(paste("Plot symbols are currently being colour coded using ", e$fifthVarName, ".\n\nThose colours would take precedence over any symbol colour you have chosen until colour-coding is turned off", sep = ""), parent = gw)

                            updatePlot()


                            }

                          })
                        font(okButton) <- list(weight="bold", family = "normal", color = "navy")
                        e$customLayout[11, 2:4] = okButton


                        e$presentMoreVarOps = FALSE
                        e$presentCustomOps = TRUE


                        }



                      }else{
                        e$dndDisabled = FALSE
                        e$addToPlotWin = FALSE
                        e$presentMoreVarOps = FALSE
                        e$presentCustomOps = FALSE
                        dispose(gw)
                      }



                      if(e$presentMoreVarOps){

                        add(e$optionsGp, e$changePlotLayout)
                        visible(e$changePlotLayout) = TRUE

                      }


                      if(e$presentCustomOps){

                        add(e$optionsGp, e$customLayout)
                        visible(e$customLayout) = TRUE


                      }


          })

         font(okButt1) <- list(weight="bold", color = "navy")
         add(queryGp, lbl1, expand = TRUE)
         add(queryGp, option, expand = TRUE)
         add(queryGp, okButt1)
         add(mainGp, queryGp, expand = TRUE)
         add(mainGp, e$optionsGp, expand = TRUE)
         add(gw, mainGp, expand = TRUE)



     }

     if(optionsForBarCharts){

          e$dotChartView = FALSE
          e$scatterPlotView = FALSE

         e$addToPlotWin = TRUE
         gw = gwindow(" Add to Plot ", container = TRUE, height = 20, width = 100, parent = e$win)
         mainGp = ggroup(horizontal = FALSE, expand = TRUE)
         queryGp = ggroup(horizontal = TRUE, expand = FALSE)
         segmentLayout = glayout()
         lbl1 = glabel("I want to")
         font(lbl1) <- list(weight="bold", family = "normal", size = "large")

         addHandlerUnrealize(gw, handler = function(h, ...){

          if(!is.null(e$segmentVariable)){
              x  = gconfirm("Click OK to stop the future segmentation of the bar charts.", parent = gw, expand = TRUE,
                   handler = function(h,...){
                          #optionsForBarCharts = FALSE
                          #optionsForDotCharts = FALSE
                          e$addToPlotWin = FALSE
                          e$dndDisabled = FALSE
                          e$segmentVariable = NULL
                          e$segmentVariableSubset = NULL
                          e$segmentVarName = ""
                          # how about removing the fifth and sixth variable here also
                          dispose(gw)

                    })
          }

           e$addToPlotWin = FALSE
          })


         #option = gcheckbox(c("Segment barchart(s)"))
         optionLbl = glabel("segment barchart(s)")
         okButt1 = gbutton(" OK ", horizontal = TRUE, handler = function(h, ...){


                      #if(svalue(option)){

                        addSpace(queryGp, 10, horizontal = FALSE)
                        enabled(okButt1) = FALSE
                        #enabled(option) = FALSE
                        colorCodingVarGp  = ggroup(expand = TRUE)
                        add(colorCodingVarGp, glabel("         segment by levels of       :  "))
                        codingVarList = gdroplist(c("",names(tag(e$obj, "dataSet"))))
                        add(colorCodingVarGp, codingVarList)

                        okButton = gbutton(" Show Changes ", handler = function(h,...){
                                                              if(svalue(codingVarList, index = TRUE) != 1){
                                                                e$segmentVariable = tag(e$obj, "dataSet")[,(svalue(codingVarList, index = TRUE))-1]
                                                                e$segmentVarName = svalue(codingVarList)
                                                                updatePlot()
                                                              }else{
                                                                e$segmentVariable = NULL
                                                                e$segmentVariableSubset = NULL
                                                                e$segmentVarName = ""
                                                                updatePlot()
                                                              }
                                                            })
                        font(okButton) <- list(weight="bold", family = "normal", color = "navy")
                        add(mainGp, colorCodingVarGp)
                        addSpace(mainGp, 5, horizontal = FALSE)
                        add(mainGp, okButton)

                      # }else{
#                          e$addToPlotWin = FALSE
#                          dispose(gw)
#                       }
          })
         font(okButt1) <- list(weight="bold", color = "navy")

         segmentLayout[3,2, anchor = c(-1,-1), expand = TRUE] = lbl1
         segmentLayout[3,4, anchor = c(-1,-1)] = optionLbl
         segmentLayout[3:4,6:7, anchor = c(-1,-1)] = okButt1


         add(queryGp, segmentLayout)
         visible(segmentLayout) = TRUE
         #add(queryGp, lbl1) #, expand = TRUE)
#         #add(queryGp, option, expand = TRUE)
#         add(queryGp, optionLbl, expand = TRUE)
#         add(queryGp, okButt1)
         add(mainGp, queryGp, expand = TRUE)
         add(gw, mainGp, expand = TRUE)


     }

    }
    if(!(is.null(e$yVarData)) && !(is.null(e$xVarData)) && (is.null(e$groupingVarData) || !is.null(e$groupingVarData))){

      valueX = svalue(e$xVarData)
      valueY =  svalue(e$yVarData)

      if(!is.null(groupingVarData)){
        valueG = svalue(e$groupingVarData)

        d = na.omit(data.frame(valueX,valueY,valueG))
        valueX = d$valueX
        valueY = d$valueY
        valueG = d$valueG

        if(!is.factor(valueG))
          valueG = convert.to.factor(valueG)

      }else{
        d = na.omit(data.frame(valueX,valueY))
        valueX = d$valueX
        valueY = d$valueY
      }



      if (!is.factor(valueX) && !is.factor(valueY)){
          e$addToPlotWin = TRUE
          e$dotChartView = FALSE
          e$scatterPlotView = TRUE

         #e$dndDisabled = TRUE
         #gw = gwindow(" Add to Plot ", container = TRUE, height = 20, parent = e$win)-----commented out on May 11th
         gw = gwindow(" Add to Plot ", container = TRUE, height = 200, width = 300, parent = e$win)
         mainGp = ggroup(horizontal = FALSE, expand = TRUE)
         queryGp = ggroup(horizontal = TRUE, expand = FALSE)
         lbl1 = glabel("I want to")
         font(lbl1) <- list(weight="bold", family = "normal", size = "large")
         e$sliderGp = ggroup(horizontal = FALSE, expand = FALSE)
         #e$option = gradio(c("customise plot", "add a smoother", "add y = x line", "add linear trend line", "add quadratic trend line", "add cubic trend line","add jitter", "add rug(s)",
#                        "join points by lines",
#                        "do nothing"), selected = 10, horizontal = FALSE)

         e$option = gradio(c("Code more variables", "Add trend curves", "Add y = x line", "Add a smoother", "Add jitter", "Add rugs",
                        "Join points by lines", "Change plot appearance"), selected = 1, horizontal = FALSE)

         e$trendOption1 = gcheckbox("linear", checked = e$addLinearTrend, handler = function(h,...){
                                                if(svalue(h$obj)){
                                                  enabled(e$colorChooserLIN) = TRUE
                                                  e$addLinearTrend = TRUE
                                                }else{
                                                  enabled(e$colorChooserLIN) = FALSE
                                                  e$addLinearTrend = FALSE
                                                }
                                                updatePlot()
                                                })
         e$trendOption2 = gcheckbox("quadratic", checked = e$addQuadTrend, handler = function(h,...){
                                                if(svalue(h$obj)){
                                                  enabled(e$colorChooserQUAD) = TRUE
                                                  e$addQuadTrend = TRUE
                                                }else{
                                                  enabled(e$colorChooserQUAD) = FALSE
                                                  e$addQuadTrend = FALSE
                                                }
                                                updatePlot()
                                                })
         e$trendOption3 = gcheckbox("cubic", checked = e$addCubicTrend, handler = function(h,...){
                                                if(svalue(h$obj)){
                                                  enabled(e$colorChooserCUBE) = TRUE
                                                  e$addCubicTrend = TRUE
                                                }else{
                                                  enabled(e$colorChooserCUBE) = FALSE
                                                  e$addCubicTrend = FALSE
                                                }
                                                updatePlot()
                                                })
         #e$trendGp = ggroup(horizontal = FALSE)
         trendColors = c("#8B0000", "#000000", "#0000FF", "#006400", "#CD9B1D", "#CD6090", "#5C5C5C", "#8B4500")

         if(svalue(e$option, index = TRUE) == 4) selectedSmooth = which(trendColors == e$smootherColor)
         else selectedSmooth = 1



         e$colorChooser = gradio(c("red", "black", "blue", "green", "yellow", "pink", "grey", "orange"), selected = selectedSmooth, horizontal = TRUE,
                                  handler = function(h,...){
                                        if(svalue(e$option, index = TRUE) == 4)
                                            e$smootherColor = trendColors[svalue(h$obj, index = TRUE)]

                                        updatePlot()

                                  })
         selectedLin = which(trendColors == e$linearColor)
         e$colorChooserLIN = gdroplist(c("red", "black", "blue", "green", "yellow", "pink", "grey", "orange"), selected = selectedLin, horizontal = TRUE,
                                  handler = function(h,...){

                                    if(svalue(e$trendOption1))
                                      e$linearColor = trendColors[svalue(h$obj, index = TRUE)]

                                    updatePlot()

                                  })
         selectedQuad = which(trendColors == e$quadColor)
         e$colorChooserQUAD = gdroplist(c("red", "black", "blue", "green", "yellow", "pink", "grey", "orange"), selected = selectedQuad, horizontal = TRUE,
                                  handler = function(h,...){

                                    if(svalue(e$trendOption2))
                                      e$quadColor = trendColors[svalue(h$obj, index = TRUE)]

                                    updatePlot()

                                  })
         selectedCube = which(trendColors == e$cubicColor)
         e$colorChooserCUBE = gdroplist(c("red", "black", "blue", "green", "yellow", "pink", "grey", "orange"), selected = selectedCube, horizontal = TRUE,
                                  handler = function(h,...){

                                    if(svalue(e$trendOption3))
                                      e$cubicColor = trendColors[svalue(h$obj, index = TRUE)]

                                    updatePlot()

                                  })

         enabled(e$colorChooserLIN) = FALSE
         enabled(e$colorChooserQUAD) = FALSE
         enabled(e$colorChooserCUBE) = FALSE

         #rugJitterButt = gbutton(" ADD ", horizontal = TRUE, handler = function(h,...) e$addRugJitter())

         xJitter = gcheckbox("Jitter x-variable", checked = e$addJitterX, handler = function(h,...){

                      if(svalue(h$obj)) e$addJitterX = TRUE
                      else e$addJitterX = FALSE
                      updatePlot()
                    })
         yJitter = gcheckbox("Jitter y-variable", checked = e$addJitterY, handler = function(h,...){

                      if(svalue(h$obj)) e$addJitterY = TRUE
                      else e$addJitterY = FALSE
                      updatePlot()

                    })

         xRug = gcheckbox("Add x-rug", checked = e$addRugX, handler = function(h,...){

                      if(svalue(h$obj)) e$addRugX = TRUE
                      else e$addRugX = FALSE

                      updatePlot()
                })
         yRug = gcheckbox("Add y-rug", checked = e$addRugY, handler = function(h,...){

                      if(svalue(h$obj)) e$addRugY = TRUE
                      else e$addRugY = FALSE

                      updatePlot()
                })
         yHatRug = gcheckbox("Add y-hat rug", checked = FALSE )

         extraOptionsLbl = glabel("Choose from the options below")
         font(extraOptionsLbl) = list(weight = "bold", family = "normal", size = "large")


         e$smoothSlider = gslider(from = 0, to = 1, by = 0.1, value = e$smootherValue,
                          handler = function(h, ...){
                              e$addSmoother = TRUE
                              e$smootherValue = svalue(h$obj)
                              updatePlot()
                          })



         e$changePlotLayout = glayout()
         e$trendLayout = glayout()
         e$customLayout = glayout()
         e$sliderLayout = glayout()

         okButt1 = gbutton(" OK ", horizontal = TRUE, handler = function(h, ...){



                      if(svalue(e$option, index = TRUE) == 1){


                        if(!e$presentMoreVarOps){

                          delete(e$sliderGp, xJitter)
                          delete(e$sliderGp, yJitter)
                          delete(e$sliderGp, xRug)
                          delete(e$sliderGp, yRug)
                          delete(e$sliderGp, extraOptionsLbl)

                          delete(e$sliderGp, e$trendLayout)
                          delete(e$sliderGp, e$customLayout)
                          #delete(e$sliderGp, e$colorChooser)
                          delete(e$sliderGp, e$sliderLayout)

                        #enabled(okButt1) = FALSE
                        #enabled(e$option) = FALSE

                        e$changePlotLayout = glayout()

                        lbl1 = glabel("Code More Variables")
                        font(lbl1) <- list(weight="bold", family = "normal", size = "medium")

                        lbl2 = glabel("Colour by levels of :")
                        lbl3 = glabel("Resize points proportional to :")


                        selectedFifth = ifelse(e$fifthVarName == "", 1, which(e$fifthVarName == names(tag(e$obj, "dataSet"))) + 1)
                        codingVarList = gdroplist(c("",names(tag(e$obj, "dataSet"))), selected = selectedFifth)

                        numericVariableList = character(0)
                        for(i in 1:length(names(tag(e$obj, "dataSet")))){
                             if((!is.factor(tag(e$obj, "dataSet")[,i])) && (!is.infinite(min(tag(e$obj, "dataSet")[,i], na.rm = TRUE)))){
                               if(min(tag(e$obj, "dataSet")[,i], na.rm = TRUE) >= 0)
                                  numericVariableList = c(numericVariableList, names(tag(e$obj, "dataSet"))[i])
                             }
                        }

                        selectedSixth = ifelse(e$sixthVarName == "", 1, which(e$sixthVarName == numericVariableList) + 1)
                        resizeVarList = gdroplist(c("",numericVariableList), selected = selectedSixth)


                        e$changePlotLayout[3,2:4, anchor = c(-1,-1)] = lbl1

                        e$changePlotLayout[4,2, anchor = c(-1,-1)] = lbl2
                        e$changePlotLayout[4,3] = codingVarList

                        e$changePlotLayout[5,2, anchor = c(-1,-1)] = lbl3
                        e$changePlotLayout[5,3] = resizeVarList


                        okButton = gbutton(" Show Changes ", handler = function(h,...){


                                                            if(svalue(codingVarList, index = TRUE) != 1){
                                                              e$fifthVariable = tag(e$obj, "dataSet")[,(svalue(codingVarList, index = TRUE))-1]
                                                              e$fifthVarName = svalue(codingVarList)

                                                              if(svalue(resizeVarList, index = TRUE) != 1){
                                                                e$sixthVarName = svalue(resizeVarList)
                                                                e$sixthVariable = tag(e$obj, "dataSet")[,e$sixthVarName]

                                                              }else{
                                                                e$sixthVariable = NULL
                                                                e$sixthVariableSubset = NULL
                                                                e$sixthVarName = ""
                                                              }

                                                              updatePlot()
                                                            }else{
                                                              e$fifthVariable = NULL
                                                              e$fifthVariableNumeric = NULL
                                                              e$fifthVariableSubset = NULL
                                                              e$fifthVarName = ""

                                                              if(svalue(resizeVarList, index = TRUE) != 1){
                                                                e$sixthVarName = svalue(resizeVarList)
                                                                e$sixthVariable = tag(e$obj, "dataSet")[,e$sixthVarName]

                                                              }else{
                                                                e$sixthVariable = NULL
                                                                e$sixthVariableSubset = NULL
                                                                e$sixthVarName = ""
                                                              }

                                                              updatePlot()
                                                            }

                                                            })
                        font(okButton) <- list(weight="bold", family = "normal", color = "navy")
                        e$changePlotLayout[8, 2:5] = okButton

                        e$presentRugOptions = FALSE
                        e$presentJitterOptions = FALSE
                        e$presentTrendOps = FALSE
                        e$presentMoreVarOps = TRUE
                        showSmoothnessSlider = FALSE
                        e$presentCustomOps = FALSE
                        e$presentSmootherOps = FALSE

                        }

                      }else if(svalue(e$option, index = TRUE) == 2){

                        if(!e$presentTrendOps){

                          delete(e$sliderGp, xJitter)
                          delete(e$sliderGp, yJitter)
                          delete(e$sliderGp, xRug)
                          delete(e$sliderGp, yRug)
                          delete(e$sliderGp, extraOptionsLbl)

                          delete(e$sliderGp, e$changePlotLayout)
                          delete(e$sliderGp, e$customLayout)
                          #delete(e$sliderGp, e$colorChooser)
                          delete(e$sliderGp, e$sliderLayout)

                          delete(e$trendLayout, e$trendOption1)
                          delete(e$trendLayout, e$colorChooserLIN)
                          delete(e$trendLayout, e$trendOption2)
                          delete(e$trendLayout, e$colorChooserQUAD)
                          delete(e$trendLayout, e$trendOption3)
                          delete(e$trendLayout, e$colorChooserCUBE)

                          e$trendLayout = glayout()

                          e$trendLayout[2,2, anchor = c(-1,0)] = e$trendOption1
                          e$trendLayout[2,3, anchor = c(-1,0)] = e$colorChooserLIN

                          e$trendLayout[4,2, anchor = c(-1,0)] = e$trendOption2
                          e$trendLayout[4,3, anchor = c(-1,0)] = e$colorChooserQUAD

                          e$trendLayout[6,2, anchor = c(-1,0)] = e$trendOption3
                          e$trendLayout[6,3, anchor = c(-1,0)] = e$colorChooserCUBE


                          e$presentJitterOptions = FALSE
                          e$presentRugOptions = FALSE
                          e$presentTrendOps = TRUE
                          e$presentMoreVarOps = FALSE
                          showSmoothnessSlider = FALSE
                          e$presentCustomOps = FALSE
                          e$presentSmootherOps = FALSE


                       }

                      }else if(svalue(e$option, index = TRUE) == 3){

                          e$presentJitterOptions = FALSE
                          e$presentRugOptions = FALSE
                          e$presentTrendOps = FALSE
                          e$presentMoreVarOps = FALSE
                          showSmoothnessSlider = FALSE
                          e$presentCustomOps = FALSE
                          e$presentSmootherOps = FALSE


                          delete(e$sliderGp, xJitter)
                          delete(e$sliderGp, yJitter)
                          delete(e$sliderGp, xRug)
                          delete(e$sliderGp, yRug)
                          delete(e$sliderGp, extraOptionsLbl)

                          delete(e$sliderGp, e$changePlotLayout)

                          delete(e$sliderGp, e$trendLayout)
                          delete(e$sliderGp, e$customLayout)
                          #delete(e$sliderGp, e$colorChooser)
                          delete(e$sliderGp, e$sliderLayout)


                          e$addYequalsX = TRUE
                          updatePlot()

                      }else if(svalue(e$option, index = TRUE) == 4){

                        if(!e$presentSmootherOps){
                          delete(e$sliderGp, xJitter)
                          delete(e$sliderGp, yJitter)
                          delete(e$sliderGp, xRug)
                          delete(e$sliderGp, yRug)
                          delete(e$sliderGp, extraOptionsLbl)

                          delete(e$sliderGp, e$changePlotLayout)

                          delete(e$sliderGp, e$trendLayout)
                          delete(e$sliderGp, e$customLayout)
                          #delete(e$sliderGp, e$colorChooser)

                          e$presentJitterOptions = FALSE
                          e$presentRugOptions = FALSE
                          e$presentTrendOps = FALSE
                          e$presentMoreVarOps = FALSE
                          showSmoothnessSlider = FALSE
                          e$presentCustomOps = FALSE
                          e$presentSmootherOps = TRUE


                          lbl1 = glabel("Choose the smoothness :\n(Larger values give more smoothness)", expand = TRUE)
                          font(lbl1) <- list(weight="bold", family = "normal")

#                        okButt2 = gbutton(" DONE ", horizontal = TRUE, handler = function(h,...){showSmoothnessSlider = FALSE;
#                       e$dndDisabled = FALSE; e$addToPlotWin = FALSE; e$smoothSlider = NULL; e$colorChooser = NULL; dispose(gw)})



                          e$sliderLayout[3,2:5, anchor = c(-1,-1)] = lbl1
                          e$sliderLayout[5,2:5] = e$smoothSlider
                          e$sliderLayout[7,2:5] = e$colorChooser

                          e$addSmoother = TRUE


                        }
                      }else if(svalue(e$option, index = TRUE) == 5){

                          if(!e$presentJitterOptions){

                            delete(e$sliderGp, xRug)
                            delete(e$sliderGp, yRug)
                            delete(e$sliderGp, extraOptionsLbl)

                            delete(e$sliderGp, e$changePlotLayout)

                            delete(e$sliderGp, e$trendLayout)
                            delete(e$sliderGp, e$customLayout)
                            #delete(e$sliderGp, e$colorChooser)
                            delete(e$sliderGp, e$sliderLayout)


                            e$presentJitterOptions = TRUE
                            e$presentRugOptions = FALSE
                            e$presentTrendOps = FALSE
                            e$presentMoreVarOps = FALSE
                            showSmoothnessSlider = FALSE
                            e$presentCustomOps = FALSE
                            e$presentSmootherOps = FALSE
                          }



                      }else if(svalue(e$option, index = TRUE) == 6){

                        if(!e$presentRugOptions){
                          e$presentJitterOptions = FALSE
                          e$presentRugOptions = TRUE
                          e$presentTrendOps = FALSE
                          e$presentMoreVarOps = FALSE
                          showSmoothnessSlider = FALSE
                          e$presentCustomOps = FALSE
                          e$presentSmootherOps = FALSE

                          delete(e$sliderGp, xJitter)
                          delete(e$sliderGp, yJitter)
                          delete(e$sliderGp, xRug)
                          delete(e$sliderGp, yRug)
                          delete(e$sliderGp, extraOptionsLbl)

                          delete(e$sliderGp, e$changePlotLayout)
                          delete(e$sliderGp, e$trendLayout)
                          delete(e$sliderGp, e$customLayout)
                          #delete(e$sliderGp, e$colorChooser)
                          delete(e$sliderGp, e$sliderLayout)

                        }

                      }else if(svalue(e$option, index = TRUE) == 7){

                        delete(e$sliderGp, xJitter)
                        delete(e$sliderGp, yJitter)
                        delete(e$sliderGp, xRug)
                        delete(e$sliderGp, yRug)
                        delete(e$sliderGp, extraOptionsLbl)

                        delete(e$sliderGp, e$changePlotLayout)

                        delete(e$sliderGp, e$trendLayout)
                        delete(e$sliderGp, e$customLayout)
                        #delete(e$sliderGp, e$colorChooser)
                        delete(e$sliderGp, e$sliderLayout)

                        e$presentJitterOptions = FALSE
                        e$presentRugOptions = FALSE
                        e$presentTrendOps = FALSE
                        e$presentMoreVarOps = FALSE
                        showSmoothnessSlider = FALSE
                        e$presentCustomOps = FALSE
                        e$presentSmootherOps = FALSE

                        e$joinByLines = TRUE
                        updatePlot()

                      }else if(svalue(e$option, index = TRUE) == 8){


                        if(!e$presentCustomOps){

                          delete(e$sliderGp, xJitter)
                          delete(e$sliderGp, yJitter)
                          delete(e$sliderGp, xRug)
                          delete(e$sliderGp, yRug)
                          delete(e$sliderGp, extraOptionsLbl)

                          delete(e$sliderGp, e$changePlotLayout)

                          delete(e$sliderGp, e$trendLayout)

                          #delete(e$sliderGp, e$colorChooser)

                          delete(e$sliderGp, e$sliderLayout)


                        e$customLayout = glayout()

                        lbl1 = glabel("Customise Scatter Plots")
                        font(lbl1) <- list(weight="bold", family = "normal", size = "medium")

                        lbl2 = glabel("Colour of symbols :") # Mention that coded colors will override this until it is turned off
                        lbl3 = glabel("Background colour :")
                        lbl4 = glabel("Size of symbols  :")
                        lbl5 = glabel("Thickness of symbols :")

                        lbl6 = glabel("(Use drop down list or type in if desired color is unavailable)")
                        font(lbl6) <- list(weight="bold", family = "normal", size = "small")


                        pointCols = c(e$basicScatterColor, "darkblue", "darkgreen", "darkmagenta", "darkslateblue", "hotpink4", "lightsalmon2", "palegreen3", "steelblue3")
                        backgroundCols = c(e$basicBackgroundScatter, "antiquewhite", "azure3", "bisque", "cornsilk", "darkolivegreen2", "darkslategray1", "greenyellow", "lightblue1", "lightpink", "rosybrown1", "slategray1", "thistle1", "wheat1")


                        symbolColList = gdroplist(pointCols, selected = which(pointCols == e$basicScatterColor)[1], editable = TRUE)
                        backgroundColList = gdroplist(backgroundCols, selected = which(backgroundCols == e$basicBackgroundScatter)[1], editable = TRUE)


                        fillColor = gcheckbox("Colour symbol interior", checked = (e$basicPlottingCharScatter != 1))
                        cexSlider = gslider(from = 0.5, to = 3.5, by = 0.5, value = e$basicCexScatter)
                        thicknessSlider = gslider(from = 0.5, to = 3.5, by = 0.5, value = e$scatterThickness1)



                        e$customLayout[3,2:4, anchor = c(-1,-1)] = lbl1

                        e$customLayout[4,2, anchor = c(-1,-1)] = lbl2
                        e$customLayout[4,3, anchor = c(-1,-1)] = symbolColList
                        e$customLayout[5,2:4] = lbl6

                        e$customLayout[6,3, anchor = c(-1,-1)] = fillColor

                        e$customLayout[7,2, anchor = c(-1,-1)] = lbl3
                        e$customLayout[7,3, anchor = c(-1,-1)] = backgroundColList

                        e$customLayout[9,2, anchor = c(-1,-1)] = lbl4
                        e$customLayout[9,3, anchor = c(-1,-1)] = cexSlider
                        e$customLayout[10,2, anchor = c(-1,-1)] = lbl5
                        e$customLayout[10,3, anchor = c(-1,-1)] = thicknessSlider


                        okButton = gbutton(" Show Changes ", handler = function(h,...){

                            if(!svalue(symbolColList) %in% colors())gmessage("Invalid Colour for Symbols", parent = gw)
                            else if(!svalue(backgroundColList) %in% colors())  gmessage("Invalid Colour for Background", parent = gw)
                            else{
                            e$basicScatterColor = gsub("\\s+", "", svalue(symbolColList), perl = TRUE)
                            e$basicBackgroundScatter =  gsub("\\s+", "", svalue(backgroundColList), perl = TRUE)
                            e$basicCexScatter = svalue(cexSlider)
                            e$dndDisabled = FALSE
                            e$addToPlotWin = FALSE

                            if(svalue(fillColor)) e$basicPlottingCharScatter = 19 else e$basicPlottingCharScatter = 1
                            e$scatterThickness1 = svalue(thicknessSlider)
                            e$scatterThickness2 = svalue(thicknessSlider)

                            if(!is.null(e$fifthVariable))
                              gmessage(paste("Plot symbols are currently being colour coded using ", e$fifthVarName, ".\n\nThose colours would take precedence over any symbol colour you have chosen until colour-coding is turned off", sep = ""), parent = gw)



                            updatePlot()


                            }

                          })
                        font(okButton) <- list(weight="bold", family = "normal", color = "navy")
                        e$customLayout[12, 2:4] = okButton

                        e$presentRugOptions = FALSE
                        e$presentJitterOptions = FALSE
                        e$presentTrendOps = FALSE
                        e$presentMoreVarOps = FALSE
                        showSmoothnessSlider = FALSE
                        e$presentCustomOps = TRUE
                        e$presentSmootherOps = FALSE

                        }




                      }else{

                        e$dndDisabled = FALSE
                        e$addToPlotWin = FALSE
                        e$presentJitterOptions = FALSE
                        e$presentRugOptions = FALSE
                        e$presentTrendOps = FALSE
                        e$presentMoreVarOps = FALSE
                        showSmoothnessSlider = FALSE
                        e$presentCustomOps = FALSE
                        e$presentSmootherOps = FALSE

                        dispose(gw)
                      }



                       if(e$presentSmootherOps){

                        add(e$sliderGp, e$sliderLayout)
                        visible(e$sliderLayout) = TRUE
                        updatePlot()
                       }



                      if(e$presentMoreVarOps){

                        add(e$sliderGp, e$changePlotLayout)
                        visible(e$changePlotLayout) = TRUE

                      }

                      if(e$presentTrendOps){

                        add(e$sliderGp, e$trendLayout)
                        visible(e$trendLayout) = TRUE

                      }

                      if(e$presentCustomOps){

                        add(e$sliderGp, e$customLayout)
                        visible(e$customLayout) = TRUE


                      }

                      if(e$presentJitterOptions){
                        add(e$sliderGp, extraOptionsLbl)
                        add(e$sliderGp, xJitter)
                        add(e$sliderGp, yJitter)
                      }

                      if(e$presentRugOptions){
                        add(e$sliderGp, extraOptionsLbl)
                        add(e$sliderGp, xRug)
                        add(e$sliderGp, yRug)
                      }







                      })

         font(okButt1) <- list(weight="bold", color = "navy")
         add(queryGp, lbl1, expand = TRUE)
         add(queryGp, e$option, expand = TRUE)
         add(queryGp, okButt1)

         add(mainGp, queryGp, expand = TRUE)


         add(mainGp, e$sliderGp, expand = TRUE)
         add(gw, mainGp, expand = TRUE)


         addHandlerUnrealize(gw, handler = function(h, ...){


            delete(mainGp, e$sliderGp)

            e$addToPlotWin = FALSE

            showSmoothnessSlider = FALSE;
            e$presentRugOptions = FALSE
            e$presentJitterOptions = FALSE
            e$presentTrendOps = FALSE
            e$presentMoreVarOps = FALSE
            e$presentCustomOps = FALSE
            e$presentSmootherOps = FALSE

            e$dndDisabled = FALSE
            e$smoothSlider = NULL
            e$colorChooser = NULL

            dispose(gw)
        })


      }
      else{
       e$dndDisabled = FALSE ######################### This could be important later on ************************************************************
       e$addToPlotWin = FALSE
      }
    }









  }

# ------------------------------------------------------------------------------

## clear out view.col handlers
  clearDropHandlers = function(...) {
    dropHandlers = tag(e$obj,"dropHandlers")
    if(length(dropHandlers) > 0) {
      for(i in 1:length(dropHandlers)) {
        removehandler(dropHandlers[[i]]$view.col,dropHandlers[[i]]$id)
      }
    }
  }
  addHandlerUnrealize(e$obj, handler = clearDropHandlers)



  e$fileReader = function(){
    print("Importing file")
    #importUserFile()

    specifyFileForImport()
# Make sure to change inDataView() + enabled(dataView) etc if you change the method of reading data
  }

  e$fileWriter = function(){

    specifyFileForExport()

  }

# ------------------------------------------------------------------------------

  e$updateData = function() {
    names(tag(e$obj,"dataSet")) = make.names(names(tag(e$obj,"dataSet")), unique = TRUE)

    tag(e$obj,"rowDataSet") = data.frame( ROW_NAME = tag(e$obj,"rowDataSet")[,1], tag(e$obj, "dataSet"))
    names(tag(e$obj,"rowDataSet")) = make.names(names(tag(e$obj,"rowDataSet")), unique = TRUE)


    if(!is.null(e$dataList))
      delete(e$dataGp, e$dataList, expand = TRUE)
    if(!is.null(e$dataList1))
      delete(e$dataGp, e$dataList1, expand = TRUE)
    if(!is.null(e$dataList2))
      delete(e$dataGp, e$dataList2, expand = TRUE)
    if(!is.null(e$dataSt))
      delete(e$dataGp, e$dataSt, expand = TRUE)

      e$dataSt = gdf(tag(e$obj,"dataSet"),expand = TRUE)
      add(e$dataGp, e$dataSt, expand = TRUE)
      addHandlerChanged(e$dataSt, handler = function(h,...)tag(e$obj,"dataSet") = e$dataSt[])
      #tag(e$obj, "originalDataSet") = tag(e$obj, "dataSet")
      e$inDataView = TRUE
  }

  e$updateList = function() {
    names(tag(e$obj,"dataSet")) = make.names(names(tag(e$obj,"dataSet")), unique = TRUE)

    tag(e$obj,"rowDataSet") = data.frame(ROW_NAME = tag(e$obj,"rowDataSet")[,1], tag(e$obj, "dataSet"))
    names(tag(e$obj,"rowDataSet")) = make.names(names(tag(e$obj,"rowDataSet")), unique = TRUE)


    if(!is.null(e$dataList))
      delete(e$dataGp, e$dataList, expand = TRUE)
    if(!is.null(e$dataList1))
      delete(e$dataGp, e$dataList1, expand = TRUE)
    if(!is.null(e$dataList2))
      delete(e$dataGp, e$dataList2, expand = TRUE)
    if(!is.null(e$dataSt))
      delete(e$dataGp, e$dataSt, expand = TRUE)

    N = 19
    if(e$sliderCreated && e$sliderCreated2) N = 14

      if((length(names(tag(e$obj,"dataSet"))) > N) && (length(names(tag(e$obj,"dataSet"))) < 80)){

        x = length(names(tag(e$obj,"dataSet"))[(N+1):(length(names(tag(e$obj,"dataSet"))))])
        d1 = (names(tag(e$obj,"dataSet"))[1:N])
        d2 = c(names(tag(e$obj,"dataSet"))[(N+1):(length(names(tag(e$obj,"dataSet"))))])  #, rep("",(length(names(tag(e$obj,"dataSet")))-25-x))))

      e$dataList1 = gtable(d1,expand = TRUE)
      names(e$dataList1) = "VARIABLES"
      e$dataList2 = gtable(d2,expand = TRUE)
      names(e$dataList2) = "...CONTINUED"
      adddropsource(e$dataList1)
      adddropsource(e$dataList2)
      add(e$dataGp, e$dataList1, expand = TRUE)
      add(e$dataGp, e$dataList2, expand = TRUE)

      }else{

        d = names(tag(e$obj,"dataSet"))
        e$dataList = gtable(d,expand = TRUE)
        names(e$dataList) = "VARIABLES"
        adddropsource(e$dataList)
        add(e$dataGp, e$dataList, expand = TRUE)
      }

      #tag(e$obj, "originalDataSet") = tag(e$obj, "dataSet")
      e$inDataView = FALSE
  }
# ------------------------------------------------------------------------------
  scatter3d <- function(x, y, z,
  	xlab=deparse(substitute(x)), ylab=deparse(substitute(y)),
  	axis.scales=TRUE,
  	zlab=deparse(substitute(z)), revolutions=0, bg.col=c("white", "black"),
  	axis.col=if (bg.col == "white") c("darkmagenta", "black", "darkcyan")
  		else c("darkmagenta", "white", "darkcyan"),
  	surface.col=c("blue", "green", "orange", "magenta", "cyan", "red", "yellow", "gray"),
  	neg.res.col="red", pos.res.col="green",
  	square.col=if (bg.col == "white") "black" else "gray", point.col="yellow",
  	text.col=axis.col, grid.col=if (bg.col == "white") "black" else "gray",
  	fogtype=c("exp2", "linear", "exp", "none"),
  	residuals=(length(fit) == 1), surface=TRUE, fill=TRUE, grid=TRUE, grid.lines=26,
  	df.smooth=NULL, df.additive=NULL,
  	sphere.size=1, threshold=0.01, speed=1, fov=60,
  	fit="linear", groups=NULL, parallel=TRUE, ellipsoid=FALSE, level=0.5,
  	model.summary=FALSE){
  	require(rgl)
  	require(mgcv)
  	if (residuals == "squares"){
  		residuals <- TRUE
  		squares <- TRUE
  	}
  	else squares <- FALSE
  	summaries <- list()
  	if ((!is.null(groups)) && (nlevels(groups) > length(surface.col)))
  		stop(sprintf(gettextRcmdr("Number of groups (%d) exceeds number of colours (%d)."),
  				nlevels(groups), length(surface.col)))
  	if ((!is.null(groups)) && (!is.factor(groups))) stop(gettextRcmdr("groups variable must be a factor."))
  	bg.col <- match.arg(bg.col)
  	fogtype <- match.arg(fogtype)
  	if ((length(fit) > 1) && residuals && surface)
  		stop(gettextRcmdr("cannot plot both multiple surfaces and residuals"))
  #	xlab   cause these arguments to be evaluated
  #	ylab
  #	zlab
  	rgl.clear()
  	rgl.viewpoint(fov=fov)
  	rgl.bg(col=bg.col, fogtype=fogtype)
  	valid <- if (is.null(groups)) complete.cases(x, y, z)
  		else complete.cases(x, y, z, groups)
  	x <- x[valid]
  	y <- y[valid]
  	z <- z[valid]
  	minx <- min(x)
  	maxx <- max(x)
  	miny <- min(y)
  	maxy <- max(y)
  	minz <- min(z)
  	maxz <- max(z)
  	if (axis.scales){
  #		lab.min.x <- nice(minx)
  #		lab.max.x <- nice(maxx)
  #		lab.min.y <- nice(miny)
  #		lab.max.y <- nice(maxy)
  #		lab.min.z <- nice(minz)
  #		lab.max.z <- nice(maxz)

  		lab.min.x <- minx
  		lab.max.x <- maxx
  		lab.min.y <- miny
  		lab.max.y <- maxy
  		lab.min.z <- minz
  		lab.max.z <- maxz

  		minx <- min(lab.min.x, minx)
  		maxx <- max(lab.max.x, maxx)
  		miny <- min(lab.min.y, miny)
  		maxy <- max(lab.max.y, maxy)
  		minz <- min(lab.min.z, minz)
  		maxz <- max(lab.max.z, maxz)
  		min.x <- (lab.min.x - minx)/(maxx - minx)
  		max.x <- (lab.max.x - minx)/(maxx - minx)
  		min.y <- (lab.min.y - miny)/(maxy - miny)
  		max.y <- (lab.max.y - miny)/(maxy - miny)
  		min.z <- (lab.min.z - minz)/(maxz - minz)
  		max.z <- (lab.max.z - minz)/(maxz - minz)
  	}
  	if (!is.null(groups)) groups <- groups[valid]
  	x <- (x - minx)/(maxx - minx)
  	y <- (y - miny)/(maxy - miny)
  	z <- (z - minz)/(maxz - minz)
  	size <- sphere.size*((100/length(x))^(1/3))*0.015
  	if (is.null(groups)){
  		if (size > threshold) rgl.spheres(x, y, z, color=point.col, radius=size)
  		else rgl.points(x, y, z, color=point.col)
  	}
  	else {
  		if (size > threshold) rgl.spheres(x, y, z, color=surface.col[as.numeric(groups)], radius=size)
  		else rgl.points(x, y, z, color=surface.col[as.numeric(groups)])
  	}
  	if (!axis.scales) axis.col[1] <- axis.col[3] <- axis.col[2]
  	rgl.lines(c(0,1), c(0,0), c(0,0), color=axis.col[1])
  	rgl.lines(c(0,0), c(0,1), c(0,0), color=axis.col[2])
  	rgl.lines(c(0,0), c(0,0), c(0,1), color=axis.col[3])
  	rgl.texts(1, 0, 0, xlab, adj=1, color=axis.col[1])
  	rgl.texts(0, 1.05, 0, ylab, adj=1, color=axis.col[2])
  	rgl.texts(0, 0, 1, zlab, adj=1, color=axis.col[3])
  	if (axis.scales){
  		rgl.texts(min.x, -0.05, 0, lab.min.x, col=axis.col[1])
  		rgl.texts(max.x, -0.05, 0, lab.max.x, col=axis.col[1])
  		rgl.texts(0, -0.1, min.z, lab.min.z, col=axis.col[3])
  		rgl.texts(0, -0.1, max.z, lab.max.z, col=axis.col[3])
  		rgl.texts(-0.05, min.y, -0.05, lab.min.y, col=axis.col[2])
  		rgl.texts(-0.05, max.y, -0.05, lab.max.y, col=axis.col[2])
  	}
  	if (ellipsoid) {
  		dfn <- 3
  		if (is.null(groups)){
  			dfd <- length(x) - 1
  			radius <- sqrt(dfn * qf(level, dfn, dfd))
  			ellips <- ellipsoid(center=c(mean(x), mean(y), mean(z)),
  				shape=cov(cbind(x,y,z)), radius=radius)
  			if (fill) shade3d(ellips, col=surface.col[1], alpha=0.1, lit=FALSE)
  			if (grid) wire3d(ellips, col=surface.col[1], lit=FALSE)
  		}
  		else{
  			levs <- levels(groups)
  			for (j in 1:length(levs)){
  				group <- levs[j]
  				select.obs <- groups == group
  				xx <- x[select.obs]
  				yy <- y[select.obs]
  				zz <- z[select.obs]
  				dfd <- length(xx) - 1
  				radius <- sqrt(dfn * qf(level, dfn, dfd))
  				ellips <- ellipsoid(center=c(mean(xx), mean(yy), mean(zz)),
  					shape=cov(cbind(xx,yy,zz)), radius=radius)
  				if (fill) shade3d(ellips, col=surface.col[j], alpha=0.1, lit=FALSE)
  				if (grid) wire3d(ellips, col=surface.col[j], lit=FALSE)
  				coords <- ellips$vb[, which.max(ellips$vb[1,])]
  				if (!surface) rgl.texts(coords[1] + 0.05, coords[2], coords[3], group,
  						col=surface.col[j])
  			}
  		}
  	}
  	if (surface){
  		vals <- seq(0, 1, length.out=grid.lines)
  		dat <- expand.grid(x=vals, z=vals)
  		for (i in 1:length(fit)){
  			f <- match.arg(fit[i], c("linear", "quadratic", "smooth", "additive"))
  			if (is.null(groups)){
  				mod <- switch(f,
  					linear = lm(y ~ x + z),
  					quadratic = lm(y ~ (x + z)^2 + I(x^2) + I(z^2)),
  					smooth = if (is.null(df.smooth)) gam(y ~ s(x, z))
  						else gam(y ~ s(x, z, fx=TRUE, k=df.smooth)),
  					additive = if (is.null(df.additive)) gam(y ~ s(x) + s(z))
  						else gam(y ~ s(x, fx=TRUE, k=df.additive[1]+1) +
  									s(z, fx=TRUE, k=(rev(df.additive+1)[1]+1)))
  				)
  				if (model.summary) summaries[[f]] <- summary(mod)
  				yhat <- matrix(predict(mod, newdata=dat), grid.lines, grid.lines)
  				if (fill) rgl.surface(vals, vals, yhat, color=surface.col[i], alpha=0.5, lit=FALSE)
  				if(grid) rgl.surface(vals, vals, yhat, color=if (fill) grid.col
  							else surface.col[i], alpha=0.5, lit=FALSE, front="lines", back="lines")
  				if (residuals){
  					n <- length(y)
  					fitted <- fitted(mod)
  					colors <- ifelse(residuals(mod) > 0, pos.res.col, neg.res.col)
  					rgl.lines(as.vector(rbind(x,x)), as.vector(rbind(y,fitted)), as.vector(rbind(z,z)),
  						color=as.vector(rbind(colors,colors)))
  					if (squares){
  						res <- y - fitted
  						xx <- as.vector(rbind(x, x, x + res, x + res))
  						yy <- as.vector(rbind(y, fitted, fitted, y))
  						zz <- as.vector(rbind(z, z, z, z))
  						rgl.quads(xx, yy, zz, color=square.col, alpha=0.5, lit=FALSE)
  						rgl.lines(xx, yy, zz, color=square.col)
  					}
  				}
  			}
  			else{
  				if (parallel){
  					mod <- switch(f,
  						linear = lm(y ~ x + z + groups),
  						quadratic = lm(y ~ (x + z)^2 + I(x^2) + I(z^2) + groups),
  						smooth = if (is.null(df.smooth)) gam(y ~ s(x, z) + groups)
  							else gam(y ~ s(x, z, fx=TRUE, k=df.smooth) + groups),
  						additive = if (is.null(df.additive)) gam(y ~ s(x) + s(z) + groups)
  							else gam(y ~ s(x, fx=TRUE, k=df.additive[1]+1) +
  										s(z, fx=TRUE, k=(rev(df.additive+1)[1]+1)) + groups)
  					)
  					if (model.summary) summaries[[f]] <- summary(mod)
  					levs <- levels(groups)
  					for (j in 1:length(levs)){
  						group <- levs[j]
  						select.obs <- groups == group
  						yhat <- matrix(predict(mod, newdata=cbind(dat, groups=group)), grid.lines, grid.lines)
  						if (fill) rgl.surface(vals, vals, yhat, color=surface.col[j], alpha=0.5, lit=FALSE)
  						if (grid) rgl.surface(vals, vals, yhat, color=if (fill) grid.col
  									else surface.col[j], alpha=0.5, lit=FALSE, front="lines", back="lines")
  						rgl.texts(1, predict(mod, newdata=data.frame(x=1, z=1, groups=group)), 1,
  							paste(group, " "), adj=1, color=surface.col[j])
  						if (residuals){
  							yy <- y[select.obs]
  							xx <- x[select.obs]
  							zz <- z[select.obs]
  							fitted <- fitted(mod)[select.obs]
  							res <- yy - fitted
  							rgl.lines(as.vector(rbind(xx,xx)), as.vector(rbind(yy,fitted)), as.vector(rbind(zz,zz)),
  								col=surface.col[j])
  							if (squares) {
  								xxx <- as.vector(rbind(xx, xx, xx + res, xx + res))
  								yyy <- as.vector(rbind(yy, fitted, fitted, yy))
  								zzz <- as.vector(rbind(zz, zz, zz, zz))
  								rgl.quads(xxx, yyy, zzz, color=surface.col[j], alpha=0.5, lit=FALSE)
  								rgl.lines(xxx, yyy, zzz, color=surface.col[j])
  							}
  						}
  					}
  				}
  				else {
  					levs <- levels(groups)
  					for (j in 1:length(levs)){
  						group <- levs[j]
  						select.obs <- groups == group
  						mod <- switch(f,
  							linear = lm(y ~ x + z, subset=select.obs),
  							quadratic = lm(y ~ (x + z)^2 + I(x^2) + I(z^2), subset=select.obs),
  							smooth = if (is.null(df.smooth)) gam(y ~ s(x, z), subset=select.obs)
  								else gam(y ~ s(x, z, fx=TRUE, k=df.smooth), subset=select.obs),
  							additive = if (is.null(df.additive)) gam(y ~ s(x) + s(z), subset=select.obs)
  								else gam(y ~ s(x, fx=TRUE, k=df.additive[1]+1) +
  											s(z, fx=TRUE, k=(rev(df.additive+1)[1]+1)), subset=select.obs)
  						)
  						if (model.summary) summaries[[paste(f, ".", group, sep="")]] <- summary(mod)
  						yhat <- matrix(predict(mod, newdata=dat), grid.lines, grid.lines)
  						if (fill) rgl.surface(vals, vals, yhat, color=surface.col[j], alpha=0.5, lit=FALSE)
  						if (grid) rgl.surface(vals, vals, yhat, color=if (fill) grid.col
  									else surface.col[j], alpha=0.5, lit=FALSE, front="lines", back="lines")
  						rgl.texts(1, predict(mod, newdata=data.frame(x=1, z=1, groups=group)), 1,
  							paste(group, " "), adj=1, color=surface.col[j])
  						if (residuals){
  							yy <- y[select.obs]
  							xx <- x[select.obs]
  							zz <- z[select.obs]
  							fitted <- fitted(mod)
  							res <- yy - fitted
  							rgl.lines(as.vector(rbind(xx,xx)), as.vector(rbind(yy,fitted)), as.vector(rbind(zz,zz)),
  								col=surface.col[j])
  							if (squares) {
  								xxx <- as.vector(rbind(xx, xx, xx + res, xx + res))
  								yyy <- as.vector(rbind(yy, fitted, fitted, yy))
  								zzz <- as.vector(rbind(zz, zz, zz, zz))
  								rgl.quads(xxx, yyy, zzz, color=surface.col[j], alpha=0.5, lit=FALSE)
  								rgl.lines(xxx, yyy, zzz, color=surface.col[j])
  							}
  						}
  					}
  				}
  			}
  		}
  	}
  	if (revolutions > 0) {
  		for (i in 1:revolutions){
  			for (angle in seq(1, 360, length.out=360/speed)) rgl.viewpoint(-angle, fov=fov)
  		}
  	}
  	if (model.summary) return(summaries) else return(invisible(NULL))
  }


  Rcmdr.select3d <-
  	function (...)
  {
  	rgl:::.check3d()
  	rect <- rgl:::rgl.select(...)
  	llx <- rect[1]
  	lly <- rect[2]
  	urx <- rect[3]
  	ury <- rect[4]
  	if (llx > urx) {
  		temp <- llx
  		llx <- urx
  		urx <- temp
  	}
  	if (lly > ury) {
  		temp <- lly
  		lly <- ury
  		ury <- temp
  	}
  	proj <- rgl:::rgl.projection()
  	function(x, y, z) {
  		pixel <- rgl.user2window(x, y, z, proj = proj)
  		apply(pixel, 1, function(p) (llx <= p[1]) && (p[1] <=
  						urx) && (lly <= p[2]) && (p[2] <= ury) && (0 <= p[3]) &&
  					(p[3] <= 1))
  	}
  }
  identify3d  <-
  	function (x, y, z, axis.scales=TRUE, groups = NULL, labels = 1:length(x),
  		col = c("blue", "green", "orange", "magenta", "cyan", "red", "yellow", "gray"),
  		offset = ((100/length(x))^(1/3)) * 0.02)
  {
  	valid <- if (is.null(groups))
  			complete.cases(x, y, z)
  		else complete.cases(x, y, z, groups)
  	labels <- labels[valid]
  	x <- x[valid]
  	y <- y[valid]
  	z <- z[valid]
  	minx <- min(x)
  	maxx <- max(x)
  	miny <- min(y)
  	maxy <- max(y)
  	minz <- min(z)
  	maxz <- max(z)
  	if (axis.scales){
#  		lab.min.x <- nice(minx)
#  		lab.max.x <- nice(maxx)
#  		lab.min.y <- nice(miny)
#  		lab.max.y <- nice(maxy)
#  		lab.min.z <- nice(minz)
#  		lab.max.z <- nice(maxz)

  		lab.min.x <- minx
  		lab.max.x <- maxx
  		lab.min.y <- miny
  		lab.max.y <- maxy
  		lab.min.z <- minz
  		lab.max.z <- maxz


  		minx <- min(lab.min.x, minx)
  		maxx <- max(lab.max.x, maxx)
  		miny <- min(lab.min.y, miny)
  		maxy <- max(lab.max.y, maxy)
  		minz <- min(lab.min.z, minz)
  		maxz <- max(lab.max.z, maxz)
  		min.x <- (lab.min.x - minx)/(maxx - minx)
  		max.x <- (lab.max.x - minx)/(maxx - minx)
  		min.y <- (lab.min.y - miny)/(maxy - miny)
  		max.y <- (lab.max.y - miny)/(maxy - miny)
  		min.z <- (lab.min.z - minz)/(maxz - minz)
  		max.z <- (lab.max.z - minz)/(maxz - minz)
  	}
  	x <- (x - minx)/(maxx - minx)
  	y <- (y - miny)/(maxy - miny)
  	z <- (z - minz)/(maxz - minz)
  	rgl.bringtotop()
  	identified <- character(0)
  	groups <- if (!is.null(groups))
  			as.numeric(groups[valid])
  		else rep(1, length(x))
  	repeat {
  		f <- Rcmdr.select3d(button="right")
  		which <- f(x, y, z)
  		if (!any(which))
  			break
  		rgl.texts(x[which], y[which] + offset, z[which], labels[which],
  			color = col[groups][which])
  		identified <- c(identified, labels[which])
  	}
  	unique(identified)
  }




  e$plot3D = function(){

    currentDevice = dev.cur()
    defaultText =  "Drop name here"

    noConflicts = TRUE

    scatterPlot3DWindow = gwindow("3D Scatter Plot Controls", parent = e$win)  # when you close this window make the current device the embedded plot
    scatterPlot3DGp = ggroup(horizontal = FALSE)

    dropGroup = ggroup(horizontal = TRUE)

    dropLayout = glayout()

    responseLabel =   glabel("  Response     :")
    font(responseLabel) <- list(weight="bold", family = "normal")
    covariateLabel1 = glabel("  Covariate 1  :")
    font(covariateLabel1) <- list(weight="bold", family = "normal")
    covariateLabel2 = glabel("  Covariate 2  :")
    font(covariateLabel2) <- list(weight="bold", family = "normal")
    groupLabel = glabel("  Group by     :")
    font(groupLabel) <- list(weight="bold", family = "normal")

    responseDrop = glabel(defaultText)
    covariateDrop1 = glabel(defaultText)
    covariateDrop2 = glabel(defaultText)
    groupDrop = glabel(defaultText)

    dropLayout[2,1] = responseLabel
    dropLayout[2,2] = responseDrop
    dropLayout[2,3] = gbutton("clear", handler = function(h,...) svalue(responseDrop) = defaultText)
    dropLayout[3,1] = covariateLabel1
    dropLayout[3,2] = covariateDrop1
    dropLayout[3,3] = gbutton("clear", handler = function(h,...) svalue(covariateDrop1) = defaultText)
    dropLayout[4,1] = covariateLabel2
    dropLayout[4,2] = covariateDrop2
    dropLayout[4,3] = gbutton("clear", handler = function(h,...) svalue(covariateDrop2) = defaultText)
    dropLayout[3,5] = groupLabel
    dropLayout[3,6] = groupDrop
    dropLayout[3,7] = gbutton("clear", handler = function(h,...) svalue(groupDrop) = defaultText)

    add(dropGroup, dropLayout)


    controlsGroupMain = ggroup(horizontal = TRUE)
    plot3DImage = gimage(filename =paste(OrigPath,"/scatter3dunmoving2.jpg",sep=""), size = "dialog")
    add(controlsGroupMain, plot3DImage)
    controlsGroup = ggroup(horizontal = FALSE)
    controlsGroupLayout = glayout()



    sectionTitle1 = glabel("Surfaces to Fit")
    font(sectionTitle1) <- list(weight="bold", family = "normal"
    )
#
#    controlsGroupLayout[2,1] = glabel("Show surface grid lines")
#    controlsGroupLayout[3,1] = glabel("Show surface residuals")
#    controlsGroupLayout[4,1] = sectionTitle1
#    controlsGroupLayout[5,1] = glabel("Linear least-squares")
#    controlsGroupLayout[6,1] = glabel("Quadratic least-squares")



    gridLines = gcheckbox("Show surface grid lines", checked = TRUE)
    surfaceResiduals = gcheckbox("Show surface residuals")
    plotSurface = gcheckbox("Plot surface(s)", checked = TRUE)
    linearLS = gcheckbox("Linear least-squares", checked = TRUE)
    quadraticLS = gcheckbox("Quadratic least-squares")
    multipleSurfaceParallel = gcheckbox("Parallel surfaces\n(when plotting surfaces by groups)", checked = TRUE)

    e$canIdentify = FALSE
    #e$deviceNumber = -100


    plotButton = gbutton("Plot in 3D", handler = function(h, ...){

        X = svalue(covariateDrop1)
        Z = svalue(covariateDrop2)
        Y = svalue(responseDrop)
        G = svalue(groupDrop)

        groups = NULL

        if(defaultText %in% c(X,Y,Z)){
          noConflicts = FALSE
          gmessage("3 variables are needed to create a 3-dimensional plot" , parent = e$win)
        }else{

        xData = eval(parse(text = paste("tag(e$obj, \"dataSet\")", "$", svalue(covariateDrop1), collapse = "")))
        zData = eval(parse(text = paste("tag(e$obj, \"dataSet\")", "$", svalue(covariateDrop2), collapse = "")))
        yData = eval(parse(text = paste("tag(e$obj, \"dataSet\")", "$", svalue(responseDrop), collapse = "")))
        gData = NULL

        if(G != defaultText)
          gData = eval(parse(text = paste("tag(e$obj, \"dataSet\")", "$", svalue(groupDrop), collapse = "")))


        if(!is.factor(xData) && !is.factor(yData) && !is.factor(zData)){
          noConflicts = TRUE
          if(!is.null(gData)){
            if(!is.factor(gData)){
              gmessage("The grouping variable MUST be a factor!", parent = e$win)
              noConflicts = FALSE
            }
          }

         }else{
           gmessage("One or more of the main variables is a factor!", parent = e$win)
           noConflicts = FALSE
         }
        }

    if(noConflicts){
        fit = c("linear", "quadratic")

        if(any(c(svalue(linearLS),svalue(quadraticLS))))
          fit = fit[c(svalue(linearLS), svalue(quadraticLS))]
        else{
          svalue(linearLS) = TRUE
          fit = "linear"

        }
        e$deviceNumber = dev.cur()
        scatter3d(xData, yData, zData, xlab = X, ylab = Y, zlab = Z, bg.col = "black", fit = fit, sphere.size = 1, surface = svalue(plotSurface), groups = gData, parallel = svalue(multipleSurfaceParallel), grid = svalue(gridLines), residuals = svalue(surfaceResiduals))


#        scatter3d(eval(parse(text = paste("tag(e$obj, \"dataSet\")", "$", svalue(covariateDrop1), collapse = ""))), eval(parse(text = paste("tag(e$obj, \"dataSet\")", "$", svalue(responseDrop), collapse = ""))), eval(parse(text = paste("tag(e$obj, \"dataSet\")", "$", svalue(covariateDrop2), collapse = ""))),
#                  xlab = svalue(covariateDrop1), ylab = svalue(responseDrop), zlab = svalue(covariateDrop2),bg.col = "black", fit = fit, grid = svalue(gridLines), residuals = svalue(surfaceResiduals))
#
        e$canIdentify = TRUE

     }

    })

    identifyButton = gbutton("Identify Points", handler = function(h,...){

            #if(e$deviceNumber != dev.cur())  e$canIdentify = FALSE

            if(e$canIdentify)
                identify3d(eval(parse(text = paste("tag(e$obj, \"dataSet\")", "$", svalue(covariateDrop1), collapse = ""))), col = "white", eval(parse(text = paste("tag(e$obj, \"dataSet\")", "$", svalue(responseDrop), collapse = ""))), eval(parse(text = paste("tag(e$obj, \"dataSet\")", "$", svalue(covariateDrop2), collapse = ""))))
                  #identify3d(x, y, z, axis.scales=TRUE, groups=NULL, labels=1:length(x),
#                      col=c("blue", "green", "orange", "magenta", "cyan", "red", "yellow", "gray"),
#                      offset = ((100/length(x))^(1/3)) * 0.02)




            })

    identifyGp = ggroup(horizontal = FALSE)
    addSpace(identifyGp, 10, horizontal = FALSE)
    #font(plotButton) = list(style="bold")
    add(identifyGp, plotButton)
    #font(identifyButton) = list(style="bold")
    addSpace(identifyGp, 5, horizontal = FALSE)
    add(identifyGp, identifyButton)
    add(identifyGp, glabel("Drag right mouse button to identify points,\nclick right button to exit"), expand = TRUE)

    controlsGroupLayout[2,2] = gridLines
    controlsGroupLayout[3,2] = surfaceResiduals
    controlsGroupLayout[4,2] = sectionTitle1
    controlsGroupLayout[5,2] = plotSurface
    controlsGroupLayout[6,2] = linearLS
    controlsGroupLayout[7,2] = quadraticLS
    controlsGroupLayout[8,2] = multipleSurfaceParallel
    #controlsGroupLayout[8,3] = plotButton


    adddroptarget(responseDrop, handler = function(h,...) svalue(responseDrop) = id(h$dropdata))
    adddroptarget(covariateDrop2, handler = function(h,...) svalue(covariateDrop2) = id(h$dropdata))
    adddroptarget(covariateDrop1, handler = function(h,...) svalue(covariateDrop1) = id(h$dropdata))
    adddroptarget(groupDrop, handler = function(h,...) svalue(groupDrop) = id(h$dropdata))

    add(controlsGroup, controlsGroupLayout)
    add(controlsGroup, identifyGp)
    add(scatterPlot3DGp, dropGroup)
    add(controlsGroupMain, controlsGroup)
    add(scatterPlot3DGp, controlsGroupMain)

    add(scatterPlot3DWindow, scatterPlot3DGp)

  }

  addInferenceInfo = function(){

    xVarData = tag(e$obj,"xVarData")
    yVarData = tag(e$obj,"yVarData")
    groupingVarData = tag(e$obj,"groupingVarData")

    showSmoothnessSlider = FALSE

    optionsForDotcharts = FALSE
    optionsForBarCharts = FALSE


    if(!is.null(e$xVarData)){

      if(!is.factor(svalue(e$xVarData)))  optionsForDotcharts = TRUE
      else  optionsForBarCharts = TRUE

      if(!is.null(e$yVarData)){

        if(!is.factor(svalue(e$xVarData)) && !is.factor(svalue(e$yVarData))) optionsForDotcharts = FALSE  # This condition is sneaky
        else if(!is.factor(svalue(e$yVarData)) || !is.factor(svalue(e$xVarData))){
           optionsForDotcharts = TRUE
           optionsForBarCharts = FALSE    #if(optionsForBarCharts)
        }

      }

    }


    if(optionsForDotcharts){

         e$inferenceWinOpened = TRUE
         e$dndDisabled = TRUE
         inferenceWin = gwindow("Add Inference Info", cont = TRUE, width = 250, height = 250, parent = e$win)
         addHandlerUnrealize(inferenceWin, handler = function(h,...){

           e$inferenceWinOpened = FALSE
           e$dndDisabled = FALSE
           # DISABLE ALL OTHER THINGS THAT CAN UPDATE THE PLOT  ---------- 11th August (Not Done YET)
           dispose(inferenceWin)
         })
         inferenceMain = ggroup(horizontal = FALSE, expand = TRUE, cont = inferenceWin)

         lbl1 = glabel("Choose Parameter :")
         font(lbl1) <- list(weight="bold", family = "normal")

         lbl4 = glabel("Interval Type :")
         font(lbl4) <- list(weight="bold", family = "normal")

         intervalList = gradio(c("Comparison Intervals", "Comparison + Confidence Intervals"))

         lbl5 = glabel("Method to use :")
         font(lbl5) <- list(weight="bold", family = "normal")

         #methodList = gradio(c("Bootstrap", "Normal"), horizontal = FALSE)
         methodList = gradio(c("Bootstrap", "Year 12"), selected = 2, horizontal = FALSE) # c("Bootstrap", "Year 12 Method")  c("Bootstrap", "N/A")

         parameterList = gradio(c("Medians", "Means"), selected = 1, horizontal = FALSE, handler = function(h,...){
                                                                           if(svalue(h$obj, index = TRUE) == 1) methodList[] = c("Bootstrap", "Year 12")
                                                                           else methodList[] = c("Bootstrap", "Normal")
                                                                           })

         inferenceLayout = glayout()

         inferenceLayout[2,2, anchor = c(-1,0)] = lbl1
         inferenceLayout[2,3:4, anchor = c(-1,-1)] = parameterList
         inferenceLayout[4,2, anchor = c(-1,0)] = lbl4
         inferenceLayout[4,3:4, anchor = c(-1,-1)] = intervalList
         inferenceLayout[6,2, anchor = c(-1,0)] = lbl5
         inferenceLayout[6,3:4, anchor = c(-1,-1)] = methodList
         inferenceLayout[8,4] = gbutton("Add Intervals", handler = function(h,...){
                                                                                e$drawBoxPlots = (svalue(parameterList) == "Medians");
                                                                                e$drawBothInf = (svalue(intervalList) == "Comparison + Confidence Intervals");
                                                                                e$useBootstrap = (svalue(methodList) == "Bootstrap")
                                                                                e$drawIntervals = TRUE
                                                                                e$inferenceWinOpened = FALSE
                                                                                e$dndDisabled = FALSE
                                                                                updatePlot()
                                                                                dispose(inferenceWin)
                                                                                # Right now not taking into consideration the method
                                                                              })

         visible(inferenceLayout) = TRUE


         add(inferenceMain, inferenceLayout)

    }else if(optionsForBarCharts){

         e$inferenceWinOpened = TRUE
         e$dndDisabled = TRUE
         inferenceWin = gwindow("Add Inference Info", cont = TRUE, width = 250, height = 250, parent = e$win)
         addHandlerUnrealize(inferenceWin, handler = function(h,...){

           e$inferenceWinOpened = FALSE
           e$dndDisabled = FALSE
           # DISABLE ALL OTHER THINGS THAT CAN UPDATE THE PLOT  ---------- 11th August (Not Done YET)
           dispose(inferenceWin)
         })
         inferenceMain = ggroup(horizontal = FALSE, expand = TRUE, cont = inferenceWin)

         lbl1 = glabel("Choose Parameter :")
         font(lbl1) <- list(weight="bold", family = "normal")

         lbl4 = glabel("Interval Type :")
         font(lbl4) <- list(weight="bold", family = "normal")

         intervalList = gradio(c("Comparison Intervals", "Comparison + Confidence Intervals"))

         lbl5 = glabel("Method to use :")
         font(lbl5) <- list(weight="bold", family = "normal")

         methodList = gradio(c("Bootstrap", "Normal"), selected = 2, horizontal = FALSE)

         inferenceLayout = glayout()

         inferenceLayout[2,2, anchor = c(-1,0)] = lbl1
         inferenceLayout[2,3:4, anchor = c(-1,0)] = glabel("      Proportions")
         inferenceLayout[4,2, anchor = c(-1,0)] = lbl4
         inferenceLayout[4,3:4, anchor = c(-1,-1)] = intervalList
         inferenceLayout[6,2, anchor = c(-1,0)] = lbl5
         inferenceLayout[6,3:4, anchor = c(-1,-1)] = methodList
         inferenceLayout[8,4] = gbutton("Add Intervals", handler = function(h,...){  e$drawBothInf = (svalue(intervalList) == "Comparison + Confidence Intervals");
                                                                                e$useBootstrap = (svalue(methodList) == "Bootstrap")
                                                                                e$drawIntervals = TRUE
                                                                                e$inferenceWinOpened = FALSE
                                                                                e$dndDisabled = FALSE
                                                                                updatePlot()
                                                                                dispose(inferenceWin)
                                                                              })

         visible(inferenceLayout) = TRUE


         add(inferenceMain, inferenceLayout)


    }

    if(e$scatterPlotView){

      if(e$addSmoother || e$addLinearTrend || e$addQuadTrend || e$addCubicTrend){

        #Perhaps give the users a chance to modify how many bootstrap lines they want
        e$drawBootLines = TRUE
        e$inferenceWinOpened = FALSE
        e$dndDisabled = FALSE
        updatePlot()
        #dispose(inferenceWin)
      }else
        gmessage(title = "INFO", message = "Add a smoother and/or trend curves before adding confidence bands"
                , icon = "info", cont = TRUE, parent = e$win)
    }
  }



  removeAll = function(){ e$addSmoother = FALSE; e$addYequalsX = FALSE;
                          e$addLinearTrend = FALSE; e$addQuadTrend = FALSE; e$addCubicTrend = FALSE;
                          e$fifthVariable = NULL; e$fifthVariableSubset = NULL; e$fifthVarName = "";
                          e$sixthVariable = NULL; e$sixthVariableSubset = NULL; e$sixthVarName = "";
                          e$segmentVariable = NULL; e$segmentVariableSubset = NULL; e$segmentVarName = "";
                          e$addRugY = FALSE; e$addRugX = FALSE; e$addRugYhat = FALSE;
                          e$addJitterX = FALSE; e$addJitterY = FALSE;
                          e$drawBoxPlots = TRUE; e$drawBothInf = FALSE; e$drawIntervals = FALSE; e$useBootstrap = FALSE;
                          e$basicScatterColor = "black"; e$basicDotColor = "grey50"
                          e$basicCexScatter = 1; e$basicCexDot = 1
                          e$basicPlottingCharScatter = 1; e$basicPlottingCharDot = 1
                          e$scatterThickness1 = 1; e$scatterThickness2 = 2
                          e$basicBackgroundDot = "white"; e$basicBackgroundScatter = "white"
                          e$drawBootLines = FALSE
                          e$joinByLines = FALSE
                          #updatePlot()
                        }

  removeSmoothers = function() e$addSmoother = FALSE #; updatePlot()
  removeYequalsX = function() e$addYequalsX = FALSE
  removeTrendLines = function(){e$addLinearTrend = FALSE; e$addQuadTrend = FALSE; e$addCubicTrend = FALSE}
  stopColorCoding = function(){ e$fifthVariable = NULL; e$fifthVariableSubset = NULL; e$fifthVarName = ""}
  stopResizing = function(){ e$sixthVariable = NULL; e$sixthVariableSubset = NULL; e$sixthVarName = ""}
  stopSegmentation = function(){ e$segmentVariable = NULL; e$segmentVariableSubset = NULL; e$segmentVarName = ""}
  removeRugs = function(){ e$addRugY = FALSE; e$addRugX = FALSE; e$addRugYhat = FALSE}
  removeJitter = function(){ e$addJitterX = FALSE; e$addJitterY = FALSE}      # Warning: updatePlot() has been removed from all these functions
  defaultThickness = function(){e$scatterThickness1 = 1; e$scatterThickness2 = 2}




  e$removeAdditions = function(){

    e$removeAddWinOpened = TRUE
    e$dndDisabled = TRUE

    removeAddWin = gwindow("Remove Additions", cont = TRUE, width = 210, height = 220, parent = e$win)
    addHandlerUnrealize(removeAddWin, handler = function(h,...){

           e$removeAddWinOpened = FALSE
           e$dndDisabled = FALSE
           # DISABLE ALL OTHER THINGS THAT CAN UPDATE THE PLOT  ---------- 11th August (Not Done YET)
           dispose(removeAddWin)
         })
    removeAddMain = ggroup(horizontal = FALSE, expand = TRUE, cont = removeAddWin)
    addSpace(removeAddMain, 5)
    removeAddSecondary = ggroup()

#    nameList = c("Remove All Additions", "Remove Smoothers", "Remove Y = X line", "Remove Trend Lines", "Stop Colour Coding", "Stop Resizing", "Stop Segmentation", "Remove Rugs", "Remove Jitter", "Restore default symbol colours", "Restore default plotting symbol sizes", "Restore white background", "Remove all confidence intervals", "No symbol interior colour", "Restore default line thickness")


    nameList =  c("Remove all additions",
                  paste("Remove colour coding by", e$fifthVarName),
                  paste("Remove resizing by",e$sixthVarName),
                  "Remove trend curves",
                  "Remove y = x line",
                  "Remove smoothers",
                  "Remove jitter",
                  "Remove rugs",
                  "Remove connecting lines",
                  "Remove segmentation in bar charts",
                  "Remove all confidence intervals",
                  "Remove symbol interior colouring",
                  "Restore default symbol colours",
                  "Restore default plotting symbol sizes",
                  "Restore default background colour",
                  "Restore default line thickness")


    x = gcheckboxgroup(nameList[e$removeAddIndices], cont = removeAddMain)
    addSpring(removeAddSecondary)

    proceedButton = gbutton("  -Proceed-  ", cont = removeAddSecondary, handler = function(h,...){

      checkedBoxes = svalue(x)
      if("Remove all additions" %in% checkedBoxes) removeAll()
      if("Remove smoothers" %in% checkedBoxes) removeSmoothers()
      if("Remove y = x line" %in% checkedBoxes) removeYequalsX()
      if("Remove trend curves" %in% checkedBoxes) removeTrendLines()
      if(paste("Remove colour coding by", e$fifthVarName) %in% checkedBoxes) stopColorCoding()
      if(paste("Remove resizing by",e$sixthVarName) %in% checkedBoxes) stopResizing()
      if("Remove segmentation in bar charts" %in% checkedBoxes) stopSegmentation()
      if("Remove rugs" %in% checkedBoxes) removeRugs()
      if("Remove connecting lines" %in% checkedBoxes) e$joinByLines = FALSE
      if("Remove jitter" %in% checkedBoxes) removeJitter()
      if("Restore default symbol colours" %in% checkedBoxes){if(e$dotChartView)  e$basicDotColor = "grey50" else if (e$scatterPlotView) e$basicScatterColor = "black"}
      if("Restore default plotting symbol sizes" %in% checkedBoxes){if(e$dotChartView) e$basicCexDot = 1 else if(e$scatterPlotView) e$basicCexScatter = 1}
      if("Restore default background colour" %in% checkedBoxes){if(e$dotChartView) e$basicBackgroundDot = "white" else if(e$scatterPlotView) e$basicBackgroundScatter= "white"}
      if("Remove all confidence intervals" %in% checkedBoxes){e$drawBootLines = FALSE;e$drawBoxPlots = TRUE; e$drawBothInf = FALSE; e$drawIntervals = FALSE; e$useBootstrap = FALSE;}
      if("Remove symbol interior colouring" %in% checkedBoxes) if(e$dotChartView) e$basicPlottingCharDot = 1 else if(e$scatterPlotView) e$basicPlottingCharScatter = 1
      if("Restore default line thickness" %in% checkedBoxes) defaultThickness()
      updatePlot()
      e$removeAddWinOpened = FALSE
      e$dndDisabled = FALSE
      dispose(removeAddWin)

    })
    add(removeAddMain, removeAddSecondary)

  }


  e$changePlotCharacteristics = function(){

    #Unused function

  }

  e$clearAllSlots = function(){

      if(!(svalue(xVar) == "Drop name here" && svalue(yVar) == "Drop name here"  && svalue(groupingVar) == "Drop name here" && svalue(groupingVar2) == "Drop name here"))
        add(nb, ggraphics(expand = TRUE),label = "plot")

      svalue(xVar) <- "Drop name here"
      e$xVarData = NULL
      tag(e$obj,"xVarData") = NULL
      svalue(yVar) <- "Drop name here"
      e$yVarData = NULL
      tag(e$obj,"yVarData") = NULL
      svalue(groupingVar) <- "Drop name here"
      e$groupingVarData = NULL
      tag(e$obj,"groupingVarData") = NULL
      tag(e$obj,  "sliderData") = NULL
      if(e$sliderCreated){
        delete(e$firstSliderGp, e$grpSlider)
        delete(e$firstSliderGp, e$lbl)
        e$sliderCreated = FALSE
      }
      if(e$sliderCreated2){
        delete(e$secondSliderGp, e$grpSlider2)
        delete(e$secondSliderGp, e$lbl2)
        e$sliderCreated2 = FALSE
      }
      e$fourthVariable = NULL
      e$fourthVarName = ""
      svalue(groupingVar2) <- "Drop name here"
      e$groupingVarData2 = NULL
      tag(e$obj,"groupingVarData2") = NULL
      tag(e$obj,  "sliderData2") = NULL


  }
  return(e$obj)

}


################################################################################
################################################################################
################################################################################
################################################################################

#dynamicPlot()